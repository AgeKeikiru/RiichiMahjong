/* Environment.c generated by valac 0.12.0, the Vala compiler
 * generated from Environment.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL2/SDL_video.h>
#include <SDL2/SDL.h>
#include <GL/glew.h>
#include <SDL2/SDL_net.h>
#include <SDL2/SDL_image.h>
#include <gobject/gvaluecollector.h>


#define TYPE_ENVIRONMENT (environment_get_type ())
#define ENVIRONMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ENVIRONMENT, Environment))
#define ENVIRONMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ENVIRONMENT, EnvironmentClass))
#define IS_ENVIRONMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ENVIRONMENT))
#define IS_ENVIRONMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ENVIRONMENT))
#define ENVIRONMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ENVIRONMENT, EnvironmentClass))

typedef struct _Environment Environment;
typedef struct _EnvironmentClass EnvironmentClass;
typedef struct _EnvironmentPrivate EnvironmentPrivate;

#define ENVIRONMENT_TYPE_CURSOR_TYPE (environment_cursor_type_get_type ())
#define _SDL_free0(var) ((var == NULL) ? NULL : (var = (SDL_free (var), NULL)))
#define _SDL_FreeCursor0(var) ((var == NULL) ? NULL : (var = (SDL_FreeCursor (var), NULL)))
#define _g_rand_free0(var) ((var == NULL) ? NULL : (var = (g_rand_free (var), NULL)))
typedef struct _ParamSpecEnvironment ParamSpecEnvironment;

struct _Environment {
	GTypeInstance parent_instance;
	volatile int ref_count;
	EnvironmentPrivate * priv;
};

struct _EnvironmentClass {
	GTypeClass parent_class;
	void (*finalize) (Environment *self);
};

typedef enum  {
	ENVIRONMENT_CURSOR_TYPE_DEFAULT,
	ENVIRONMENT_CURSOR_TYPE_HOVER
} EnvironmentCursorType;

struct _ParamSpecEnvironment {
	GParamSpec parent_instance;
};


static gpointer environment_parent_class = NULL;
extern SDL_Window* environment_window;
SDL_Window* environment_window = NULL;
static GRand* environment_rand;
static GRand* environment_rand = NULL;
static gboolean environment_initialized;
static gboolean environment_initialized = FALSE;
static SDL_GLContext* environment_context;
static SDL_GLContext* environment_context = NULL;
static SDL_Cursor* environment_default_cursor;
static SDL_Cursor* environment_default_cursor = NULL;
static SDL_Cursor* environment_hover_cursor;
static SDL_Cursor* environment_hover_cursor = NULL;

gpointer environment_ref (gpointer instance);
void environment_unref (gpointer instance);
GParamSpec* param_spec_environment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_environment (GValue* value, gpointer v_object);
void value_take_environment (GValue* value, gpointer v_object);
gpointer value_get_environment (const GValue* value);
GType environment_get_type (void) G_GNUC_CONST;
enum  {
	ENVIRONMENT_DUMMY_PROPERTY
};
GType environment_cursor_type_get_type (void) G_GNUC_CONST;
#define ENVIRONMENT_ORIGINAL_WINDOW_WIDTH 1280
#define ENVIRONMENT_ORIGINAL_WINDOW_HEIGHT 720
gboolean environment_init (void);
gboolean sound_init (void);
void sound_quit (void);
void environment_exit (void);
void texture_clear_cache (void);
void environment_set_cursor (EnvironmentCursorType type);
Environment* environment_new (void);
Environment* environment_construct (GType object_type);
GRand* environment_get_random (void);
static void environment_finalize (Environment* obj);

static const GLfloat ENVIRONMENT_light_ambient[4] = {(GLfloat) 0.0f, (GLfloat) 0.0f, (GLfloat) 0.0f, (GLfloat) 1.0f};
static const GLfloat ENVIRONMENT_light_diffuse[4] = {(GLfloat) 1.0f, (GLfloat) 1.0f, (GLfloat) 1.0f, (GLfloat) 1.0f};
static const GLfloat ENVIRONMENT_light_specular[4] = {(GLfloat) 1.0f, (GLfloat) 1.0f, (GLfloat) 1.0f, (GLfloat) 1.0f};
static const GLfloat ENVIRONMENT_light_position[4] = {(GLfloat) 2.0f, (GLfloat) 5.0f, (GLfloat) 5.0f, (GLfloat) 0.0f};
static const GLfloat ENVIRONMENT_mat_ambient[4] = {(GLfloat) 0.7f, (GLfloat) 0.7f, (GLfloat) 0.7f, (GLfloat) 1.0f};
static const GLfloat ENVIRONMENT_mat_diffuse[4] = {(GLfloat) 0.8f, (GLfloat) 0.8f, (GLfloat) 0.8f, (GLfloat) 1.0f};
static const GLfloat ENVIRONMENT_mat_specular[4] = {(GLfloat) 1.0f, (GLfloat) 1.0f, (GLfloat) 1.0f, (GLfloat) 1.0f};
static const GLfloat ENVIRONMENT_high_shininess[1] = {(GLfloat) 100.0f};

GType environment_cursor_type_get_type (void) {
	static volatile gsize environment_cursor_type_type_id__volatile = 0;
	if (g_once_init_enter (&environment_cursor_type_type_id__volatile)) {
		static const GEnumValue values[] = {{ENVIRONMENT_CURSOR_TYPE_DEFAULT, "ENVIRONMENT_CURSOR_TYPE_DEFAULT", "default"}, {ENVIRONMENT_CURSOR_TYPE_HOVER, "ENVIRONMENT_CURSOR_TYPE_HOVER", "hover"}, {0, NULL, NULL}};
		GType environment_cursor_type_type_id;
		environment_cursor_type_type_id = g_enum_register_static ("EnvironmentCursorType", values);
		g_once_init_leave (&environment_cursor_type_type_id__volatile, environment_cursor_type_type_id);
	}
	return environment_cursor_type_type_id__volatile;
}


gboolean environment_init (void) {
	gboolean result = FALSE;
	gint _tmp0_;
	gboolean _tmp1_;
	gint _tmp2_;
	SDL_Window* _tmp3_ = NULL;
	SDL_GLContext* _tmp4_ = NULL;
	SDL_Surface* _tmp5_ = NULL;
	SDL_Cursor* _tmp6_ = NULL;
	SDL_Cursor* _tmp7_ = NULL;
	GRand* _tmp8_ = NULL;
	if (environment_initialized) {
		result = TRUE;
		return result;
	}
	_tmp0_ = SDL_Init ((guint32) SDL_INIT_EVERYTHING);
	if (_tmp0_ < 0) {
		result = FALSE;
		return result;
	}
	_tmp1_ = sound_init ();
	if (!_tmp1_) {
		SDL_Quit ();
		result = FALSE;
		return result;
	}
	_tmp2_ = SDLNet_Init ();
	if (_tmp2_ < 0) {
		sound_quit ();
		SDL_Quit ();
		result = FALSE;
		return result;
	}
	_tmp3_ = SDL_CreateWindow ("Riichi Mahjong", (gint) SDL_WINDOWPOS_CENTERED_MASK, (gint) SDL_WINDOWPOS_CENTERED_MASK, ENVIRONMENT_ORIGINAL_WINDOW_WIDTH, ENVIRONMENT_ORIGINAL_WINDOW_HEIGHT, (guint32) (SDL_WINDOW_RESIZABLE | SDL_WINDOW_OPENGL));
	_SDL_free0 (environment_window);
	environment_window = _tmp3_;
	if (environment_window == NULL) {
		SDL_Quit ();
		sound_quit ();
		SDLNet_Quit ();
		result = FALSE;
		return result;
	}
	_tmp4_ = SDL_GL_CreateContext (environment_window);
	environment_context = _tmp4_;
	if (environment_context == NULL) {
		SDL_DestroyWindow (environment_window);
		SDL_Quit ();
		sound_quit ();
		SDLNet_Quit ();
		result = FALSE;
		return result;
	}
	SDL_GL_SetAttribute (SDL_GL_CONTEXT_MAJOR_VERSION, 3);
	SDL_GL_SetAttribute (SDL_GL_CONTEXT_MINOR_VERSION, 1);
	SDL_GL_SetSwapInterval (1);
	glewInit ();
	glEnable (GL_CULL_FACE);
	glEnable (GL_DEPTH_TEST);
	glDepthFunc ((GLenum) GL_LEQUAL);
	glEnable (GL_LINE_SMOOTH);
	glEnable (GL_BLEND);
	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glShadeModel ((GLenum) GL_SMOOTH);
	glEnable ((GLenum) GL_LIGHT0);
	glEnable ((GLenum) GL_NORMALIZE);
	glEnable ((GLenum) GL_COLOR_MATERIAL);
	glEnable ((GLenum) GL_LIGHTING);
	glLightfv ((GLenum) GL_LIGHT0, (GLenum) GL_AMBIENT, ENVIRONMENT_light_ambient);
	glLightfv ((GLenum) GL_LIGHT0, (GLenum) GL_DIFFUSE, ENVIRONMENT_light_diffuse);
	glLightfv ((GLenum) GL_LIGHT0, (GLenum) GL_SPECULAR, ENVIRONMENT_light_specular);
	glLightfv ((GLenum) GL_LIGHT0, (GLenum) GL_POSITION, ENVIRONMENT_light_position);
	glMaterialfv ((GLenum) GL_FRONT, (GLenum) GL_AMBIENT, ENVIRONMENT_mat_ambient);
	glMaterialfv ((GLenum) GL_FRONT, (GLenum) GL_DIFFUSE, ENVIRONMENT_mat_diffuse);
	glMaterialfv ((GLenum) GL_FRONT, (GLenum) GL_SPECULAR, ENVIRONMENT_mat_specular);
	glMaterialfv ((GLenum) GL_FRONT, (GLenum) GL_SHININESS, ENVIRONMENT_high_shininess);
	_tmp5_ = IMG_Load ("textures/Icon.png");
	SDL_SetWindowIcon (environment_window, _tmp5_);
	SDL_SetWindowSize (environment_window, ENVIRONMENT_ORIGINAL_WINDOW_WIDTH, ENVIRONMENT_ORIGINAL_WINDOW_HEIGHT);
	SDL_ShowWindow (environment_window);
	SDL_StartTextInput ();
	_tmp6_ = SDL_CreateSystemCursor (SDL_SYSTEM_CURSOR_HAND);
	_SDL_FreeCursor0 (environment_hover_cursor);
	environment_hover_cursor = _tmp6_;
	_tmp7_ = SDL_CreateSystemCursor (SDL_SYSTEM_CURSOR_ARROW);
	_SDL_FreeCursor0 (environment_default_cursor);
	environment_default_cursor = _tmp7_;
	_tmp8_ = g_rand_new ();
	_g_rand_free0 (environment_rand);
	environment_rand = _tmp8_;
	environment_initialized = TRUE;
	result = TRUE;
	return result;
}


void environment_exit (void) {
	if (environment_initialized) {
		SDL_GL_DeleteContext (environment_context);
		sound_quit ();
		SDLNet_Quit ();
		SDL_DestroyWindow (environment_window);
		SDL_StopTextInput ();
		_SDL_FreeCursor0 (environment_default_cursor);
		environment_default_cursor = NULL;
		_SDL_FreeCursor0 (environment_hover_cursor);
		environment_hover_cursor = NULL;
		SDL_Quit ();
		texture_clear_cache ();
	}
}


void environment_set_cursor (EnvironmentCursorType type) {
	switch (type) {
		case ENVIRONMENT_CURSOR_TYPE_HOVER:
		{
			SDL_SetCursor (environment_hover_cursor);
			break;
		}
		case ENVIRONMENT_CURSOR_TYPE_DEFAULT:
		{
			SDL_SetCursor (environment_default_cursor);
			break;
		}
		default:
		break;
	}
}


Environment* environment_construct (GType object_type) {
	Environment* self = NULL;
	self = (Environment*) g_type_create_instance (object_type);
	return self;
}


Environment* environment_new (void) {
	return environment_construct (TYPE_ENVIRONMENT);
}


GRand* environment_get_random (void) {
	GRand* result;
	result = environment_rand;
	return result;
}


static void value_environment_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_environment_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		environment_unref (value->data[0].v_pointer);
	}
}


static void value_environment_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = environment_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_environment_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_environment_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Environment* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = environment_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_environment_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Environment** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = environment_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_environment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecEnvironment* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_ENVIRONMENT), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_environment (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_ENVIRONMENT), NULL);
	return value->data[0].v_pointer;
}


void value_set_environment (GValue* value, gpointer v_object) {
	Environment* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_ENVIRONMENT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_ENVIRONMENT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		environment_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		environment_unref (old);
	}
}


void value_take_environment (GValue* value, gpointer v_object) {
	Environment* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_ENVIRONMENT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_ENVIRONMENT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		environment_unref (old);
	}
}


static void environment_class_init (EnvironmentClass * klass) {
	environment_parent_class = g_type_class_peek_parent (klass);
	ENVIRONMENT_CLASS (klass)->finalize = environment_finalize;
}


static void environment_instance_init (Environment * self) {
	self->ref_count = 1;
}


static void environment_finalize (Environment* obj) {
	Environment * self;
	self = ENVIRONMENT (obj);
}


GType environment_get_type (void) {
	static volatile gsize environment_type_id__volatile = 0;
	if (g_once_init_enter (&environment_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_environment_init, value_environment_free_value, value_environment_copy_value, value_environment_peek_pointer, "p", value_environment_collect_value, "p", value_environment_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (EnvironmentClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) environment_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Environment), 0, (GInstanceInitFunc) environment_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType environment_type_id;
		environment_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Environment", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&environment_type_id__volatile, environment_type_id);
	}
	return environment_type_id__volatile;
}


gpointer environment_ref (gpointer instance) {
	Environment* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void environment_unref (gpointer instance) {
	Environment* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ENVIRONMENT_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



