/* Threading.c generated by valac 0.12.0, the Vala compiler
 * generated from Threading.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gobject/gvaluecollector.h>


#define TYPE_THREADING (threading_get_type ())
#define THREADING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_THREADING, Threading))
#define THREADING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_THREADING, ThreadingClass))
#define IS_THREADING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_THREADING))
#define IS_THREADING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_THREADING))
#define THREADING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_THREADING, ThreadingClass))

typedef struct _Threading Threading;
typedef struct _ThreadingClass ThreadingClass;
typedef struct _ThreadingPrivate ThreadingPrivate;

#define THREADING_TYPE_THREAD (threading_thread_get_type ())
#define THREADING_THREAD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), THREADING_TYPE_THREAD, ThreadingThread))
#define THREADING_THREAD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), THREADING_TYPE_THREAD, ThreadingThreadClass))
#define THREADING_IS_THREAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), THREADING_TYPE_THREAD))
#define THREADING_IS_THREAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), THREADING_TYPE_THREAD))
#define THREADING_THREAD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), THREADING_TYPE_THREAD, ThreadingThreadClass))

typedef struct _ThreadingThread ThreadingThread;
typedef struct _ThreadingThreadClass ThreadingThreadClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define THREADING_TYPE_THREAD0 (threading_thread0_get_type ())
#define THREADING_THREAD0(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), THREADING_TYPE_THREAD0, ThreadingThread0))
#define THREADING_THREAD0_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), THREADING_TYPE_THREAD0, ThreadingThread0Class))
#define THREADING_IS_THREAD0(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), THREADING_TYPE_THREAD0))
#define THREADING_IS_THREAD0_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), THREADING_TYPE_THREAD0))
#define THREADING_THREAD0_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), THREADING_TYPE_THREAD0, ThreadingThread0Class))

typedef struct _ThreadingThread0 ThreadingThread0;
typedef struct _ThreadingThread0Class ThreadingThread0Class;
#define _threading_thread_unref0(var) ((var == NULL) ? NULL : (var = (threading_thread_unref (var), NULL)))

#define THREADING_TYPE_THREAD1 (threading_thread1_get_type ())
#define THREADING_THREAD1(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), THREADING_TYPE_THREAD1, ThreadingThread1))
#define THREADING_THREAD1_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), THREADING_TYPE_THREAD1, ThreadingThread1Class))
#define THREADING_IS_THREAD1(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), THREADING_TYPE_THREAD1))
#define THREADING_IS_THREAD1_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), THREADING_TYPE_THREAD1))
#define THREADING_THREAD1_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), THREADING_TYPE_THREAD1, ThreadingThread1Class))

typedef struct _ThreadingThread1 ThreadingThread1;
typedef struct _ThreadingThread1Class ThreadingThread1Class;

#define THREADING_TYPE_THREAD2 (threading_thread2_get_type ())
#define THREADING_THREAD2(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), THREADING_TYPE_THREAD2, ThreadingThread2))
#define THREADING_THREAD2_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), THREADING_TYPE_THREAD2, ThreadingThread2Class))
#define THREADING_IS_THREAD2(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), THREADING_TYPE_THREAD2))
#define THREADING_IS_THREAD2_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), THREADING_TYPE_THREAD2))
#define THREADING_THREAD2_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), THREADING_TYPE_THREAD2, ThreadingThread2Class))

typedef struct _ThreadingThread2 ThreadingThread2;
typedef struct _ThreadingThread2Class ThreadingThread2Class;

#define THREADING_TYPE_THREAD3 (threading_thread3_get_type ())
#define THREADING_THREAD3(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), THREADING_TYPE_THREAD3, ThreadingThread3))
#define THREADING_THREAD3_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), THREADING_TYPE_THREAD3, ThreadingThread3Class))
#define THREADING_IS_THREAD3(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), THREADING_TYPE_THREAD3))
#define THREADING_IS_THREAD3_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), THREADING_TYPE_THREAD3))
#define THREADING_THREAD3_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), THREADING_TYPE_THREAD3, ThreadingThread3Class))

typedef struct _ThreadingThread3 ThreadingThread3;
typedef struct _ThreadingThread3Class ThreadingThread3Class;
typedef struct _ThreadingThreadPrivate ThreadingThreadPrivate;
typedef struct _ThreadingParamSpecThread ThreadingParamSpecThread;
typedef struct _ThreadingThread0Private ThreadingThread0Private;
typedef struct _ThreadingThread1Private ThreadingThread1Private;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _ThreadingThread2Private ThreadingThread2Private;
typedef struct _ThreadingThread3Private ThreadingThread3Private;
typedef struct _ParamSpecThreading ParamSpecThreading;

#define TYPE_OBJ (obj_get_type ())
#define OBJ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OBJ, Obj))
#define OBJ_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OBJ, ObjClass))
#define IS_OBJ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OBJ))
#define IS_OBJ_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OBJ))
#define OBJ_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OBJ, ObjClass))

typedef struct _Obj Obj;
typedef struct _ObjClass ObjClass;
typedef struct _ObjPrivate ObjPrivate;

struct _Threading {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ThreadingPrivate * priv;
};

struct _ThreadingClass {
	GTypeClass parent_class;
	void (*finalize) (Threading *self);
};

typedef void (*ThreadingDel0Arg) (void* user_data);
typedef void (*ThreadingDel1Arg) (GObject* arg1, void* user_data);
typedef void (*ThreadingDel2Arg) (GObject* arg1, GObject* arg2, void* user_data);
typedef void (*ThreadingDel3Arg) (GObject* arg1, GObject* arg2, GObject* arg3, void* user_data);
struct _ThreadingThread {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ThreadingThreadPrivate * priv;
};

struct _ThreadingThreadClass {
	GTypeClass parent_class;
	void (*finalize) (ThreadingThread *self);
	void (*start) (ThreadingThread* self);
};

struct _ThreadingParamSpecThread {
	GParamSpec parent_instance;
};

struct _ThreadingThread0 {
	ThreadingThread parent_instance;
	ThreadingThread0Private * priv;
};

struct _ThreadingThread0Class {
	ThreadingThreadClass parent_class;
};

struct _ThreadingThread0Private {
	ThreadingThread* self;
	ThreadingDel0Arg func;
	gpointer func_target;
	GDestroyNotify func_target_destroy_notify;
};

struct _ThreadingThread1 {
	ThreadingThread parent_instance;
	ThreadingThread1Private * priv;
};

struct _ThreadingThread1Class {
	ThreadingThreadClass parent_class;
};

struct _ThreadingThread1Private {
	ThreadingThread* self;
	ThreadingDel1Arg func;
	gpointer func_target;
	GDestroyNotify func_target_destroy_notify;
	GObject* arg1;
};

struct _ThreadingThread2 {
	ThreadingThread parent_instance;
	ThreadingThread2Private * priv;
};

struct _ThreadingThread2Class {
	ThreadingThreadClass parent_class;
};

struct _ThreadingThread2Private {
	ThreadingThread* self;
	ThreadingDel2Arg func;
	gpointer func_target;
	GDestroyNotify func_target_destroy_notify;
	GObject* arg1;
	GObject* arg2;
};

struct _ThreadingThread3 {
	ThreadingThread parent_instance;
	ThreadingThread3Private * priv;
};

struct _ThreadingThread3Class {
	ThreadingThreadClass parent_class;
};

struct _ThreadingThread3Private {
	ThreadingThread* self;
	ThreadingDel3Arg func;
	gpointer func_target;
	GDestroyNotify func_target_destroy_notify;
	GObject* arg1;
	GObject* arg2;
	GObject* arg3;
};

struct _ParamSpecThreading {
	GParamSpec parent_instance;
};

struct _Obj {
	GObject parent_instance;
	ObjPrivate * priv;
};

struct _ObjClass {
	GObjectClass parent_class;
};

struct _ObjPrivate {
	GType t_type;
	GBoxedCopyFunc t_dup_func;
	GDestroyNotify t_destroy_func;
	gpointer _obj;
};


static gpointer threading_parent_class = NULL;
static gpointer threading_thread_parent_class = NULL;
static gpointer threading_thread0_parent_class = NULL;
static gpointer threading_thread1_parent_class = NULL;
static gpointer threading_thread2_parent_class = NULL;
static gpointer threading_thread3_parent_class = NULL;
static gpointer obj_parent_class = NULL;

gpointer threading_ref (gpointer instance);
void threading_unref (gpointer instance);
GParamSpec* param_spec_threading (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_threading (GValue* value, gpointer v_object);
void value_take_threading (GValue* value, gpointer v_object);
gpointer value_get_threading (const GValue* value);
GType threading_get_type (void) G_GNUC_CONST;
enum  {
	THREADING_DUMMY_PROPERTY
};
static gpointer threading_thread_ref (gpointer instance);
static void threading_thread_unref (gpointer instance);
static GParamSpec* threading_param_spec_thread (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void threading_value_set_thread (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void threading_value_take_thread (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer threading_value_get_thread (const GValue* value) G_GNUC_UNUSED;
static GType threading_thread_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void threading_start_thread (ThreadingThread* thread);
static void threading_thread_start (ThreadingThread* self);
static gpointer _threading_thread_start_gthread_func (gpointer self);
void threading_start0 (ThreadingDel0Arg function, void* function_target);
static ThreadingThread0* threading_thread0_new (ThreadingDel0Arg func, void* func_target);
static ThreadingThread0* threading_thread0_construct (GType object_type, ThreadingDel0Arg func, void* func_target);
static GType threading_thread0_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
void threading_start1 (ThreadingDel1Arg function, void* function_target, GObject* arg1);
static ThreadingThread1* threading_thread1_new (ThreadingDel1Arg func, void* func_target, GObject* arg1);
static ThreadingThread1* threading_thread1_construct (GType object_type, ThreadingDel1Arg func, void* func_target, GObject* arg1);
static GType threading_thread1_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
void threading_start2 (ThreadingDel2Arg function, void* function_target, GObject* arg1, GObject* arg2);
static ThreadingThread2* threading_thread2_new (ThreadingDel2Arg func, void* func_target, GObject* arg1, GObject* arg2);
static ThreadingThread2* threading_thread2_construct (GType object_type, ThreadingDel2Arg func, void* func_target, GObject* arg1, GObject* arg2);
static GType threading_thread2_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
void threading_start3 (ThreadingDel3Arg function, void* function_target, GObject* arg1, GObject* arg2, GObject* arg3);
static ThreadingThread3* threading_thread3_new (ThreadingDel3Arg func, void* func_target, GObject* arg1, GObject* arg2, GObject* arg3);
static ThreadingThread3* threading_thread3_construct (GType object_type, ThreadingDel3Arg func, void* func_target, GObject* arg1, GObject* arg2, GObject* arg3);
static GType threading_thread3_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
Threading* threading_new (void);
Threading* threading_construct (GType object_type);
gboolean threading_get_threading (void);
enum  {
	THREADING_THREAD_DUMMY_PROPERTY
};
static void threading_thread_real_start (ThreadingThread* self);
static ThreadingThread* threading_thread_construct (GType object_type);
static void threading_thread_finalize (ThreadingThread* obj);
#define THREADING_THREAD0_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), THREADING_TYPE_THREAD0, ThreadingThread0Private))
enum  {
	THREADING_THREAD0_DUMMY_PROPERTY
};
static void threading_thread0_real_start (ThreadingThread* base);
static void threading_thread0_finalize (ThreadingThread* obj);
#define THREADING_THREAD1_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), THREADING_TYPE_THREAD1, ThreadingThread1Private))
enum  {
	THREADING_THREAD1_DUMMY_PROPERTY
};
static void threading_thread1_real_start (ThreadingThread* base);
static void threading_thread1_finalize (ThreadingThread* obj);
#define THREADING_THREAD2_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), THREADING_TYPE_THREAD2, ThreadingThread2Private))
enum  {
	THREADING_THREAD2_DUMMY_PROPERTY
};
static void threading_thread2_real_start (ThreadingThread* base);
static void threading_thread2_finalize (ThreadingThread* obj);
#define THREADING_THREAD3_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), THREADING_TYPE_THREAD3, ThreadingThread3Private))
enum  {
	THREADING_THREAD3_DUMMY_PROPERTY
};
static void threading_thread3_real_start (ThreadingThread* base);
static void threading_thread3_finalize (ThreadingThread* obj);
static void threading_finalize (Threading* obj);
GType obj_get_type (void) G_GNUC_CONST;
#define OBJ_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_OBJ, ObjPrivate))
enum  {
	OBJ_DUMMY_PROPERTY,
	OBJ_T_TYPE,
	OBJ_T_DUP_FUNC,
	OBJ_T_DESTROY_FUNC,
	OBJ_OBJ
};
Obj* obj_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer t);
Obj* obj_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer t);
static void obj_set_obj (Obj* self, gconstpointer value);
gconstpointer obj_get_obj (Obj* self);
static void obj_finalize (GObject* obj);
static void _vala_obj_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_obj_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


static gpointer _threading_thread_start_gthread_func (gpointer self) {
	threading_thread_start (self);
}


static void threading_start_thread (ThreadingThread* thread) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (thread != NULL);
	g_thread_create (_threading_thread_start_gthread_func, thread, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_THREAD_ERROR) {
			goto __catch3_g_thread_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	goto __finally3;
	__catch3_g_thread_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void threading_start0 (ThreadingDel0Arg function, void* function_target) {
	ThreadingThread0* _tmp0_ = NULL;
	ThreadingThread0* _tmp1_;
	_tmp0_ = threading_thread0_new (function, function_target);
	_tmp1_ = _tmp0_;
	threading_start_thread ((ThreadingThread*) _tmp1_);
	_threading_thread_unref0 (_tmp1_);
}


void threading_start1 (ThreadingDel1Arg function, void* function_target, GObject* arg1) {
	ThreadingThread1* _tmp0_ = NULL;
	ThreadingThread1* _tmp1_;
	g_return_if_fail (arg1 != NULL);
	_tmp0_ = threading_thread1_new (function, function_target, arg1);
	_tmp1_ = _tmp0_;
	threading_start_thread ((ThreadingThread*) _tmp1_);
	_threading_thread_unref0 (_tmp1_);
}


void threading_start2 (ThreadingDel2Arg function, void* function_target, GObject* arg1, GObject* arg2) {
	ThreadingThread2* _tmp0_ = NULL;
	ThreadingThread2* _tmp1_;
	g_return_if_fail (arg1 != NULL);
	g_return_if_fail (arg2 != NULL);
	_tmp0_ = threading_thread2_new (function, function_target, arg1, arg2);
	_tmp1_ = _tmp0_;
	threading_start_thread ((ThreadingThread*) _tmp1_);
	_threading_thread_unref0 (_tmp1_);
}


void threading_start3 (ThreadingDel3Arg function, void* function_target, GObject* arg1, GObject* arg2, GObject* arg3) {
	ThreadingThread3* _tmp0_ = NULL;
	ThreadingThread3* _tmp1_;
	g_return_if_fail (arg1 != NULL);
	g_return_if_fail (arg2 != NULL);
	g_return_if_fail (arg3 != NULL);
	_tmp0_ = threading_thread3_new (function, function_target, arg1, arg2, arg3);
	_tmp1_ = _tmp0_;
	threading_start_thread ((ThreadingThread*) _tmp1_);
	_threading_thread_unref0 (_tmp1_);
}


Threading* threading_construct (GType object_type) {
	Threading* self = NULL;
	self = (Threading*) g_type_create_instance (object_type);
	return self;
}


Threading* threading_new (void) {
	return threading_construct (TYPE_THREADING);
}


gboolean threading_get_threading (void) {
	gboolean result;
	gboolean _tmp0_;
	_tmp0_ = g_thread_supported ();
	result = _tmp0_;
	return result;
}


static void threading_thread_real_start (ThreadingThread* self) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `threading_thread_start'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void threading_thread_start (ThreadingThread* self) {
	THREADING_THREAD_GET_CLASS (self)->start (self);
}


static ThreadingThread* threading_thread_construct (GType object_type) {
	ThreadingThread* self = NULL;
	self = (ThreadingThread*) g_type_create_instance (object_type);
	return self;
}


static void threading_value_thread_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void threading_value_thread_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		threading_thread_unref (value->data[0].v_pointer);
	}
}


static void threading_value_thread_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = threading_thread_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer threading_value_thread_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* threading_value_thread_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ThreadingThread* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = threading_thread_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* threading_value_thread_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ThreadingThread** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = threading_thread_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* threading_param_spec_thread (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ThreadingParamSpecThread* spec;
	g_return_val_if_fail (g_type_is_a (object_type, THREADING_TYPE_THREAD), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer threading_value_get_thread (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, THREADING_TYPE_THREAD), NULL);
	return value->data[0].v_pointer;
}


static void threading_value_set_thread (GValue* value, gpointer v_object) {
	ThreadingThread* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, THREADING_TYPE_THREAD));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, THREADING_TYPE_THREAD));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		threading_thread_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		threading_thread_unref (old);
	}
}


static void threading_value_take_thread (GValue* value, gpointer v_object) {
	ThreadingThread* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, THREADING_TYPE_THREAD));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, THREADING_TYPE_THREAD));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		threading_thread_unref (old);
	}
}


static void threading_thread_class_init (ThreadingThreadClass * klass) {
	threading_thread_parent_class = g_type_class_peek_parent (klass);
	THREADING_THREAD_CLASS (klass)->finalize = threading_thread_finalize;
	THREADING_THREAD_CLASS (klass)->start = threading_thread_real_start;
}


static void threading_thread_instance_init (ThreadingThread * self) {
	self->ref_count = 1;
}


static void threading_thread_finalize (ThreadingThread* obj) {
	ThreadingThread * self;
	self = THREADING_THREAD (obj);
}


static GType threading_thread_get_type (void) {
	static volatile gsize threading_thread_type_id__volatile = 0;
	if (g_once_init_enter (&threading_thread_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { threading_value_thread_init, threading_value_thread_free_value, threading_value_thread_copy_value, threading_value_thread_peek_pointer, "p", threading_value_thread_collect_value, "p", threading_value_thread_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ThreadingThreadClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) threading_thread_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ThreadingThread), 0, (GInstanceInitFunc) threading_thread_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType threading_thread_type_id;
		threading_thread_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ThreadingThread", &g_define_type_info, &g_define_type_fundamental_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&threading_thread_type_id__volatile, threading_thread_type_id);
	}
	return threading_thread_type_id__volatile;
}


static gpointer threading_thread_ref (gpointer instance) {
	ThreadingThread* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void threading_thread_unref (gpointer instance) {
	ThreadingThread* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		THREADING_THREAD_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static gpointer _threading_thread_ref0 (gpointer self) {
	return self ? threading_thread_ref (self) : NULL;
}


static ThreadingThread0* threading_thread0_construct (GType object_type, ThreadingDel0Arg func, void* func_target) {
	ThreadingThread0* self = NULL;
	ThreadingThread* _tmp0_;
	ThreadingDel0Arg _tmp1_;
	self = (ThreadingThread0*) threading_thread_construct (object_type);
	_tmp0_ = _threading_thread_ref0 ((ThreadingThread*) self);
	_threading_thread_unref0 (self->priv->self);
	self->priv->self = _tmp0_;
	_tmp1_ = func;
	(self->priv->func_target_destroy_notify == NULL) ? NULL : (self->priv->func_target_destroy_notify (self->priv->func_target), NULL);
	self->priv->func = NULL;
	self->priv->func_target = NULL;
	self->priv->func_target_destroy_notify = NULL;
	self->priv->func = _tmp1_;
	self->priv->func_target = func_target;
	self->priv->func_target_destroy_notify = NULL;
	return self;
}


static ThreadingThread0* threading_thread0_new (ThreadingDel0Arg func, void* func_target) {
	return threading_thread0_construct (THREADING_TYPE_THREAD0, func, func_target);
}


static void threading_thread0_real_start (ThreadingThread* base) {
	ThreadingThread0 * self;
	self = (ThreadingThread0*) base;
	self->priv->func (self->priv->func_target);
	_threading_thread_unref0 (self->priv->self);
	self->priv->self = NULL;
}


static void threading_thread0_class_init (ThreadingThread0Class * klass) {
	threading_thread0_parent_class = g_type_class_peek_parent (klass);
	THREADING_THREAD_CLASS (klass)->finalize = threading_thread0_finalize;
	g_type_class_add_private (klass, sizeof (ThreadingThread0Private));
	THREADING_THREAD_CLASS (klass)->start = threading_thread0_real_start;
}


static void threading_thread0_instance_init (ThreadingThread0 * self) {
	self->priv = THREADING_THREAD0_GET_PRIVATE (self);
}


static void threading_thread0_finalize (ThreadingThread* obj) {
	ThreadingThread0 * self;
	self = THREADING_THREAD0 (obj);
	_threading_thread_unref0 (self->priv->self);
	(self->priv->func_target_destroy_notify == NULL) ? NULL : (self->priv->func_target_destroy_notify (self->priv->func_target), NULL);
	self->priv->func = NULL;
	self->priv->func_target = NULL;
	self->priv->func_target_destroy_notify = NULL;
	THREADING_THREAD_CLASS (threading_thread0_parent_class)->finalize (obj);
}


static GType threading_thread0_get_type (void) {
	static volatile gsize threading_thread0_type_id__volatile = 0;
	if (g_once_init_enter (&threading_thread0_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ThreadingThread0Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) threading_thread0_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ThreadingThread0), 0, (GInstanceInitFunc) threading_thread0_instance_init, NULL };
		GType threading_thread0_type_id;
		threading_thread0_type_id = g_type_register_static (THREADING_TYPE_THREAD, "ThreadingThread0", &g_define_type_info, 0);
		g_once_init_leave (&threading_thread0_type_id__volatile, threading_thread0_type_id);
	}
	return threading_thread0_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static ThreadingThread1* threading_thread1_construct (GType object_type, ThreadingDel1Arg func, void* func_target, GObject* arg1) {
	ThreadingThread1* self = NULL;
	ThreadingThread* _tmp0_;
	ThreadingDel1Arg _tmp1_;
	GObject* _tmp2_;
	g_return_val_if_fail (arg1 != NULL, NULL);
	self = (ThreadingThread1*) threading_thread_construct (object_type);
	_tmp0_ = _threading_thread_ref0 ((ThreadingThread*) self);
	_threading_thread_unref0 (self->priv->self);
	self->priv->self = _tmp0_;
	_tmp1_ = func;
	(self->priv->func_target_destroy_notify == NULL) ? NULL : (self->priv->func_target_destroy_notify (self->priv->func_target), NULL);
	self->priv->func = NULL;
	self->priv->func_target = NULL;
	self->priv->func_target_destroy_notify = NULL;
	self->priv->func = _tmp1_;
	self->priv->func_target = func_target;
	self->priv->func_target_destroy_notify = NULL;
	_tmp2_ = _g_object_ref0 (arg1);
	_g_object_unref0 (self->priv->arg1);
	self->priv->arg1 = _tmp2_;
	return self;
}


static ThreadingThread1* threading_thread1_new (ThreadingDel1Arg func, void* func_target, GObject* arg1) {
	return threading_thread1_construct (THREADING_TYPE_THREAD1, func, func_target, arg1);
}


static void threading_thread1_real_start (ThreadingThread* base) {
	ThreadingThread1 * self;
	self = (ThreadingThread1*) base;
	self->priv->func (self->priv->arg1, self->priv->func_target);
	_threading_thread_unref0 (self->priv->self);
	self->priv->self = NULL;
}


static void threading_thread1_class_init (ThreadingThread1Class * klass) {
	threading_thread1_parent_class = g_type_class_peek_parent (klass);
	THREADING_THREAD_CLASS (klass)->finalize = threading_thread1_finalize;
	g_type_class_add_private (klass, sizeof (ThreadingThread1Private));
	THREADING_THREAD_CLASS (klass)->start = threading_thread1_real_start;
}


static void threading_thread1_instance_init (ThreadingThread1 * self) {
	self->priv = THREADING_THREAD1_GET_PRIVATE (self);
}


static void threading_thread1_finalize (ThreadingThread* obj) {
	ThreadingThread1 * self;
	self = THREADING_THREAD1 (obj);
	_threading_thread_unref0 (self->priv->self);
	(self->priv->func_target_destroy_notify == NULL) ? NULL : (self->priv->func_target_destroy_notify (self->priv->func_target), NULL);
	self->priv->func = NULL;
	self->priv->func_target = NULL;
	self->priv->func_target_destroy_notify = NULL;
	_g_object_unref0 (self->priv->arg1);
	THREADING_THREAD_CLASS (threading_thread1_parent_class)->finalize (obj);
}


static GType threading_thread1_get_type (void) {
	static volatile gsize threading_thread1_type_id__volatile = 0;
	if (g_once_init_enter (&threading_thread1_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ThreadingThread1Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) threading_thread1_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ThreadingThread1), 0, (GInstanceInitFunc) threading_thread1_instance_init, NULL };
		GType threading_thread1_type_id;
		threading_thread1_type_id = g_type_register_static (THREADING_TYPE_THREAD, "ThreadingThread1", &g_define_type_info, 0);
		g_once_init_leave (&threading_thread1_type_id__volatile, threading_thread1_type_id);
	}
	return threading_thread1_type_id__volatile;
}


static ThreadingThread2* threading_thread2_construct (GType object_type, ThreadingDel2Arg func, void* func_target, GObject* arg1, GObject* arg2) {
	ThreadingThread2* self = NULL;
	ThreadingThread* _tmp0_;
	ThreadingDel2Arg _tmp1_;
	GObject* _tmp2_;
	GObject* _tmp3_;
	g_return_val_if_fail (arg1 != NULL, NULL);
	g_return_val_if_fail (arg2 != NULL, NULL);
	self = (ThreadingThread2*) threading_thread_construct (object_type);
	_tmp0_ = _threading_thread_ref0 ((ThreadingThread*) self);
	_threading_thread_unref0 (self->priv->self);
	self->priv->self = _tmp0_;
	_tmp1_ = func;
	(self->priv->func_target_destroy_notify == NULL) ? NULL : (self->priv->func_target_destroy_notify (self->priv->func_target), NULL);
	self->priv->func = NULL;
	self->priv->func_target = NULL;
	self->priv->func_target_destroy_notify = NULL;
	self->priv->func = _tmp1_;
	self->priv->func_target = func_target;
	self->priv->func_target_destroy_notify = NULL;
	_tmp2_ = _g_object_ref0 (arg1);
	_g_object_unref0 (self->priv->arg1);
	self->priv->arg1 = _tmp2_;
	_tmp3_ = _g_object_ref0 (arg2);
	_g_object_unref0 (self->priv->arg2);
	self->priv->arg2 = _tmp3_;
	return self;
}


static ThreadingThread2* threading_thread2_new (ThreadingDel2Arg func, void* func_target, GObject* arg1, GObject* arg2) {
	return threading_thread2_construct (THREADING_TYPE_THREAD2, func, func_target, arg1, arg2);
}


static void threading_thread2_real_start (ThreadingThread* base) {
	ThreadingThread2 * self;
	self = (ThreadingThread2*) base;
	self->priv->func (self->priv->arg1, self->priv->arg2, self->priv->func_target);
	_threading_thread_unref0 (self->priv->self);
	self->priv->self = NULL;
}


static void threading_thread2_class_init (ThreadingThread2Class * klass) {
	threading_thread2_parent_class = g_type_class_peek_parent (klass);
	THREADING_THREAD_CLASS (klass)->finalize = threading_thread2_finalize;
	g_type_class_add_private (klass, sizeof (ThreadingThread2Private));
	THREADING_THREAD_CLASS (klass)->start = threading_thread2_real_start;
}


static void threading_thread2_instance_init (ThreadingThread2 * self) {
	self->priv = THREADING_THREAD2_GET_PRIVATE (self);
}


static void threading_thread2_finalize (ThreadingThread* obj) {
	ThreadingThread2 * self;
	self = THREADING_THREAD2 (obj);
	_threading_thread_unref0 (self->priv->self);
	(self->priv->func_target_destroy_notify == NULL) ? NULL : (self->priv->func_target_destroy_notify (self->priv->func_target), NULL);
	self->priv->func = NULL;
	self->priv->func_target = NULL;
	self->priv->func_target_destroy_notify = NULL;
	_g_object_unref0 (self->priv->arg1);
	_g_object_unref0 (self->priv->arg2);
	THREADING_THREAD_CLASS (threading_thread2_parent_class)->finalize (obj);
}


static GType threading_thread2_get_type (void) {
	static volatile gsize threading_thread2_type_id__volatile = 0;
	if (g_once_init_enter (&threading_thread2_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ThreadingThread2Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) threading_thread2_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ThreadingThread2), 0, (GInstanceInitFunc) threading_thread2_instance_init, NULL };
		GType threading_thread2_type_id;
		threading_thread2_type_id = g_type_register_static (THREADING_TYPE_THREAD, "ThreadingThread2", &g_define_type_info, 0);
		g_once_init_leave (&threading_thread2_type_id__volatile, threading_thread2_type_id);
	}
	return threading_thread2_type_id__volatile;
}


static ThreadingThread3* threading_thread3_construct (GType object_type, ThreadingDel3Arg func, void* func_target, GObject* arg1, GObject* arg2, GObject* arg3) {
	ThreadingThread3* self = NULL;
	ThreadingThread* _tmp0_;
	ThreadingDel3Arg _tmp1_;
	GObject* _tmp2_;
	GObject* _tmp3_;
	GObject* _tmp4_;
	g_return_val_if_fail (arg1 != NULL, NULL);
	g_return_val_if_fail (arg2 != NULL, NULL);
	g_return_val_if_fail (arg3 != NULL, NULL);
	self = (ThreadingThread3*) threading_thread_construct (object_type);
	_tmp0_ = _threading_thread_ref0 ((ThreadingThread*) self);
	_threading_thread_unref0 (self->priv->self);
	self->priv->self = _tmp0_;
	_tmp1_ = func;
	(self->priv->func_target_destroy_notify == NULL) ? NULL : (self->priv->func_target_destroy_notify (self->priv->func_target), NULL);
	self->priv->func = NULL;
	self->priv->func_target = NULL;
	self->priv->func_target_destroy_notify = NULL;
	self->priv->func = _tmp1_;
	self->priv->func_target = func_target;
	self->priv->func_target_destroy_notify = NULL;
	_tmp2_ = _g_object_ref0 (arg1);
	_g_object_unref0 (self->priv->arg1);
	self->priv->arg1 = _tmp2_;
	_tmp3_ = _g_object_ref0 (arg2);
	_g_object_unref0 (self->priv->arg2);
	self->priv->arg2 = _tmp3_;
	_tmp4_ = _g_object_ref0 (arg3);
	_g_object_unref0 (self->priv->arg3);
	self->priv->arg3 = _tmp4_;
	return self;
}


static ThreadingThread3* threading_thread3_new (ThreadingDel3Arg func, void* func_target, GObject* arg1, GObject* arg2, GObject* arg3) {
	return threading_thread3_construct (THREADING_TYPE_THREAD3, func, func_target, arg1, arg2, arg3);
}


static void threading_thread3_real_start (ThreadingThread* base) {
	ThreadingThread3 * self;
	self = (ThreadingThread3*) base;
	self->priv->func (self->priv->arg1, self->priv->arg2, self->priv->arg3, self->priv->func_target);
	_threading_thread_unref0 (self->priv->self);
	self->priv->self = NULL;
}


static void threading_thread3_class_init (ThreadingThread3Class * klass) {
	threading_thread3_parent_class = g_type_class_peek_parent (klass);
	THREADING_THREAD_CLASS (klass)->finalize = threading_thread3_finalize;
	g_type_class_add_private (klass, sizeof (ThreadingThread3Private));
	THREADING_THREAD_CLASS (klass)->start = threading_thread3_real_start;
}


static void threading_thread3_instance_init (ThreadingThread3 * self) {
	self->priv = THREADING_THREAD3_GET_PRIVATE (self);
}


static void threading_thread3_finalize (ThreadingThread* obj) {
	ThreadingThread3 * self;
	self = THREADING_THREAD3 (obj);
	_threading_thread_unref0 (self->priv->self);
	(self->priv->func_target_destroy_notify == NULL) ? NULL : (self->priv->func_target_destroy_notify (self->priv->func_target), NULL);
	self->priv->func = NULL;
	self->priv->func_target = NULL;
	self->priv->func_target_destroy_notify = NULL;
	_g_object_unref0 (self->priv->arg1);
	_g_object_unref0 (self->priv->arg2);
	_g_object_unref0 (self->priv->arg3);
	THREADING_THREAD_CLASS (threading_thread3_parent_class)->finalize (obj);
}


static GType threading_thread3_get_type (void) {
	static volatile gsize threading_thread3_type_id__volatile = 0;
	if (g_once_init_enter (&threading_thread3_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ThreadingThread3Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) threading_thread3_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ThreadingThread3), 0, (GInstanceInitFunc) threading_thread3_instance_init, NULL };
		GType threading_thread3_type_id;
		threading_thread3_type_id = g_type_register_static (THREADING_TYPE_THREAD, "ThreadingThread3", &g_define_type_info, 0);
		g_once_init_leave (&threading_thread3_type_id__volatile, threading_thread3_type_id);
	}
	return threading_thread3_type_id__volatile;
}


static void value_threading_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_threading_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		threading_unref (value->data[0].v_pointer);
	}
}


static void value_threading_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = threading_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_threading_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_threading_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Threading* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = threading_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_threading_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Threading** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = threading_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_threading (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecThreading* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_THREADING), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_threading (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_THREADING), NULL);
	return value->data[0].v_pointer;
}


void value_set_threading (GValue* value, gpointer v_object) {
	Threading* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_THREADING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_THREADING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		threading_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		threading_unref (old);
	}
}


void value_take_threading (GValue* value, gpointer v_object) {
	Threading* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_THREADING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_THREADING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		threading_unref (old);
	}
}


static void threading_class_init (ThreadingClass * klass) {
	threading_parent_class = g_type_class_peek_parent (klass);
	THREADING_CLASS (klass)->finalize = threading_finalize;
}


static void threading_instance_init (Threading * self) {
	self->ref_count = 1;
}


static void threading_finalize (Threading* obj) {
	Threading * self;
	self = THREADING (obj);
}


GType threading_get_type (void) {
	static volatile gsize threading_type_id__volatile = 0;
	if (g_once_init_enter (&threading_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_threading_init, value_threading_free_value, value_threading_copy_value, value_threading_peek_pointer, "p", value_threading_collect_value, "p", value_threading_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ThreadingClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) threading_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Threading), 0, (GInstanceInitFunc) threading_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType threading_type_id;
		threading_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Threading", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&threading_type_id__volatile, threading_type_id);
	}
	return threading_type_id__volatile;
}


gpointer threading_ref (gpointer instance) {
	Threading* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void threading_unref (gpointer instance) {
	Threading* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		THREADING_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


Obj* obj_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer t) {
	Obj * self = NULL;
	self = (Obj*) g_object_new (object_type, NULL);
	self->priv->t_type = t_type;
	self->priv->t_dup_func = t_dup_func;
	self->priv->t_destroy_func = t_destroy_func;
	obj_set_obj (self, t);
	return self;
}


Obj* obj_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer t) {
	return obj_construct (TYPE_OBJ, t_type, t_dup_func, t_destroy_func, t);
}


gconstpointer obj_get_obj (Obj* self) {
	gconstpointer result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_obj;
	return result;
}


static void obj_set_obj (Obj* self, gconstpointer value) {
	gpointer _tmp0_;
	gconstpointer _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (_tmp1_ = value, ((_tmp1_ == NULL) || (self->priv->t_dup_func == NULL)) ? ((gpointer) _tmp1_) : self->priv->t_dup_func ((gpointer) _tmp1_));
	((self->priv->_obj == NULL) || (self->priv->t_destroy_func == NULL)) ? NULL : (self->priv->_obj = (self->priv->t_destroy_func (self->priv->_obj), NULL));
	self->priv->_obj = _tmp0_;
	g_object_notify ((GObject *) self, "obj");
}


static void obj_class_init (ObjClass * klass) {
	obj_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ObjPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_obj_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_obj_set_property;
	G_OBJECT_CLASS (klass)->finalize = obj_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), OBJ_T_TYPE, g_param_spec_gtype ("t-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), OBJ_T_DUP_FUNC, g_param_spec_pointer ("t-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), OBJ_T_DESTROY_FUNC, g_param_spec_pointer ("t-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), OBJ_OBJ, g_param_spec_pointer ("obj", "obj", "obj", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void obj_instance_init (Obj * self) {
	self->priv = OBJ_GET_PRIVATE (self);
}


static void obj_finalize (GObject* obj) {
	Obj * self;
	self = OBJ (obj);
	((self->priv->_obj == NULL) || (self->priv->t_destroy_func == NULL)) ? NULL : (self->priv->_obj = (self->priv->t_destroy_func (self->priv->_obj), NULL));
	G_OBJECT_CLASS (obj_parent_class)->finalize (obj);
}


GType obj_get_type (void) {
	static volatile gsize obj_type_id__volatile = 0;
	if (g_once_init_enter (&obj_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ObjClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) obj_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Obj), 0, (GInstanceInitFunc) obj_instance_init, NULL };
		GType obj_type_id;
		obj_type_id = g_type_register_static (G_TYPE_OBJECT, "Obj", &g_define_type_info, 0);
		g_once_init_leave (&obj_type_id__volatile, obj_type_id);
	}
	return obj_type_id__volatile;
}


static void _vala_obj_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Obj * self;
	self = OBJ (object);
	switch (property_id) {
		case OBJ_OBJ:
		g_value_set_pointer (value, obj_get_obj (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_obj_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Obj * self;
	self = OBJ (object);
	switch (property_id) {
		case OBJ_OBJ:
		obj_set_obj (self, g_value_get_pointer (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
		case OBJ_T_TYPE:
		self->priv->t_type = g_value_get_gtype (value);
		break;
		case OBJ_T_DUP_FUNC:
		self->priv->t_dup_func = g_value_get_pointer (value);
		break;
		case OBJ_T_DESTROY_FUNC:
		self->priv->t_destroy_func = g_value_get_pointer (value);
		break;
	}
}



