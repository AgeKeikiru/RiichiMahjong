/* MainWindow.c generated by valac 0.12.0, the Vala compiler
 * generated from MainWindow.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL2/SDL_video.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_events.h>
#include <SDL2/SDL.h>
#include <float.h>
#include <math.h>
#include <GL/glew.h>
#include <gobject/gvaluecollector.h>


#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
typedef struct _MainWindowPrivate MainWindowPrivate;

#define TYPE_VIEW (view_get_type ())
#define VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VIEW, View))
#define VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VIEW, ViewClass))
#define IS_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VIEW))
#define IS_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VIEW))
#define VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VIEW, ViewClass))

typedef struct _View View;
typedef struct _ViewClass ViewClass;

#define TYPE_NETWORKING (networking_get_type ())
#define NETWORKING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NETWORKING, Networking))
#define NETWORKING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NETWORKING, NetworkingClass))
#define IS_NETWORKING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NETWORKING))
#define IS_NETWORKING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NETWORKING))
#define NETWORKING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NETWORKING, NetworkingClass))

typedef struct _Networking Networking;
typedef struct _NetworkingClass NetworkingClass;
#define _view_unref0(var) ((var == NULL) ? NULL : (var = (view_unref (var), NULL)))
#define _networking_unref0(var) ((var == NULL) ? NULL : (var = (networking_unref (var), NULL)))

#define TYPE_MAIN_MENU (main_menu_get_type ())
#define MAIN_MENU(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_MENU, MainMenu))
#define MAIN_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_MENU, MainMenuClass))
#define IS_MAIN_MENU(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_MENU))
#define IS_MAIN_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_MENU))
#define MAIN_MENU_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_MENU, MainMenuClass))

typedef struct _MainMenu MainMenu;
typedef struct _MainMenuClass MainMenuClass;

#define MAIN_MENU_TYPE_MENU_ACTION (main_menu_menu_action_get_type ())

#define TYPE_MAHJONG (mahjong_get_type ())
#define MAHJONG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAHJONG, Mahjong))
#define MAHJONG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAHJONG, MahjongClass))
#define IS_MAHJONG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAHJONG))
#define IS_MAHJONG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAHJONG))
#define MAHJONG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAHJONG, MahjongClass))

typedef struct _Mahjong Mahjong;
typedef struct _MahjongClass MahjongClass;
typedef struct _ParamSpecMainWindow ParamSpecMainWindow;
typedef struct _ViewPrivate ViewPrivate;
typedef struct _ParamSpecView ParamSpecView;

struct _MainWindow {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MainWindowPrivate * priv;
};

struct _MainWindowClass {
	GTypeClass parent_class;
	void (*finalize) (MainWindow *self);
};

struct _MainWindowPrivate {
	SDL_Window* window;
	View* view;
	gboolean fullscreen;
	guint color_id;
	gboolean exit;
	gboolean restart;
	gint focal_length;
	Networking* net;
};

typedef enum  {
	MAIN_MENU_MENU_ACTION_ACTIVE,
	MAIN_MENU_MENU_ACTION_SINGLE_PLAYER,
	MAIN_MENU_MENU_ACTION_HOST_MULTI_PLAYER,
	MAIN_MENU_MENU_ACTION_JOIN_MULTI_PLAYER,
	MAIN_MENU_MENU_ACTION_OPTIONS,
	MAIN_MENU_MENU_ACTION_EXIT
} MainMenuMenuAction;

struct _ParamSpecMainWindow {
	GParamSpec parent_instance;
};

struct _View {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ViewPrivate * priv;
};

struct _ViewClass {
	GTypeClass parent_class;
	void (*finalize) (View *self);
	void (*process) (View* self, gdouble dt);
	void (*render) (View* self);
	void (*render_selection) (View* self);
	void (*render_interface) (View* self);
	void (*render_interface_selection) (View* self);
	void (*mouse_move) (View* self, gint x, gint y, guint color_id);
	void (*mouse_click) (View* self, gint x, gint y, gint button, gboolean state, guint color_id);
	void (*mouse_wheel) (View* self, gint amount);
};

struct _ParamSpecView {
	GParamSpec parent_instance;
};


static gpointer main_window_parent_class = NULL;
static gpointer view_parent_class = NULL;

gpointer main_window_ref (gpointer instance);
void main_window_unref (gpointer instance);
GParamSpec* param_spec_main_window (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_main_window (GValue* value, gpointer v_object);
void value_take_main_window (GValue* value, gpointer v_object);
gpointer value_get_main_window (const GValue* value);
GType main_window_get_type (void) G_GNUC_CONST;
gpointer view_ref (gpointer instance);
void view_unref (gpointer instance);
GParamSpec* param_spec_view (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_view (GValue* value, gpointer v_object);
void value_take_view (GValue* value, gpointer v_object);
gpointer value_get_view (const GValue* value);
GType view_get_type (void) G_GNUC_CONST;
gpointer networking_ref (gpointer instance);
void networking_unref (gpointer instance);
GParamSpec* param_spec_networking (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_networking (GValue* value, gpointer v_object);
void value_take_networking (GValue* value, gpointer v_object);
gpointer value_get_networking (const GValue* value);
GType networking_get_type (void) G_GNUC_CONST;
#define MAIN_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MAIN_WINDOW, MainWindowPrivate))
enum  {
	MAIN_WINDOW_DUMMY_PROPERTY
};
Networking* networking_new (void);
Networking* networking_construct (GType object_type);
MainWindow* main_window_new (SDL_Window* window);
MainWindow* main_window_construct (GType object_type, SDL_Window* window);
MainMenu* main_menu_new (SDL_Window* window);
MainMenu* main_menu_construct (GType object_type, SDL_Window* window);
GType main_menu_get_type (void) G_GNUC_CONST;
static void main_window_menu_action (MainWindow* self, MainMenu* m);
static void _main_window_menu_action_main_menu_menu_action (MainMenu* _sender, gpointer self);
GType main_menu_menu_action_get_type (void) G_GNUC_CONST;
MainMenuMenuAction main_menu_get_action (MainMenu* self);
Mahjong* mahjong_new (SDL_Window* window);
Mahjong* mahjong_construct (GType object_type, SDL_Window* window);
GType mahjong_get_type (void) G_GNUC_CONST;
gboolean networking_host (Networking* self);
gboolean networking_join (Networking* self, const gchar* addr);
gboolean main_window_loop (MainWindow* self);
static void main_window_key (MainWindow* self, gchar key);
void view_mouse_move (View* self, gint x, gint y, guint color_id);
void view_mouse_click (View* self, gint x, gint y, gint button, gboolean state, guint color_id);
void view_mouse_wheel (View* self, gint amount);
void view_process (View* self, gdouble dt);
static void main_window_render (MainWindow* self);
static void main_window_toggle_fullscreen (MainWindow* self);
static guint main_window_get_color_id (MainWindow* self);
static void main_window_setup_projection (MainWindow* self, gboolean ortho);
void view_render (View* self);
void view_render_interface (View* self);
void view_render_selection (View* self);
void view_render_interface_selection (View* self);
static void main_window_finalize (MainWindow* obj);
enum  {
	VIEW_DUMMY_PROPERTY
};
static void view_real_process (View* self, gdouble dt);
static void view_real_render (View* self);
static void view_real_render_selection (View* self);
static void view_real_render_interface (View* self);
static void view_real_render_interface_selection (View* self);
static void view_real_mouse_move (View* self, gint x, gint y, guint color_id);
static void view_real_mouse_click (View* self, gint x, gint y, gint button, gboolean state, guint color_id);
static void view_real_mouse_wheel (View* self, gint amount);
View* view_construct (GType object_type);
static void view_finalize (View* obj);


static gpointer _view_ref0 (gpointer self) {
	return self ? view_ref (self) : NULL;
}


static void _main_window_menu_action_main_menu_menu_action (MainMenu* _sender, gpointer self) {
	main_window_menu_action (self, _sender);
}


MainWindow* main_window_construct (GType object_type, SDL_Window* window) {
	MainWindow* self = NULL;
	MainMenu* _tmp0_ = NULL;
	MainMenu* m;
	View* _tmp1_;
	g_return_val_if_fail (window != NULL, NULL);
	self = (MainWindow*) g_type_create_instance (object_type);
	self->priv->window = window;
	_tmp0_ = main_menu_new (window);
	m = _tmp0_;
	_tmp1_ = _view_ref0 ((View*) m);
	_view_unref0 (self->priv->view);
	self->priv->view = _tmp1_;
	g_signal_connect (m, "menu-action", (GCallback) _main_window_menu_action_main_menu_menu_action, self);
	_view_unref0 (m);
	return self;
}


MainWindow* main_window_new (SDL_Window* window) {
	return main_window_construct (TYPE_MAIN_WINDOW, window);
}


static void main_window_menu_action (MainWindow* self, MainMenu* m) {
	MainMenuMenuAction _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (m != NULL);
	_tmp0_ = main_menu_get_action (m);
	switch (_tmp0_) {
		case MAIN_MENU_MENU_ACTION_SINGLE_PLAYER:
		{
			Mahjong* _tmp1_ = NULL;
			_tmp1_ = mahjong_new (self->priv->window);
			_view_unref0 (self->priv->view);
			self->priv->view = (View*) _tmp1_;
			break;
		}
		case MAIN_MENU_MENU_ACTION_HOST_MULTI_PLAYER:
		{
			networking_host (self->priv->net);
			break;
		}
		case MAIN_MENU_MENU_ACTION_JOIN_MULTI_PLAYER:
		{
			networking_join (self->priv->net, "localhost");
			break;
		}
		case MAIN_MENU_MENU_ACTION_EXIT:
		{
			self->priv->exit = TRUE;
			break;
		}
		default:
		break;
	}
}


gboolean main_window_loop (MainWindow* self) {
	gboolean result = FALSE;
	SDL_Event e;
	g_return_val_if_fail (self != NULL, FALSE);
	while (TRUE) {
		if (!(!self->priv->exit)) {
			break;
		}
		while (TRUE) {
			SDL_Event _tmp0_;
			gint _tmp1_;
			_tmp1_ = SDL_PollEvent (&_tmp0_);
			 (e);
			e = _tmp0_;
			if (!(_tmp1_ != 0)) {
				break;
			}
			if (e.type == SDL_QUIT) {
				self->priv->exit = TRUE;
			} else {
				if (e.type == SDL_KEYDOWN) {
					main_window_key (self, (gchar) e.key.keysym.sym);
				} else {
					if (e.type == SDL_MOUSEMOTION) {
						gint x;
						gint y;
						gint width = 0;
						gint height = 0;
						gint _tmp2_;
						gint _tmp3_;
						x = 0;
						y = 0;
						SDL_GetMouseState (&x, &y);
						SDL_GetWindowSize (self->priv->window, &_tmp2_, &_tmp3_);
						width = _tmp2_;
						height = _tmp3_;
						view_mouse_move (self->priv->view, x, height - y, self->priv->color_id);
					} else {
						gboolean _tmp4_ = FALSE;
						if (e.type == SDL_MOUSEBUTTONDOWN) {
							_tmp4_ = TRUE;
						} else {
							_tmp4_ = e.type == SDL_MOUSEBUTTONUP;
						}
						if (_tmp4_) {
							gint x;
							gint y;
							gint width = 0;
							gint height = 0;
							gint _tmp5_;
							gint _tmp6_;
							x = 0;
							y = 0;
							SDL_GetMouseState (&x, &y);
							SDL_GetWindowSize (self->priv->window, &_tmp5_, &_tmp6_);
							width = _tmp5_;
							height = _tmp6_;
							view_mouse_click (self->priv->view, x, height - y, (gint) e.button.button, e.type == SDL_MOUSEBUTTONUP, self->priv->color_id);
						} else {
							if (e.type == SDL_MOUSEWHEEL) {
								view_mouse_wheel (self->priv->view, (gint) e.wheel.y);
							}
						}
					}
				}
			}
		}
		view_process (self->priv->view, 0.1);
		main_window_render (self);
	}
	result = self->priv->restart;
	 (e);
	return result;
}


static void main_window_key (MainWindow* self, gchar key) {
	g_return_if_fail (self != NULL);
	switch (key) {
		case 27:
		case 'q':
		{
			self->priv->exit = TRUE;
			break;
		}
		case 'f':
		{
			main_window_toggle_fullscreen (self);
			break;
		}
		case 'r':
		{
			self->priv->restart = TRUE;
			self->priv->exit = TRUE;
			break;
		}
		default:
		break;
	}
}


static void main_window_toggle_fullscreen (MainWindow* self) {
	SDL_WindowFlags _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	self->priv->fullscreen = !self->priv->fullscreen;
	if (self->priv->fullscreen) {
		_tmp0_ = SDL_WINDOW_FULLSCREEN_DESKTOP;
	} else {
		_tmp0_ = 0;
	}
	SDL_SetWindowFullscreen (self->priv->window, (guint32) _tmp0_);
}


static guint main_window_get_color_id (MainWindow* self) {
	guint result = 0U;
	guchar color[3] = {0};
	gint x;
	gint y;
	gint width = 0;
	gint height = 0;
	gint _tmp0_;
	gint _tmp1_;
	g_return_val_if_fail (self != NULL, 0U);
	x = 0;
	y = 0;
	SDL_GetMouseState (&x, &y);
	SDL_GetWindowSize (self->priv->window, &_tmp0_, &_tmp1_);
	width = _tmp0_;
	height = _tmp1_;
	glReadPixels ((GLint) x, (GLint) (height - y), (GLsizei) 1, (GLsizei) 1, (GLenum) GL_RGB, (GLenum) GL_UNSIGNED_BYTE, (GLvoid*) color);
	result = ((((guint) color[0]) << 16) + (((guint) color[1]) << 8)) + ((guint) color[2]);
	return result;
}


static void main_window_render (MainWindow* self) {
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = main_window_get_color_id (self);
	self->priv->color_id = _tmp0_;
	glPushMatrix ();
	glPushAttrib ((GLbitfield) GL_ALL_ATTRIB_BITS);
	main_window_setup_projection (self, FALSE);
	glClear (GL_DEPTH_BUFFER_BIT);
	glClearColor ((GLfloat) 0, (GLfloat) 0.1, (GLfloat) 0.2, (GLfloat) 0);
	glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	view_render (self->priv->view);
	glPopAttrib ();
	glPopMatrix ();
	glPushMatrix ();
	glPushAttrib ((GLbitfield) GL_ALL_ATTRIB_BITS);
	main_window_setup_projection (self, TRUE);
	glClear (GL_DEPTH_BUFFER_BIT);
	glDisable (GL_DEPTH_TEST);
	glDisable ((GLenum) GL_LIGHTING);
	glEnable ((GLenum) GL_TEXTURE_2D);
	glEnable ((GLenum) GL_COLOR_SUM);
	glDepthFunc ((GLenum) GL_LEQUAL);
	view_render_interface (self->priv->view);
	glPopAttrib ();
	glPopMatrix ();
	SDL_GL_SwapWindow (self->priv->window);
	glPushMatrix ();
	glPushAttrib ((GLbitfield) GL_ALL_ATTRIB_BITS);
	main_window_setup_projection (self, FALSE);
	glClearColor ((GLfloat) 0, (GLfloat) 0, (GLfloat) 0, (GLfloat) 0);
	glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	view_render_selection (self->priv->view);
	glPopAttrib ();
	glPopMatrix ();
	glPushMatrix ();
	glPushAttrib ((GLbitfield) GL_ALL_ATTRIB_BITS);
	glClear (GL_DEPTH_BUFFER_BIT);
	main_window_setup_projection (self, TRUE);
	glDisable (GL_DEPTH_TEST);
	glDisable ((GLenum) GL_LIGHTING);
	glEnable ((GLenum) GL_COLOR_SUM);
	glDepthFunc ((GLenum) GL_LEQUAL);
	view_render_interface_selection (self->priv->view);
	glPopAttrib ();
	glPopMatrix ();
}


static void main_window_setup_projection (MainWindow* self, gboolean ortho) {
	gint width = 0;
	gint height = 0;
	gint _tmp0_;
	gint _tmp1_;
	gfloat ar;
	g_return_if_fail (self != NULL);
	SDL_GetWindowSize (self->priv->window, &_tmp0_, &_tmp1_);
	width = _tmp0_;
	height = _tmp1_;
	ar = ((gfloat) width) / ((gfloat) height);
	glViewport ((GLint) 0, (GLint) 0, (GLsizei) width, (GLsizei) height);
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity ();
	if (ortho) {
		glOrtho ((GLdouble) 0, (GLdouble) 0, (GLdouble) 0, (GLdouble) 0, (GLdouble) 0, (GLdouble) 0);
	} else {
		glFrustum (-((GLdouble) ar), (GLdouble) ar, -((GLdouble) 1.0), (GLdouble) 1.0, (GLdouble) self->priv->focal_length, (GLdouble) 1000.0);
	}
	glMatrixMode (GL_MODELVIEW);
	glLoadIdentity ();
}


static void value_main_window_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_main_window_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		main_window_unref (value->data[0].v_pointer);
	}
}


static void value_main_window_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = main_window_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_main_window_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_main_window_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		MainWindow* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = main_window_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_main_window_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	MainWindow** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = main_window_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_main_window (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecMainWindow* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_MAIN_WINDOW), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_main_window (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_MAIN_WINDOW), NULL);
	return value->data[0].v_pointer;
}


void value_set_main_window (GValue* value, gpointer v_object) {
	MainWindow* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_MAIN_WINDOW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_MAIN_WINDOW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		main_window_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		main_window_unref (old);
	}
}


void value_take_main_window (GValue* value, gpointer v_object) {
	MainWindow* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_MAIN_WINDOW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_MAIN_WINDOW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		main_window_unref (old);
	}
}


static void main_window_class_init (MainWindowClass * klass) {
	main_window_parent_class = g_type_class_peek_parent (klass);
	MAIN_WINDOW_CLASS (klass)->finalize = main_window_finalize;
	g_type_class_add_private (klass, sizeof (MainWindowPrivate));
}


static void main_window_instance_init (MainWindow * self) {
	Networking* _tmp0_ = NULL;
	self->priv = MAIN_WINDOW_GET_PRIVATE (self);
	self->priv->fullscreen = FALSE;
	self->priv->exit = FALSE;
	self->priv->restart = FALSE;
	self->priv->focal_length = 2;
	_tmp0_ = networking_new ();
	self->priv->net = _tmp0_;
	self->ref_count = 1;
}


static void main_window_finalize (MainWindow* obj) {
	MainWindow * self;
	self = MAIN_WINDOW (obj);
	_view_unref0 (self->priv->view);
	_networking_unref0 (self->priv->net);
}


GType main_window_get_type (void) {
	static volatile gsize main_window_type_id__volatile = 0;
	if (g_once_init_enter (&main_window_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_main_window_init, value_main_window_free_value, value_main_window_copy_value, value_main_window_peek_pointer, "p", value_main_window_collect_value, "p", value_main_window_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (MainWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) main_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MainWindow), 0, (GInstanceInitFunc) main_window_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType main_window_type_id;
		main_window_type_id = g_type_register_fundamental (g_type_fundamental_next (), "MainWindow", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&main_window_type_id__volatile, main_window_type_id);
	}
	return main_window_type_id__volatile;
}


gpointer main_window_ref (gpointer instance) {
	MainWindow* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void main_window_unref (gpointer instance) {
	MainWindow* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		MAIN_WINDOW_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void view_real_process (View* self, gdouble dt) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_process'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_process (View* self, gdouble dt) {
	VIEW_GET_CLASS (self)->process (self, dt);
}


static void view_real_render (View* self) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_render'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_render (View* self) {
	VIEW_GET_CLASS (self)->render (self);
}


static void view_real_render_selection (View* self) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_render_selection'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_render_selection (View* self) {
	VIEW_GET_CLASS (self)->render_selection (self);
}


static void view_real_render_interface (View* self) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_render_interface'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_render_interface (View* self) {
	VIEW_GET_CLASS (self)->render_interface (self);
}


static void view_real_render_interface_selection (View* self) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_render_interface_selection'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_render_interface_selection (View* self) {
	VIEW_GET_CLASS (self)->render_interface_selection (self);
}


static void view_real_mouse_move (View* self, gint x, gint y, guint color_id) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_mouse_move'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_mouse_move (View* self, gint x, gint y, guint color_id) {
	VIEW_GET_CLASS (self)->mouse_move (self, x, y, color_id);
}


static void view_real_mouse_click (View* self, gint x, gint y, gint button, gboolean state, guint color_id) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_mouse_click'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_mouse_click (View* self, gint x, gint y, gint button, gboolean state, guint color_id) {
	VIEW_GET_CLASS (self)->mouse_click (self, x, y, button, state, color_id);
}


static void view_real_mouse_wheel (View* self, gint amount) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_mouse_wheel'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_mouse_wheel (View* self, gint amount) {
	VIEW_GET_CLASS (self)->mouse_wheel (self, amount);
}


View* view_construct (GType object_type) {
	View* self = NULL;
	self = (View*) g_type_create_instance (object_type);
	return self;
}


static void value_view_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_view_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		view_unref (value->data[0].v_pointer);
	}
}


static void value_view_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = view_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_view_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_view_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		View* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = view_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_view_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	View** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = view_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_view (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecView* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_VIEW), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_view (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_VIEW), NULL);
	return value->data[0].v_pointer;
}


void value_set_view (GValue* value, gpointer v_object) {
	View* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_VIEW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_VIEW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		view_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		view_unref (old);
	}
}


void value_take_view (GValue* value, gpointer v_object) {
	View* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_VIEW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_VIEW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		view_unref (old);
	}
}


static void view_class_init (ViewClass * klass) {
	view_parent_class = g_type_class_peek_parent (klass);
	VIEW_CLASS (klass)->finalize = view_finalize;
	VIEW_CLASS (klass)->process = view_real_process;
	VIEW_CLASS (klass)->render = view_real_render;
	VIEW_CLASS (klass)->render_selection = view_real_render_selection;
	VIEW_CLASS (klass)->render_interface = view_real_render_interface;
	VIEW_CLASS (klass)->render_interface_selection = view_real_render_interface_selection;
	VIEW_CLASS (klass)->mouse_move = view_real_mouse_move;
	VIEW_CLASS (klass)->mouse_click = view_real_mouse_click;
	VIEW_CLASS (klass)->mouse_wheel = view_real_mouse_wheel;
}


static void view_instance_init (View * self) {
	self->ref_count = 1;
}


static void view_finalize (View* obj) {
	View * self;
	self = VIEW (obj);
}


GType view_get_type (void) {
	static volatile gsize view_type_id__volatile = 0;
	if (g_once_init_enter (&view_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_view_init, value_view_free_value, value_view_copy_value, value_view_peek_pointer, "p", value_view_collect_value, "p", value_view_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (View), 0, (GInstanceInitFunc) view_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType view_type_id;
		view_type_id = g_type_register_fundamental (g_type_fundamental_next (), "View", &g_define_type_info, &g_define_type_fundamental_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&view_type_id__volatile, view_type_id);
	}
	return view_type_id__volatile;
}


gpointer view_ref (gpointer instance) {
	View* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void view_unref (gpointer instance) {
	View* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		VIEW_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



