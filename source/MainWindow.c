/* MainWindow.c generated by valac 0.12.0, the Vala compiler
 * generated from MainWindow.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_events.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_video.h>
#include <gee.h>
#include <gobject/gvaluecollector.h>


#define TYPE_RENDER_WINDOW (render_window_get_type ())
#define RENDER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER_WINDOW, RenderWindow))
#define RENDER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER_WINDOW, RenderWindowClass))
#define IS_RENDER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER_WINDOW))
#define IS_RENDER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER_WINDOW))
#define RENDER_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER_WINDOW, RenderWindowClass))

typedef struct _RenderWindow RenderWindow;
typedef struct _RenderWindowClass RenderWindowClass;
typedef struct _RenderWindowPrivate RenderWindowPrivate;

#define TYPE_IRENDER_TARGET (irender_target_get_type ())
#define IRENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IRENDER_TARGET, IRenderTarget))
#define IS_IRENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IRENDER_TARGET))
#define IRENDER_TARGET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IRENDER_TARGET, IRenderTargetIface))

typedef struct _IRenderTarget IRenderTarget;
typedef struct _IRenderTargetIface IRenderTargetIface;

#define TYPE_RENDER_STATE (render_state_get_type ())
#define RENDER_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER_STATE, RenderState))
#define RENDER_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER_STATE, RenderStateClass))
#define IS_RENDER_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER_STATE))
#define IS_RENDER_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER_STATE))
#define RENDER_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER_STATE, RenderStateClass))

typedef struct _RenderState RenderState;
typedef struct _RenderStateClass RenderStateClass;

#define TYPE_RESOURCE3_DOBJECT (resource3_dobject_get_type ())
#define RESOURCE3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE3_DOBJECT, Resource3DObject))
#define RESOURCE3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE3_DOBJECT, Resource3DObjectClass))
#define IS_RESOURCE3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE3_DOBJECT))
#define IS_RESOURCE3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE3_DOBJECT))
#define RESOURCE3_DOBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE3_DOBJECT, Resource3DObjectClass))

typedef struct _Resource3DObject Resource3DObject;
typedef struct _Resource3DObjectClass Resource3DObjectClass;

#define TYPE_RESOURCE_TEXTURE (resource_texture_get_type ())
#define RESOURCE_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE_TEXTURE, ResourceTexture))
#define RESOURCE_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE_TEXTURE, ResourceTextureClass))
#define IS_RESOURCE_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE_TEXTURE))
#define IS_RESOURCE_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE_TEXTURE))
#define RESOURCE_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE_TEXTURE, ResourceTextureClass))

typedef struct _ResourceTexture ResourceTexture;
typedef struct _ResourceTextureClass ResourceTextureClass;

#define TYPE_IRESOURCE_STORE (iresource_store_get_type ())
#define IRESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IRESOURCE_STORE, IResourceStore))
#define IS_IRESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IRESOURCE_STORE))
#define IRESOURCE_STORE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IRESOURCE_STORE, IResourceStoreIface))

typedef struct _IResourceStore IResourceStore;
typedef struct _IResourceStoreIface IResourceStoreIface;

#define TYPE_RENDER3_DOBJECT (render3_dobject_get_type ())
#define RENDER3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER3_DOBJECT, Render3DObject))
#define RENDER3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER3_DOBJECT, Render3DObjectClass))
#define IS_RENDER3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER3_DOBJECT))
#define IS_RENDER3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER3_DOBJECT))
#define RENDER3_DOBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER3_DOBJECT, Render3DObjectClass))

typedef struct _Render3DObject Render3DObject;
typedef struct _Render3DObjectClass Render3DObjectClass;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
typedef struct _MainWindowPrivate MainWindowPrivate;

#define TYPE_VIEW (view_get_type ())
#define VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VIEW, View))
#define VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VIEW, ViewClass))
#define IS_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VIEW))
#define IS_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VIEW))
#define VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VIEW, ViewClass))

typedef struct _View View;
typedef struct _ViewClass ViewClass;

#define TYPE_MAIN_MENU (main_menu_get_type ())
#define MAIN_MENU(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_MENU, MainMenu))
#define MAIN_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_MENU, MainMenuClass))
#define IS_MAIN_MENU(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_MENU))
#define IS_MAIN_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_MENU))
#define MAIN_MENU_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_MENU, MainMenuClass))

typedef struct _MainMenu MainMenu;
typedef struct _MainMenuClass MainMenuClass;
#define _view_unref0(var) ((var == NULL) ? NULL : (var = (view_unref (var), NULL)))

#define TYPE_IWINDOW_TARGET (iwindow_target_get_type ())
#define IWINDOW_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IWINDOW_TARGET, IWindowTarget))
#define IS_IWINDOW_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IWINDOW_TARGET))
#define IWINDOW_TARGET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IWINDOW_TARGET, IWindowTargetIface))

typedef struct _IWindowTarget IWindowTarget;
typedef struct _IWindowTargetIface IWindowTargetIface;

#define MAIN_MENU_TYPE_MENU_ACTION (main_menu_menu_action_get_type ())

#define TYPE_COLOR (color_get_type ())
typedef struct _Color Color;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_MAIN_VIEW (main_view_get_type ())
#define MAIN_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_VIEW, MainView))
#define MAIN_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_VIEW, MainViewClass))
#define IS_MAIN_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_VIEW))
#define IS_MAIN_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_VIEW))
#define MAIN_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_VIEW, MainViewClass))

typedef struct _MainView MainView;
typedef struct _MainViewClass MainViewClass;
#define _render_state_unref0(var) ((var == NULL) ? NULL : (var = (render_state_unref (var), NULL)))
typedef struct _ParamSpecRenderWindow ParamSpecRenderWindow;

#define TYPE_SDL_WINDOW_TARGET (sdl_window_target_get_type ())
#define SDL_WINDOW_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SDL_WINDOW_TARGET, SDLWindowTarget))
#define SDL_WINDOW_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SDL_WINDOW_TARGET, SDLWindowTargetClass))
#define IS_SDL_WINDOW_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SDL_WINDOW_TARGET))
#define IS_SDL_WINDOW_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SDL_WINDOW_TARGET))
#define SDL_WINDOW_TARGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SDL_WINDOW_TARGET, SDLWindowTargetClass))

typedef struct _SDLWindowTarget SDLWindowTarget;
typedef struct _SDLWindowTargetClass SDLWindowTargetClass;
typedef struct _SDLWindowTargetPrivate SDLWindowTargetPrivate;
typedef struct _RenderStatePrivate RenderStatePrivate;

#define TYPE_VEC3 (vec3_get_type ())
typedef struct _Vec3 Vec3;
typedef struct _ParamSpecRenderState ParamSpecRenderState;
typedef struct _ViewPrivate ViewPrivate;
typedef struct _MainViewPrivate MainViewPrivate;
#define _render_window_unref0(var) ((var == NULL) ? NULL : (var = (render_window_unref (var), NULL)))
typedef struct _ParamSpecView ParamSpecView;

struct _IResourceStoreIface {
	GTypeInterface parent_iface;
	Render3DObject* (*load_3D_object) (IResourceStore* self, const gchar* name);
};

struct _IRenderTargetIface {
	GTypeInterface parent_iface;
	void (*set_state) (IRenderTarget* self, RenderState* state);
	gboolean (*start) (IRenderTarget* self);
	void (*stop) (IRenderTarget* self);
	guint (*load_3D_object) (IRenderTarget* self, Resource3DObject* object);
	guint (*load_texture) (IRenderTarget* self, ResourceTexture* texture);
	IResourceStore* (*get_resource_store) (IRenderTarget* self);
};

struct _RenderWindow {
	GTypeInstance parent_instance;
	volatile int ref_count;
	RenderWindowPrivate * priv;
	IRenderTarget* renderer;
};

struct _RenderWindowClass {
	GTypeClass parent_class;
	void (*finalize) (RenderWindow *self);
	void (*do_process) (RenderWindow* self, gdouble dt);
};

struct _MainWindow {
	RenderWindow parent_instance;
	MainWindowPrivate * priv;
};

struct _MainWindowClass {
	RenderWindowClass parent_class;
};

struct _MainWindowPrivate {
	MainMenu* menu;
};

struct _IWindowTargetIface {
	GTypeInterface parent_iface;
	void (*swap) (IWindowTarget* self);
	void (*pump_events) (IWindowTarget* self);
	gboolean (*get_fullscreen) (IWindowTarget* self);
	void (*set_fullscreen) (IWindowTarget* self, gboolean value);
	gint (*get_width) (IWindowTarget* self);
	gint (*get_height) (IWindowTarget* self);
};

typedef enum  {
	MAIN_MENU_MENU_ACTION_ACTIVE,
	MAIN_MENU_MENU_ACTION_SINGLE_PLAYER,
	MAIN_MENU_MENU_ACTION_HOST_MULTI_PLAYER,
	MAIN_MENU_MENU_ACTION_JOIN_MULTI_PLAYER,
	MAIN_MENU_MENU_ACTION_OPTIONS,
	MAIN_MENU_MENU_ACTION_EXIT
} MainMenuMenuAction;

struct _Color {
	gfloat r;
	gfloat g;
	gfloat b;
	gfloat a;
};

struct _RenderWindowPrivate {
	IWindowTarget* window;
	gboolean running;
	View* _main_view;
	Color _back_color;
};

struct _ParamSpecRenderWindow {
	GParamSpec parent_instance;
};

struct _SDLWindowTarget {
	GObject parent_instance;
	SDLWindowTargetPrivate * priv;
};

struct _SDLWindowTargetClass {
	GObjectClass parent_class;
};

struct _SDLWindowTargetPrivate {
	gboolean is_fullscreen;
	SDL_Window* window;
};

struct _RenderState {
	GTypeInstance parent_instance;
	volatile int ref_count;
	RenderStatePrivate * priv;
};

struct _RenderStateClass {
	GTypeClass parent_class;
	void (*finalize) (RenderState *self);
};

struct _Vec3 {
	gfloat x;
	gfloat y;
	gfloat z;
};

struct _RenderStatePrivate {
	GeeArrayList* objs;
	gint _screen_width;
	gint _screen_height;
	Color _back_color;
	Vec3 _camera_position;
	Vec3 _camera_rotation;
};

struct _ParamSpecRenderState {
	GParamSpec parent_instance;
};

struct _View {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ViewPrivate * priv;
	RenderWindow* parent_window;
};

struct _ViewClass {
	GTypeClass parent_class;
	void (*finalize) (View *self);
	void (*do_load_resources) (View* self, IResourceStore* store);
	void (*do_render) (View* self, RenderState* state, IResourceStore* store);
	void (*do_process) (View* self, gdouble dt);
	void (*do_mouse_move) (View* self, gint x, gint y);
	void (*do_key_press) (View* self, gchar key);
};

struct _MainView {
	View parent_instance;
	MainViewPrivate * priv;
};

struct _MainViewClass {
	ViewClass parent_class;
};

struct _ViewPrivate {
	GeeArrayList* child_views;
	View* parent;
};

struct _ParamSpecView {
	GParamSpec parent_instance;
};


static gpointer main_window_parent_class = NULL;
static gpointer render_window_parent_class = NULL;
static gpointer sdl_window_target_parent_class = NULL;
static IWindowTargetIface* sdl_window_target_iwindow_target_parent_iface = NULL;
static gpointer render_state_parent_class = NULL;
static gpointer main_view_parent_class = NULL;
static gpointer view_parent_class = NULL;

gpointer render_window_ref (gpointer instance);
void render_window_unref (gpointer instance);
GParamSpec* param_spec_render_window (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render_window (GValue* value, gpointer v_object);
void value_take_render_window (GValue* value, gpointer v_object);
gpointer value_get_render_window (const GValue* value);
GType render_window_get_type (void) G_GNUC_CONST;
gpointer render_state_ref (gpointer instance);
void render_state_unref (gpointer instance);
GParamSpec* param_spec_render_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render_state (GValue* value, gpointer v_object);
void value_take_render_state (GValue* value, gpointer v_object);
gpointer value_get_render_state (const GValue* value);
GType render_state_get_type (void) G_GNUC_CONST;
gpointer resource3_dobject_ref (gpointer instance);
void resource3_dobject_unref (gpointer instance);
GParamSpec* param_spec_resource3_dobject (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_resource3_dobject (GValue* value, gpointer v_object);
void value_take_resource3_dobject (GValue* value, gpointer v_object);
gpointer value_get_resource3_dobject (const GValue* value);
GType resource3_dobject_get_type (void) G_GNUC_CONST;
gpointer resource_texture_ref (gpointer instance);
void resource_texture_unref (gpointer instance);
GParamSpec* param_spec_resource_texture (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_resource_texture (GValue* value, gpointer v_object);
void value_take_resource_texture (GValue* value, gpointer v_object);
gpointer value_get_resource_texture (const GValue* value);
GType resource_texture_get_type (void) G_GNUC_CONST;
gpointer render3_dobject_ref (gpointer instance);
void render3_dobject_unref (gpointer instance);
GParamSpec* param_spec_render3_dobject (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render3_dobject (GValue* value, gpointer v_object);
void value_take_render3_dobject (GValue* value, gpointer v_object);
gpointer value_get_render3_dobject (const GValue* value);
GType render3_dobject_get_type (void) G_GNUC_CONST;
GType iresource_store_get_type (void) G_GNUC_CONST;
GType irender_target_get_type (void) G_GNUC_CONST;
GType main_window_get_type (void) G_GNUC_CONST;
gpointer view_ref (gpointer instance);
void view_unref (gpointer instance);
GParamSpec* param_spec_view (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_view (GValue* value, gpointer v_object);
void value_take_view (GValue* value, gpointer v_object);
gpointer value_get_view (const GValue* value);
GType view_get_type (void) G_GNUC_CONST;
GType main_menu_get_type (void) G_GNUC_CONST;
#define MAIN_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MAIN_WINDOW, MainWindowPrivate))
enum  {
	MAIN_WINDOW_DUMMY_PROPERTY
};
static void main_window_menu_action (MainWindow* self, MainMenu* m);
static void _main_window_menu_action_main_menu_menu_action (MainMenu* _sender, gpointer self);
GType iwindow_target_get_type (void) G_GNUC_CONST;
MainWindow* main_window_new (IWindowTarget* window, IRenderTarget* renderer);
MainWindow* main_window_construct (GType object_type, IWindowTarget* window, IRenderTarget* renderer);
RenderWindow* render_window_construct (GType object_type, IWindowTarget* window, IRenderTarget* renderer);
MainMenu* main_menu_new (void);
MainMenu* main_menu_construct (GType object_type);
View* render_window_get_main_view (RenderWindow* self);
void view_add_child (View* self, View* child);
GType main_menu_menu_action_get_type (void) G_GNUC_CONST;
MainMenuMenuAction main_menu_get_action (MainMenu* self);
void render_window_finish (RenderWindow* self);
static void main_window_real_do_process (RenderWindow* base, gdouble dt);
static void main_window_key (MainWindow* self, gchar key);
void view_mouse_move (View* self, gint x, gint y);
void view_process (View* self, gdouble dt);
gboolean render_window_get_fullscreen (RenderWindow* self);
void render_window_set_fullscreen (RenderWindow* self, gboolean value);
void view_key_press (View* self, gchar key);
static void main_window_finalize (RenderWindow* obj);
GType color_get_type (void) G_GNUC_CONST;
Color* color_dup (const Color* self);
void color_free (Color* self);
#define RENDER_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_RENDER_WINDOW, RenderWindowPrivate))
enum  {
	RENDER_WINDOW_DUMMY_PROPERTY
};
MainView* main_view_new (RenderWindow* window);
MainView* main_view_construct (GType object_type, RenderWindow* window);
GType main_view_get_type (void) G_GNUC_CONST;
static void render_window_set_main_view (RenderWindow* self, View* value);
void render_window_show (RenderWindow* self);
static void render_window_load_resources (RenderWindow* self, IResourceStore* store);
IResourceStore* irender_target_get_resource_store (IRenderTarget* self);
static void render_window_process (RenderWindow* self, gdouble dt);
static gdouble render_window_get_delta (RenderWindow* self);
void irender_target_set_state (IRenderTarget* self, RenderState* state);
static RenderState* render_window_render (RenderWindow* self);
void iwindow_target_pump_events (IWindowTarget* self);
gint iwindow_target_get_width (IWindowTarget* self);
gint iwindow_target_get_height (IWindowTarget* self);
RenderState* render_state_new (gint width, gint height);
RenderState* render_state_construct (GType object_type, gint width, gint height);
void render_window_get_back_color (RenderWindow* self, Color* result);
void render_state_set_back_color (RenderState* self, Color* value);
void view_render (View* self, RenderState* state, IResourceStore* store);
void view_load_resources (View* self, IResourceStore* store);
void render_window_do_process (RenderWindow* self, gdouble dt);
static void render_window_real_do_process (RenderWindow* self, gdouble dt);
gboolean iwindow_target_get_fullscreen (IWindowTarget* self);
void iwindow_target_set_fullscreen (IWindowTarget* self, gboolean value);
void render_window_set_back_color (RenderWindow* self, Color* value);
gint render_window_get_width (RenderWindow* self);
gint render_window_get_height (RenderWindow* self);
static void render_window_finalize (RenderWindow* obj);
void iwindow_target_swap (IWindowTarget* self);
GType sdl_window_target_get_type (void) G_GNUC_CONST;
#define SDL_WINDOW_TARGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SDL_WINDOW_TARGET, SDLWindowTargetPrivate))
enum  {
	SDL_WINDOW_TARGET_DUMMY_PROPERTY,
	SDL_WINDOW_TARGET_FULLSCREEN,
	SDL_WINDOW_TARGET_WIDTH,
	SDL_WINDOW_TARGET_HEIGHT,
	SDL_WINDOW_TARGET_SDL_WINDOW
};
SDLWindowTarget* sdl_window_target_new (SDL_Window* window);
SDLWindowTarget* sdl_window_target_construct (GType object_type, SDL_Window* window);
static void sdl_window_target_real_pump_events (IWindowTarget* base);
static void sdl_window_target_real_swap (IWindowTarget* base);
SDL_Window* sdl_window_target_get_sdl_window (SDLWindowTarget* self);
static void sdl_window_target_finalize (GObject* obj);
static void _vala_sdl_window_target_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_sdl_window_target_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType vec3_get_type (void) G_GNUC_CONST;
Vec3* vec3_dup (const Vec3* self);
void vec3_free (Vec3* self);
#define RENDER_STATE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_RENDER_STATE, RenderStatePrivate))
enum  {
	RENDER_STATE_DUMMY_PROPERTY
};
static void render_state_set_screen_width (RenderState* self, gint value);
static void render_state_set_screen_height (RenderState* self, gint value);
void render_state_add_3D_object (RenderState* self, Render3DObject* object);
gint render_state_get_screen_width (RenderState* self);
gint render_state_get_screen_height (RenderState* self);
GeeArrayList* render_state_get_objects (RenderState* self);
void render_state_get_back_color (RenderState* self, Color* result);
void render_state_get_camera_position (RenderState* self, Vec3* result);
void render_state_set_camera_position (RenderState* self, Vec3* value);
void render_state_get_camera_rotation (RenderState* self, Vec3* result);
void render_state_set_camera_rotation (RenderState* self, Vec3* value);
static void render_state_finalize (RenderState* obj);
enum  {
	MAIN_VIEW_DUMMY_PROPERTY
};
View* view_construct (GType object_type);
static void main_view_real_do_render (View* base, RenderState* state, IResourceStore* store);
static void main_view_real_do_mouse_move (View* base, gint x, gint y);
static void main_view_real_do_load_resources (View* base, IResourceStore* store);
static void main_view_real_do_process (View* base, gdouble dt);
static void main_view_real_do_key_press (View* base, gchar key);
#define VIEW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_VIEW, ViewPrivate))
enum  {
	VIEW_DUMMY_PROPERTY
};
static void view_set_parent (View* self, View* parent);
void view_do_process (View* self, gdouble dt);
void view_do_render (View* self, RenderState* state, IResourceStore* store);
void view_do_mouse_move (View* self, gint x, gint y);
void view_do_key_press (View* self, gchar key);
void view_do_load_resources (View* self, IResourceStore* store);
static void view_real_do_load_resources (View* self, IResourceStore* store);
static void view_real_do_render (View* self, RenderState* state, IResourceStore* store);
static void view_real_do_process (View* self, gdouble dt);
static void view_real_do_mouse_move (View* self, gint x, gint y);
static void view_real_do_key_press (View* self, gchar key);
static void view_finalize (View* obj);


static void _main_window_menu_action_main_menu_menu_action (MainMenu* _sender, gpointer self) {
	main_window_menu_action (self, _sender);
}


MainWindow* main_window_construct (GType object_type, IWindowTarget* window, IRenderTarget* renderer) {
	MainWindow* self = NULL;
	MainMenu* _tmp0_ = NULL;
	View* _tmp1_ = NULL;
	g_return_val_if_fail (window != NULL, NULL);
	g_return_val_if_fail (renderer != NULL, NULL);
	self = (MainWindow*) render_window_construct (object_type, window, renderer);
	_tmp0_ = main_menu_new ();
	_view_unref0 (self->priv->menu);
	self->priv->menu = _tmp0_;
	g_signal_connect (self->priv->menu, "menu-action", (GCallback) _main_window_menu_action_main_menu_menu_action, self);
	_tmp1_ = render_window_get_main_view ((RenderWindow*) self);
	view_add_child (_tmp1_, (View*) self->priv->menu);
	return self;
}


MainWindow* main_window_new (IWindowTarget* window, IRenderTarget* renderer) {
	return main_window_construct (TYPE_MAIN_WINDOW, window, renderer);
}


static void main_window_menu_action (MainWindow* self, MainMenu* m) {
	MainMenuMenuAction _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (m != NULL);
	_tmp0_ = main_menu_get_action (m);
	switch (_tmp0_) {
		case MAIN_MENU_MENU_ACTION_SINGLE_PLAYER:
		{
			break;
		}
		case MAIN_MENU_MENU_ACTION_HOST_MULTI_PLAYER:
		{
			break;
		}
		case MAIN_MENU_MENU_ACTION_JOIN_MULTI_PLAYER:
		{
			break;
		}
		case MAIN_MENU_MENU_ACTION_EXIT:
		{
			render_window_finish ((RenderWindow*) self);
			break;
		}
		default:
		break;
	}
}


static void main_window_real_do_process (RenderWindow* base, gdouble dt) {
	MainWindow * self;
	SDL_Event e;
	self = (MainWindow*) base;
	{
		View* _tmp4_ = NULL;
		while (TRUE) {
			SDL_Event _tmp0_;
			gint _tmp1_;
			_tmp1_ = SDL_PollEvent (&_tmp0_);
			 (e);
			e = _tmp0_;
			if (!(_tmp1_ != 0)) {
				break;
			}
			if (e.type == SDL_QUIT) {
				render_window_finish ((RenderWindow*) self);
			} else {
				if (e.type == SDL_KEYDOWN) {
					main_window_key (self, (gchar) e.key.keysym.sym);
				} else {
					if (e.type == SDL_MOUSEMOTION) {
						gint x;
						gint y;
						View* _tmp2_ = NULL;
						x = 0;
						y = 0;
						SDL_GetMouseState (&x, &y);
						_tmp2_ = render_window_get_main_view ((RenderWindow*) self);
						view_mouse_move (_tmp2_, x, y);
					} else {
						gboolean _tmp3_ = FALSE;
						if (e.type == SDL_MOUSEBUTTONDOWN) {
							_tmp3_ = TRUE;
						} else {
							_tmp3_ = e.type == SDL_MOUSEBUTTONUP;
						}
						if (_tmp3_) {
							gint x;
							gint y;
							x = 0;
							y = 0;
							SDL_GetMouseState (&x, &y);
						} else {
							if (e.type == SDL_MOUSEWHEEL) {
							}
						}
					}
				}
			}
		}
		_tmp4_ = render_window_get_main_view ((RenderWindow*) self);
		view_process (_tmp4_, dt);
	}
	 (e);
}


static void main_window_key (MainWindow* self, gchar key) {
	g_return_if_fail (self != NULL);
	switch (key) {
		case 27:
		case 'q':
		{
			render_window_finish ((RenderWindow*) self);
			break;
		}
		case 'f':
		{
			gboolean _tmp0_;
			_tmp0_ = render_window_get_fullscreen ((RenderWindow*) self);
			render_window_set_fullscreen ((RenderWindow*) self, !_tmp0_);
			break;
		}
		default:
		{
			View* _tmp1_ = NULL;
			_tmp1_ = render_window_get_main_view ((RenderWindow*) self);
			view_key_press (_tmp1_, key);
			break;
		}
	}
}


static void main_window_class_init (MainWindowClass * klass) {
	main_window_parent_class = g_type_class_peek_parent (klass);
	RENDER_WINDOW_CLASS (klass)->finalize = main_window_finalize;
	g_type_class_add_private (klass, sizeof (MainWindowPrivate));
	RENDER_WINDOW_CLASS (klass)->do_process = main_window_real_do_process;
}


static void main_window_instance_init (MainWindow * self) {
	self->priv = MAIN_WINDOW_GET_PRIVATE (self);
}


static void main_window_finalize (RenderWindow* obj) {
	MainWindow * self;
	guint _tmp0_;
	self = MAIN_WINDOW (obj);
	g_signal_parse_name ("menu-action", TYPE_MAIN_MENU, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (self->priv->menu, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _main_window_menu_action_main_menu_menu_action, self);
	_view_unref0 (self->priv->menu);
	RENDER_WINDOW_CLASS (main_window_parent_class)->finalize (obj);
}


GType main_window_get_type (void) {
	static volatile gsize main_window_type_id__volatile = 0;
	if (g_once_init_enter (&main_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MainWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) main_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MainWindow), 0, (GInstanceInitFunc) main_window_instance_init, NULL };
		GType main_window_type_id;
		main_window_type_id = g_type_register_static (TYPE_RENDER_WINDOW, "MainWindow", &g_define_type_info, 0);
		g_once_init_leave (&main_window_type_id__volatile, main_window_type_id);
	}
	return main_window_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


RenderWindow* render_window_construct (GType object_type, IWindowTarget* window, IRenderTarget* renderer) {
	RenderWindow* self = NULL;
	IWindowTarget* _tmp0_;
	IRenderTarget* _tmp1_;
	MainView* _tmp2_ = NULL;
	MainView* _tmp3_;
	g_return_val_if_fail (window != NULL, NULL);
	g_return_val_if_fail (renderer != NULL, NULL);
	self = (RenderWindow*) g_type_create_instance (object_type);
	_tmp0_ = _g_object_ref0 (window);
	_g_object_unref0 (self->priv->window);
	self->priv->window = _tmp0_;
	_tmp1_ = _g_object_ref0 (renderer);
	_g_object_unref0 (self->renderer);
	self->renderer = _tmp1_;
	_tmp2_ = main_view_new (self);
	_tmp3_ = _tmp2_;
	render_window_set_main_view (self, (View*) _tmp3_);
	_view_unref0 (_tmp3_);
	return self;
}


void render_window_show (RenderWindow* self) {
	IResourceStore* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	self->priv->running = TRUE;
	_tmp0_ = irender_target_get_resource_store (self->renderer);
	render_window_load_resources (self, _tmp0_);
	while (TRUE) {
		gdouble _tmp1_;
		RenderState* _tmp2_ = NULL;
		RenderState* _tmp3_;
		if (!self->priv->running) {
			break;
		}
		_tmp1_ = render_window_get_delta (self);
		render_window_process (self, _tmp1_);
		_tmp2_ = render_window_render (self);
		_tmp3_ = _tmp2_;
		irender_target_set_state (self->renderer, _tmp3_);
		_render_state_unref0 (_tmp3_);
		iwindow_target_pump_events (self->priv->window);
		g_usleep ((gulong) 1000);
	}
}


void render_window_finish (RenderWindow* self) {
	g_return_if_fail (self != NULL);
	self->priv->running = FALSE;
}


static RenderState* render_window_render (RenderWindow* self) {
	RenderState* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	RenderState* _tmp2_ = NULL;
	RenderState* state;
	IResourceStore* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = iwindow_target_get_width (self->priv->window);
	_tmp1_ = iwindow_target_get_height (self->priv->window);
	_tmp2_ = render_state_new (_tmp0_, _tmp1_);
	state = _tmp2_;
	render_state_set_back_color (state, &self->priv->_back_color);
	_tmp3_ = irender_target_get_resource_store (self->renderer);
	view_render (self->priv->_main_view, state, _tmp3_);
	result = state;
	return result;
}


static gdouble render_window_get_delta (RenderWindow* self) {
	gdouble result = 0.0;
	g_return_val_if_fail (self != NULL, 0.0);
	result = 0.01;
	return result;
}


static void render_window_load_resources (RenderWindow* self, IResourceStore* store) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (store != NULL);
	view_load_resources (self->priv->_main_view, store);
}


static void render_window_process (RenderWindow* self, gdouble dt) {
	g_return_if_fail (self != NULL);
	render_window_do_process (self, dt);
	view_process (self->priv->_main_view, dt);
}


static void render_window_real_do_process (RenderWindow* self, gdouble dt) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `render_window_do_process'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void render_window_do_process (RenderWindow* self, gdouble dt) {
	RENDER_WINDOW_GET_CLASS (self)->do_process (self, dt);
}


View* render_window_get_main_view (RenderWindow* self) {
	View* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_main_view;
	return result;
}


static gpointer _view_ref0 (gpointer self) {
	return self ? view_ref (self) : NULL;
}


static void render_window_set_main_view (RenderWindow* self, View* value) {
	View* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _view_ref0 (value);
	_view_unref0 (self->priv->_main_view);
	self->priv->_main_view = _tmp0_;
}


gboolean render_window_get_fullscreen (RenderWindow* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = iwindow_target_get_fullscreen (self->priv->window);
	result = _tmp0_;
	return result;
}


void render_window_set_fullscreen (RenderWindow* self, gboolean value) {
	g_return_if_fail (self != NULL);
	iwindow_target_set_fullscreen (self->priv->window, value);
}


void render_window_get_back_color (RenderWindow* self, Color* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->_back_color;
	return;
}


void render_window_set_back_color (RenderWindow* self, Color* value) {
	g_return_if_fail (self != NULL);
	self->priv->_back_color = *value;
}


gint render_window_get_width (RenderWindow* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = iwindow_target_get_width (self->priv->window);
	result = _tmp0_;
	return result;
}


gint render_window_get_height (RenderWindow* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = iwindow_target_get_height (self->priv->window);
	result = _tmp0_;
	return result;
}


static void value_render_window_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_render_window_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		render_window_unref (value->data[0].v_pointer);
	}
}


static void value_render_window_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = render_window_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_render_window_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_render_window_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		RenderWindow* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = render_window_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_render_window_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	RenderWindow** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = render_window_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_render_window (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecRenderWindow* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_RENDER_WINDOW), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_render_window (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER_WINDOW), NULL);
	return value->data[0].v_pointer;
}


void value_set_render_window (GValue* value, gpointer v_object) {
	RenderWindow* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER_WINDOW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RENDER_WINDOW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		render_window_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		render_window_unref (old);
	}
}


void value_take_render_window (GValue* value, gpointer v_object) {
	RenderWindow* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER_WINDOW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RENDER_WINDOW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		render_window_unref (old);
	}
}


static void render_window_class_init (RenderWindowClass * klass) {
	render_window_parent_class = g_type_class_peek_parent (klass);
	RENDER_WINDOW_CLASS (klass)->finalize = render_window_finalize;
	g_type_class_add_private (klass, sizeof (RenderWindowPrivate));
	RENDER_WINDOW_CLASS (klass)->do_process = render_window_real_do_process;
}


static void render_window_instance_init (RenderWindow * self) {
	self->priv = RENDER_WINDOW_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void render_window_finalize (RenderWindow* obj) {
	RenderWindow * self;
	self = RENDER_WINDOW (obj);
	_g_object_unref0 (self->priv->window);
	_g_object_unref0 (self->renderer);
	_view_unref0 (self->priv->_main_view);
}


GType render_window_get_type (void) {
	static volatile gsize render_window_type_id__volatile = 0;
	if (g_once_init_enter (&render_window_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_render_window_init, value_render_window_free_value, value_render_window_copy_value, value_render_window_peek_pointer, "p", value_render_window_collect_value, "p", value_render_window_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (RenderWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) render_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RenderWindow), 0, (GInstanceInitFunc) render_window_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType render_window_type_id;
		render_window_type_id = g_type_register_fundamental (g_type_fundamental_next (), "RenderWindow", &g_define_type_info, &g_define_type_fundamental_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&render_window_type_id__volatile, render_window_type_id);
	}
	return render_window_type_id__volatile;
}


gpointer render_window_ref (gpointer instance) {
	RenderWindow* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void render_window_unref (gpointer instance) {
	RenderWindow* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		RENDER_WINDOW_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


void iwindow_target_swap (IWindowTarget* self) {
	IWINDOW_TARGET_GET_INTERFACE (self)->swap (self);
}


void iwindow_target_pump_events (IWindowTarget* self) {
	IWINDOW_TARGET_GET_INTERFACE (self)->pump_events (self);
}


gboolean iwindow_target_get_fullscreen (IWindowTarget* self) {
	return IWINDOW_TARGET_GET_INTERFACE (self)->get_fullscreen (self);
}


void iwindow_target_set_fullscreen (IWindowTarget* self, gboolean value) {
	IWINDOW_TARGET_GET_INTERFACE (self)->set_fullscreen (self, value);
}


gint iwindow_target_get_width (IWindowTarget* self) {
	return IWINDOW_TARGET_GET_INTERFACE (self)->get_width (self);
}


gint iwindow_target_get_height (IWindowTarget* self) {
	return IWINDOW_TARGET_GET_INTERFACE (self)->get_height (self);
}


static void iwindow_target_base_init (IWindowTargetIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_object_interface_install_property (iface, g_param_spec_boolean ("fullscreen", "fullscreen", "fullscreen", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_int ("width", "width", "width", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
		g_object_interface_install_property (iface, g_param_spec_int ("height", "height", "height", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	}
}


GType iwindow_target_get_type (void) {
	static volatile gsize iwindow_target_type_id__volatile = 0;
	if (g_once_init_enter (&iwindow_target_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IWindowTargetIface), (GBaseInitFunc) iwindow_target_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType iwindow_target_type_id;
		iwindow_target_type_id = g_type_register_static (G_TYPE_INTERFACE, "IWindowTarget", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (iwindow_target_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&iwindow_target_type_id__volatile, iwindow_target_type_id);
	}
	return iwindow_target_type_id__volatile;
}


SDLWindowTarget* sdl_window_target_construct (GType object_type, SDL_Window* window) {
	SDLWindowTarget * self = NULL;
	g_return_val_if_fail (window != NULL, NULL);
	self = (SDLWindowTarget*) g_object_new (object_type, NULL);
	self->priv->window = window;
	return self;
}


SDLWindowTarget* sdl_window_target_new (SDL_Window* window) {
	return sdl_window_target_construct (TYPE_SDL_WINDOW_TARGET, window);
}


static void sdl_window_target_real_pump_events (IWindowTarget* base) {
	SDLWindowTarget * self;
	self = (SDLWindowTarget*) base;
	SDL_PumpEvents ();
}


static void sdl_window_target_real_swap (IWindowTarget* base) {
	SDLWindowTarget * self;
	self = (SDLWindowTarget*) base;
	SDL_GL_SwapWindow (self->priv->window);
}


static gboolean sdl_window_target_real_get_fullscreen (IWindowTarget* base) {
	gboolean result;
	SDLWindowTarget* self;
	self = (SDLWindowTarget*) base;
	result = self->priv->is_fullscreen;
	return result;
}


static void sdl_window_target_real_set_fullscreen (IWindowTarget* base, gboolean value) {
	SDLWindowTarget* self;
	SDL_WindowFlags _tmp0_ = 0;
	self = (SDLWindowTarget*) base;
	self->priv->is_fullscreen = value;
	if (self->priv->is_fullscreen) {
		_tmp0_ = SDL_WINDOW_FULLSCREEN_DESKTOP;
	} else {
		_tmp0_ = 0;
	}
	SDL_SetWindowFullscreen (self->priv->window, (guint32) _tmp0_);
	g_object_notify ((GObject *) self, "fullscreen");
}


static gint sdl_window_target_real_get_width (IWindowTarget* base) {
	gint result;
	SDLWindowTarget* self;
	gint width = 0;
	gint height = 0;
	gint _tmp0_;
	gint _tmp1_;
	self = (SDLWindowTarget*) base;
	SDL_GetWindowSize (self->priv->window, &_tmp0_, &_tmp1_);
	width = _tmp0_;
	height = _tmp1_;
	result = width;
	return result;
}


static gint sdl_window_target_real_get_height (IWindowTarget* base) {
	gint result;
	SDLWindowTarget* self;
	gint width = 0;
	gint height = 0;
	gint _tmp0_;
	gint _tmp1_;
	self = (SDLWindowTarget*) base;
	SDL_GetWindowSize (self->priv->window, &_tmp0_, &_tmp1_);
	width = _tmp0_;
	height = _tmp1_;
	result = height;
	return result;
}


SDL_Window* sdl_window_target_get_sdl_window (SDLWindowTarget* self) {
	SDL_Window* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->window;
	return result;
}


static void sdl_window_target_class_init (SDLWindowTargetClass * klass) {
	sdl_window_target_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SDLWindowTargetPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_sdl_window_target_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_sdl_window_target_set_property;
	G_OBJECT_CLASS (klass)->finalize = sdl_window_target_finalize;
	g_object_class_override_property (G_OBJECT_CLASS (klass), SDL_WINDOW_TARGET_FULLSCREEN, "fullscreen");
	g_object_class_override_property (G_OBJECT_CLASS (klass), SDL_WINDOW_TARGET_WIDTH, "width");
	g_object_class_override_property (G_OBJECT_CLASS (klass), SDL_WINDOW_TARGET_HEIGHT, "height");
	g_object_class_install_property (G_OBJECT_CLASS (klass), SDL_WINDOW_TARGET_SDL_WINDOW, g_param_spec_pointer ("sdl-window", "sdl-window", "sdl-window", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void sdl_window_target_iwindow_target_interface_init (IWindowTargetIface * iface) {
	sdl_window_target_iwindow_target_parent_iface = g_type_interface_peek_parent (iface);
	iface->pump_events = (void (*)(IWindowTarget*)) sdl_window_target_real_pump_events;
	iface->swap = (void (*)(IWindowTarget*)) sdl_window_target_real_swap;
	iface->get_fullscreen = sdl_window_target_real_get_fullscreen;
	iface->set_fullscreen = sdl_window_target_real_set_fullscreen;
	iface->get_width = sdl_window_target_real_get_width;
	iface->get_height = sdl_window_target_real_get_height;
}


static void sdl_window_target_instance_init (SDLWindowTarget * self) {
	self->priv = SDL_WINDOW_TARGET_GET_PRIVATE (self);
	self->priv->is_fullscreen = FALSE;
}


static void sdl_window_target_finalize (GObject* obj) {
	SDLWindowTarget * self;
	self = SDL_WINDOW_TARGET (obj);
	G_OBJECT_CLASS (sdl_window_target_parent_class)->finalize (obj);
}


GType sdl_window_target_get_type (void) {
	static volatile gsize sdl_window_target_type_id__volatile = 0;
	if (g_once_init_enter (&sdl_window_target_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SDLWindowTargetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) sdl_window_target_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SDLWindowTarget), 0, (GInstanceInitFunc) sdl_window_target_instance_init, NULL };
		static const GInterfaceInfo iwindow_target_info = { (GInterfaceInitFunc) sdl_window_target_iwindow_target_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType sdl_window_target_type_id;
		sdl_window_target_type_id = g_type_register_static (G_TYPE_OBJECT, "SDLWindowTarget", &g_define_type_info, 0);
		g_type_add_interface_static (sdl_window_target_type_id, TYPE_IWINDOW_TARGET, &iwindow_target_info);
		g_once_init_leave (&sdl_window_target_type_id__volatile, sdl_window_target_type_id);
	}
	return sdl_window_target_type_id__volatile;
}


static void _vala_sdl_window_target_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SDLWindowTarget * self;
	self = SDL_WINDOW_TARGET (object);
	switch (property_id) {
		case SDL_WINDOW_TARGET_FULLSCREEN:
		g_value_set_boolean (value, iwindow_target_get_fullscreen ((IWindowTarget*) self));
		break;
		case SDL_WINDOW_TARGET_WIDTH:
		g_value_set_int (value, iwindow_target_get_width ((IWindowTarget*) self));
		break;
		case SDL_WINDOW_TARGET_HEIGHT:
		g_value_set_int (value, iwindow_target_get_height ((IWindowTarget*) self));
		break;
		case SDL_WINDOW_TARGET_SDL_WINDOW:
		g_value_set_pointer (value, sdl_window_target_get_sdl_window (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_sdl_window_target_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SDLWindowTarget * self;
	self = SDL_WINDOW_TARGET (object);
	switch (property_id) {
		case SDL_WINDOW_TARGET_FULLSCREEN:
		iwindow_target_set_fullscreen ((IWindowTarget*) self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


RenderState* render_state_construct (GType object_type, gint width, gint height) {
	RenderState* self = NULL;
	self = (RenderState*) g_type_create_instance (object_type);
	render_state_set_screen_width (self, width);
	render_state_set_screen_height (self, height);
	return self;
}


RenderState* render_state_new (gint width, gint height) {
	return render_state_construct (TYPE_RENDER_STATE, width, height);
}


void render_state_add_3D_object (RenderState* self, Render3DObject* object) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (object != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->objs, object);
}


gint render_state_get_screen_width (RenderState* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_screen_width;
	return result;
}


static void render_state_set_screen_width (RenderState* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_screen_width = value;
}


gint render_state_get_screen_height (RenderState* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_screen_height;
	return result;
}


static void render_state_set_screen_height (RenderState* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_screen_height = value;
}


GeeArrayList* render_state_get_objects (RenderState* self) {
	GeeArrayList* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->objs;
	return result;
}


void render_state_get_back_color (RenderState* self, Color* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->_back_color;
	return;
}


void render_state_set_back_color (RenderState* self, Color* value) {
	g_return_if_fail (self != NULL);
	self->priv->_back_color = *value;
}


void render_state_get_camera_position (RenderState* self, Vec3* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->_camera_position;
	return;
}


void render_state_set_camera_position (RenderState* self, Vec3* value) {
	g_return_if_fail (self != NULL);
	self->priv->_camera_position = *value;
}


void render_state_get_camera_rotation (RenderState* self, Vec3* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->_camera_rotation;
	return;
}


void render_state_set_camera_rotation (RenderState* self, Vec3* value) {
	g_return_if_fail (self != NULL);
	self->priv->_camera_rotation = *value;
}


static void value_render_state_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_render_state_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		render_state_unref (value->data[0].v_pointer);
	}
}


static void value_render_state_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = render_state_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_render_state_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_render_state_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		RenderState* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = render_state_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_render_state_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	RenderState** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = render_state_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_render_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecRenderState* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_RENDER_STATE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_render_state (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER_STATE), NULL);
	return value->data[0].v_pointer;
}


void value_set_render_state (GValue* value, gpointer v_object) {
	RenderState* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER_STATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RENDER_STATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		render_state_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		render_state_unref (old);
	}
}


void value_take_render_state (GValue* value, gpointer v_object) {
	RenderState* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER_STATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RENDER_STATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		render_state_unref (old);
	}
}


static void render_state_class_init (RenderStateClass * klass) {
	render_state_parent_class = g_type_class_peek_parent (klass);
	RENDER_STATE_CLASS (klass)->finalize = render_state_finalize;
	g_type_class_add_private (klass, sizeof (RenderStatePrivate));
}


static void render_state_instance_init (RenderState * self) {
	GeeArrayList* _tmp0_ = NULL;
	self->priv = RENDER_STATE_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (TYPE_RENDER3_DOBJECT, (GBoxedCopyFunc) render3_dobject_ref, render3_dobject_unref, NULL);
	self->priv->objs = _tmp0_;
	self->ref_count = 1;
}


static void render_state_finalize (RenderState* obj) {
	RenderState * self;
	self = RENDER_STATE (obj);
	_g_object_unref0 (self->priv->objs);
}


GType render_state_get_type (void) {
	static volatile gsize render_state_type_id__volatile = 0;
	if (g_once_init_enter (&render_state_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_render_state_init, value_render_state_free_value, value_render_state_copy_value, value_render_state_peek_pointer, "p", value_render_state_collect_value, "p", value_render_state_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (RenderStateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) render_state_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RenderState), 0, (GInstanceInitFunc) render_state_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType render_state_type_id;
		render_state_type_id = g_type_register_fundamental (g_type_fundamental_next (), "RenderState", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&render_state_type_id__volatile, render_state_type_id);
	}
	return render_state_type_id__volatile;
}


gpointer render_state_ref (gpointer instance) {
	RenderState* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void render_state_unref (gpointer instance) {
	RenderState* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		RENDER_STATE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static gpointer _render_window_ref0 (gpointer self) {
	return self ? render_window_ref (self) : NULL;
}


MainView* main_view_construct (GType object_type, RenderWindow* window) {
	MainView* self = NULL;
	RenderWindow* _tmp0_;
	g_return_val_if_fail (window != NULL, NULL);
	self = (MainView*) view_construct (object_type);
	_tmp0_ = _render_window_ref0 (window);
	_render_window_unref0 (((View*) self)->parent_window);
	((View*) self)->parent_window = _tmp0_;
	return self;
}


MainView* main_view_new (RenderWindow* window) {
	return main_view_construct (TYPE_MAIN_VIEW, window);
}


static void main_view_real_do_render (View* base, RenderState* state, IResourceStore* store) {
	MainView * self;
	self = (MainView*) base;
	g_return_if_fail (state != NULL);
	g_return_if_fail (store != NULL);
}


static void main_view_real_do_mouse_move (View* base, gint x, gint y) {
	MainView * self;
	self = (MainView*) base;
}


static void main_view_real_do_load_resources (View* base, IResourceStore* store) {
	MainView * self;
	self = (MainView*) base;
	g_return_if_fail (store != NULL);
}


static void main_view_real_do_process (View* base, gdouble dt) {
	MainView * self;
	self = (MainView*) base;
}


static void main_view_real_do_key_press (View* base, gchar key) {
	MainView * self;
	self = (MainView*) base;
}


static void main_view_class_init (MainViewClass * klass) {
	main_view_parent_class = g_type_class_peek_parent (klass);
	VIEW_CLASS (klass)->do_render = main_view_real_do_render;
	VIEW_CLASS (klass)->do_mouse_move = main_view_real_do_mouse_move;
	VIEW_CLASS (klass)->do_load_resources = main_view_real_do_load_resources;
	VIEW_CLASS (klass)->do_process = main_view_real_do_process;
	VIEW_CLASS (klass)->do_key_press = main_view_real_do_key_press;
}


static void main_view_instance_init (MainView * self) {
}


GType main_view_get_type (void) {
	static volatile gsize main_view_type_id__volatile = 0;
	if (g_once_init_enter (&main_view_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MainViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) main_view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MainView), 0, (GInstanceInitFunc) main_view_instance_init, NULL };
		GType main_view_type_id;
		main_view_type_id = g_type_register_static (TYPE_VIEW, "MainView", &g_define_type_info, 0);
		g_once_init_leave (&main_view_type_id__volatile, main_view_type_id);
	}
	return main_view_type_id__volatile;
}


void view_add_child (View* self, View* child) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (child != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->child_views, child);
	view_set_parent (child, self);
}


static void view_set_parent (View* self, View* parent) {
	View* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (parent != NULL);
	_tmp0_ = _view_ref0 (parent);
	_view_unref0 (self->priv->parent);
	self->priv->parent = _tmp0_;
	if (parent == NULL) {
		_render_window_unref0 (self->parent_window);
		self->parent_window = NULL;
	} else {
		RenderWindow* _tmp1_;
		_tmp1_ = _render_window_ref0 (parent->parent_window);
		_render_window_unref0 (self->parent_window);
		self->parent_window = _tmp1_;
	}
}


void view_process (View* self, gdouble dt) {
	g_return_if_fail (self != NULL);
	view_do_process (self, dt);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _view_list;
		gint _tmp1_;
		gint _view_size;
		gint _view_index;
		_tmp0_ = _g_object_ref0 (self->priv->child_views);
		_view_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _view_list);
		_view_size = _tmp1_;
		_view_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			View* view;
			_view_index = _view_index + 1;
			if (!(_view_index < _view_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _view_list, _view_index);
			view = (View*) _tmp2_;
			view_process (view, dt);
			_view_unref0 (view);
		}
		_g_object_unref0 (_view_list);
	}
}


void view_render (View* self, RenderState* state, IResourceStore* store) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (state != NULL);
	g_return_if_fail (store != NULL);
	view_do_render (self, state, store);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _view_list;
		gint _tmp1_;
		gint _view_size;
		gint _view_index;
		_tmp0_ = _g_object_ref0 (self->priv->child_views);
		_view_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _view_list);
		_view_size = _tmp1_;
		_view_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			View* view;
			_view_index = _view_index + 1;
			if (!(_view_index < _view_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _view_list, _view_index);
			view = (View*) _tmp2_;
			view_render (view, state, store);
			_view_unref0 (view);
		}
		_g_object_unref0 (_view_list);
	}
}


void view_mouse_move (View* self, gint x, gint y) {
	g_return_if_fail (self != NULL);
	view_do_mouse_move (self, x, y);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _view_list;
		gint _tmp1_;
		gint _view_size;
		gint _view_index;
		_tmp0_ = _g_object_ref0 (self->priv->child_views);
		_view_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _view_list);
		_view_size = _tmp1_;
		_view_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			View* view;
			_view_index = _view_index + 1;
			if (!(_view_index < _view_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _view_list, _view_index);
			view = (View*) _tmp2_;
			view_mouse_move (view, x, y);
			_view_unref0 (view);
		}
		_g_object_unref0 (_view_list);
	}
}


void view_key_press (View* self, gchar key) {
	g_return_if_fail (self != NULL);
	view_do_key_press (self, key);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _view_list;
		gint _tmp1_;
		gint _view_size;
		gint _view_index;
		_tmp0_ = _g_object_ref0 (self->priv->child_views);
		_view_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _view_list);
		_view_size = _tmp1_;
		_view_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			View* view;
			_view_index = _view_index + 1;
			if (!(_view_index < _view_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _view_list, _view_index);
			view = (View*) _tmp2_;
			view_key_press (view, key);
			_view_unref0 (view);
		}
		_g_object_unref0 (_view_list);
	}
}


void view_load_resources (View* self, IResourceStore* store) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (store != NULL);
	view_do_load_resources (self, store);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _view_list;
		gint _tmp1_;
		gint _view_size;
		gint _view_index;
		_tmp0_ = _g_object_ref0 (self->priv->child_views);
		_view_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _view_list);
		_view_size = _tmp1_;
		_view_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			View* view;
			_view_index = _view_index + 1;
			if (!(_view_index < _view_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _view_list, _view_index);
			view = (View*) _tmp2_;
			view_load_resources (view, store);
			_view_unref0 (view);
		}
		_g_object_unref0 (_view_list);
	}
}


static void view_real_do_load_resources (View* self, IResourceStore* store) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_do_load_resources'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_do_load_resources (View* self, IResourceStore* store) {
	VIEW_GET_CLASS (self)->do_load_resources (self, store);
}


static void view_real_do_render (View* self, RenderState* state, IResourceStore* store) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_do_render'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_do_render (View* self, RenderState* state, IResourceStore* store) {
	VIEW_GET_CLASS (self)->do_render (self, state, store);
}


static void view_real_do_process (View* self, gdouble dt) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_do_process'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_do_process (View* self, gdouble dt) {
	VIEW_GET_CLASS (self)->do_process (self, dt);
}


static void view_real_do_mouse_move (View* self, gint x, gint y) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_do_mouse_move'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_do_mouse_move (View* self, gint x, gint y) {
	VIEW_GET_CLASS (self)->do_mouse_move (self, x, y);
}


static void view_real_do_key_press (View* self, gchar key) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `view_do_key_press'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void view_do_key_press (View* self, gchar key) {
	VIEW_GET_CLASS (self)->do_key_press (self, key);
}


View* view_construct (GType object_type) {
	View* self = NULL;
	self = (View*) g_type_create_instance (object_type);
	return self;
}


static void value_view_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_view_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		view_unref (value->data[0].v_pointer);
	}
}


static void value_view_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = view_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_view_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_view_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		View* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = view_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_view_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	View** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = view_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_view (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecView* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_VIEW), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_view (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_VIEW), NULL);
	return value->data[0].v_pointer;
}


void value_set_view (GValue* value, gpointer v_object) {
	View* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_VIEW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_VIEW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		view_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		view_unref (old);
	}
}


void value_take_view (GValue* value, gpointer v_object) {
	View* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_VIEW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_VIEW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		view_unref (old);
	}
}


static void view_class_init (ViewClass * klass) {
	view_parent_class = g_type_class_peek_parent (klass);
	VIEW_CLASS (klass)->finalize = view_finalize;
	g_type_class_add_private (klass, sizeof (ViewPrivate));
	VIEW_CLASS (klass)->do_load_resources = view_real_do_load_resources;
	VIEW_CLASS (klass)->do_render = view_real_do_render;
	VIEW_CLASS (klass)->do_process = view_real_do_process;
	VIEW_CLASS (klass)->do_mouse_move = view_real_do_mouse_move;
	VIEW_CLASS (klass)->do_key_press = view_real_do_key_press;
}


static void view_instance_init (View * self) {
	GeeArrayList* _tmp0_ = NULL;
	self->priv = VIEW_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (TYPE_VIEW, (GBoxedCopyFunc) view_ref, view_unref, NULL);
	self->priv->child_views = _tmp0_;
	self->ref_count = 1;
}


static void view_finalize (View* obj) {
	View * self;
	self = VIEW (obj);
	_g_object_unref0 (self->priv->child_views);
	_render_window_unref0 (self->parent_window);
	_view_unref0 (self->priv->parent);
}


GType view_get_type (void) {
	static volatile gsize view_type_id__volatile = 0;
	if (g_once_init_enter (&view_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_view_init, value_view_free_value, value_view_copy_value, value_view_peek_pointer, "p", value_view_collect_value, "p", value_view_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (View), 0, (GInstanceInitFunc) view_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType view_type_id;
		view_type_id = g_type_register_fundamental (g_type_fundamental_next (), "View", &g_define_type_info, &g_define_type_fundamental_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&view_type_id__volatile, view_type_id);
	}
	return view_type_id__volatile;
}


gpointer view_ref (gpointer instance) {
	View* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void view_unref (gpointer instance) {
	View* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		VIEW_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


Color* color_dup (const Color* self) {
	Color* dup;
	dup = g_new0 (Color, 1);
	memcpy (dup, self, sizeof (Color));
	return dup;
}


void color_free (Color* self) {
	g_free (self);
}


GType color_get_type (void) {
	static volatile gsize color_type_id__volatile = 0;
	if (g_once_init_enter (&color_type_id__volatile)) {
		GType color_type_id;
		color_type_id = g_boxed_type_register_static ("Color", (GBoxedCopyFunc) color_dup, (GBoxedFreeFunc) color_free);
		g_once_init_leave (&color_type_id__volatile, color_type_id);
	}
	return color_type_id__volatile;
}



