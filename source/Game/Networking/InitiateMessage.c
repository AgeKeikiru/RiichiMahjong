/* InitiateMessage.c generated by valac 0.12.0, the Vala compiler
 * generated from InitiateMessage.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_MESSAGE (message_get_type ())
#define MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MESSAGE, Message))
#define MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MESSAGE, MessageClass))
#define IS_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MESSAGE))
#define IS_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MESSAGE))
#define MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MESSAGE, MessageClass))

typedef struct _Message Message;
typedef struct _MessageClass MessageClass;
typedef struct _MessagePrivate MessagePrivate;

#define TYPE_GAME_MESSAGE (game_message_get_type ())
#define GAME_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_MESSAGE, GameMessage))
#define GAME_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_MESSAGE, GameMessageClass))
#define IS_GAME_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_MESSAGE))
#define IS_GAME_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_MESSAGE))
#define GAME_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_MESSAGE, GameMessageClass))

typedef struct _GameMessage GameMessage;
typedef struct _GameMessageClass GameMessageClass;
typedef struct _GameMessagePrivate GameMessagePrivate;

#define TYPE_INITIATE_MESSAGE (initiate_message_get_type ())
#define INITIATE_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INITIATE_MESSAGE, InitiateMessage))
#define INITIATE_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INITIATE_MESSAGE, InitiateMessageClass))
#define IS_INITIATE_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INITIATE_MESSAGE))
#define IS_INITIATE_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INITIATE_MESSAGE))
#define INITIATE_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INITIATE_MESSAGE, InitiateMessageClass))

typedef struct _InitiateMessage InitiateMessage;
typedef struct _InitiateMessageClass InitiateMessageClass;
typedef struct _InitiateMessagePrivate InitiateMessagePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_array_unref0(var) ((var == NULL) ? NULL : (var = (g_array_unref (var), NULL)))

struct _Message {
	GObject parent_instance;
	MessagePrivate * priv;
};

struct _MessageClass {
	GObjectClass parent_class;
};

struct _GameMessage {
	Message parent_instance;
	GameMessagePrivate * priv;
};

struct _GameMessageClass {
	MessageClass parent_class;
};

struct _InitiateMessage {
	GameMessage parent_instance;
	InitiateMessagePrivate * priv;
};

struct _InitiateMessageClass {
	GameMessageClass parent_class;
};

struct _InitiateMessagePrivate {
	guint32 _major;
	guint32 _minor;
	guint32 _revision;
	gboolean _accepted;
	gboolean _reply;
	gchar* _name;
};


static gpointer initiate_message_parent_class = NULL;

GType message_get_type (void) G_GNUC_CONST;
GType game_message_get_type (void) G_GNUC_CONST;
GType initiate_message_get_type (void) G_GNUC_CONST;
#define INITIATE_MESSAGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_INITIATE_MESSAGE, InitiateMessagePrivate))
enum  {
	INITIATE_MESSAGE_DUMMY_PROPERTY,
	INITIATE_MESSAGE_MAJOR,
	INITIATE_MESSAGE_MINOR,
	INITIATE_MESSAGE_REVISION,
	INITIATE_MESSAGE_ACCEPTED,
	INITIATE_MESSAGE_REPLY,
	INITIATE_MESSAGE_NAME
};
InitiateMessage* initiate_message_new (guint8* data, int data_length1, guint32 type);
InitiateMessage* initiate_message_construct (GType object_type, guint8* data, int data_length1, guint32 type);
Message* message_new_empty (void);
Message* message_construct_empty (GType object_type);
#define GAME_MESSAGE_INIT ((guint32) 0x1)
guint32 game_message_get_uint_at (guint8* data, int data_length1, gint pos);
static void initiate_message_set_major (InitiateMessage* self, guint32 value);
static void initiate_message_set_minor (InitiateMessage* self, guint32 value);
static void initiate_message_set_revision (InitiateMessage* self, guint32 value);
static void initiate_message_set_accepted (InitiateMessage* self, gboolean value);
static void initiate_message_set_reply (InitiateMessage* self, gboolean value);
static void initiate_message_set_name (InitiateMessage* self, const gchar* value);
#define GAME_MESSAGE_INIT_REPLY ((guint32) 0x2)
gchar* game_message_get_string_at (guint8* data, int data_length1, guint32 pos, guint32 len);
InitiateMessage* initiate_message_new_initiate (guint32 major, guint32 minor, guint32 revision);
InitiateMessage* initiate_message_construct_initiate (GType object_type, guint32 major, guint32 minor, guint32 revision);
guint8* int_to_data (guint32 n, int* result_length1);
GameMessage* game_message_new (GArray* chunks, guint32 type);
GameMessage* game_message_construct (GType object_type, GArray* chunks, guint32 type);
InitiateMessage* initiate_message_new_initiate_reply (gboolean accepted, const gchar* name);
InitiateMessage* initiate_message_construct_initiate_reply (GType object_type, gboolean accepted, const gchar* name);
guint32 initiate_message_get_major (InitiateMessage* self);
guint32 initiate_message_get_minor (InitiateMessage* self);
guint32 initiate_message_get_revision (InitiateMessage* self);
gboolean initiate_message_get_accepted (InitiateMessage* self);
gboolean initiate_message_get_reply (InitiateMessage* self);
const gchar* initiate_message_get_name (InitiateMessage* self);
static void initiate_message_finalize (GObject* obj);
static void _vala_initiate_message_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_initiate_message_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


InitiateMessage* initiate_message_construct (GType object_type, guint8* data, int data_length1, guint32 type) {
	InitiateMessage * self = NULL;
	self = (InitiateMessage*) message_construct_empty (object_type);
	if (type == GAME_MESSAGE_INIT) {
		guint32 _tmp0_;
		guint32 _tmp1_;
		guint32 _tmp2_;
		_tmp0_ = game_message_get_uint_at (data, data_length1, 0);
		initiate_message_set_major (self, _tmp0_);
		_tmp1_ = game_message_get_uint_at (data, data_length1, 4);
		initiate_message_set_minor (self, _tmp1_);
		_tmp2_ = game_message_get_uint_at (data, data_length1, 8);
		initiate_message_set_revision (self, _tmp2_);
		initiate_message_set_accepted (self, TRUE);
		initiate_message_set_reply (self, FALSE);
		initiate_message_set_name (self, "");
	} else {
		if (type == GAME_MESSAGE_INIT_REPLY) {
			guint32 _tmp3_;
			guint32 len;
			gchar* _tmp4_ = NULL;
			gchar* _tmp5_;
			initiate_message_set_major (self, (guint32) 0);
			initiate_message_set_minor (self, (guint32) 0);
			initiate_message_set_revision (self, (guint32) 0);
			initiate_message_set_accepted (self, data[0] != 0);
			initiate_message_set_reply (self, TRUE);
			_tmp3_ = game_message_get_uint_at (data, data_length1, 1);
			len = _tmp3_;
			_tmp4_ = game_message_get_string_at (data, data_length1, (guint32) 5, len);
			_tmp5_ = _tmp4_;
			initiate_message_set_name (self, _tmp5_);
			_g_free0 (_tmp5_);
		}
	}
	return self;
}


InitiateMessage* initiate_message_new (guint8* data, int data_length1, guint32 type) {
	return initiate_message_construct (TYPE_INITIATE_MESSAGE, data, data_length1, type);
}


InitiateMessage* initiate_message_construct_initiate (GType object_type, guint32 major, guint32 minor, guint32 revision) {
	InitiateMessage * self = NULL;
	GArray* _tmp0_ = NULL;
	GArray* chunks;
	gint _tmp1_;
	guint8* _tmp2_ = NULL;
	guint8* _tmp3_;
	gint _tmp3__length1;
	gint _tmp4_;
	guint8* _tmp5_ = NULL;
	guint8* _tmp6_;
	gint _tmp6__length1;
	gint _tmp7_;
	guint8* _tmp8_ = NULL;
	guint8* _tmp9_;
	gint _tmp9__length1;
	_tmp0_ = g_array_new (TRUE, TRUE, (gulong) 1);
	chunks = _tmp0_;
	_tmp2_ = int_to_data (major, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _tmp1_;
	g_array_append_vals (chunks, _tmp3_, (guint) 4);
	_tmp3_ = (g_free (_tmp3_), NULL);
	_tmp5_ = int_to_data (minor, &_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp6__length1 = _tmp4_;
	g_array_append_vals (chunks, _tmp6_, (guint) 4);
	_tmp6_ = (g_free (_tmp6_), NULL);
	_tmp8_ = int_to_data (revision, &_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp9__length1 = _tmp7_;
	g_array_append_vals (chunks, _tmp9_, (guint) 4);
	_tmp9_ = (g_free (_tmp9_), NULL);
	self = (InitiateMessage*) game_message_construct (object_type, chunks, GAME_MESSAGE_INIT);
	initiate_message_set_major (self, major);
	initiate_message_set_minor (self, minor);
	initiate_message_set_revision (self, revision);
	initiate_message_set_accepted (self, TRUE);
	initiate_message_set_reply (self, FALSE);
	_g_array_unref0 (chunks);
	return self;
}


InitiateMessage* initiate_message_new_initiate (guint32 major, guint32 minor, guint32 revision) {
	return initiate_message_construct_initiate (TYPE_INITIATE_MESSAGE, major, minor, revision);
}


static guint8* string_get_data (const gchar* self, int* result_length1) {
	guint8* result;
	guint8* res;
	gint res_length1;
	gint _res_size_;
	gint _tmp0_;
	guint8* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = -1;
	_tmp0_ = strlen (self);
	res_length1 = (gint) _tmp0_;
	_tmp1_ = res;
	*result_length1 = res_length1;
	result = _tmp1_;
	return result;
}


InitiateMessage* initiate_message_construct_initiate_reply (GType object_type, gboolean accepted, const gchar* name) {
	InitiateMessage * self = NULL;
	gint _tmp0_ = 0;
	guint8 c;
	GArray* _tmp1_ = NULL;
	GArray* chunks;
	gint _tmp2_;
	gint _tmp3_;
	guint8* _tmp4_ = NULL;
	guint8* _tmp5_;
	gint _tmp5__length1;
	guint8* _tmp6_ = NULL;
	gint _tmp7_;
	gint _tmp8_;
	g_return_val_if_fail (name != NULL, NULL);
	if (accepted) {
		_tmp0_ = 1;
	} else {
		_tmp0_ = 0;
	}
	c = (guint8) _tmp0_;
	_tmp1_ = g_array_new (TRUE, TRUE, (gulong) 1);
	chunks = _tmp1_;
	g_array_append_val (chunks, c);
	_tmp2_ = strlen (name);
	_tmp4_ = int_to_data ((guint32) _tmp2_, &_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp5__length1 = _tmp3_;
	g_array_append_vals (chunks, _tmp5_, (guint) 4);
	_tmp5_ = (g_free (_tmp5_), NULL);
	_tmp6_ = string_get_data (name, &_tmp7_);
	_tmp8_ = strlen (name);
	g_array_append_vals (chunks, _tmp6_, (guint) _tmp8_);
	self = (InitiateMessage*) game_message_construct (object_type, chunks, GAME_MESSAGE_INIT_REPLY);
	initiate_message_set_major (self, (guint32) 0);
	initiate_message_set_minor (self, (guint32) 0);
	initiate_message_set_revision (self, (guint32) 0);
	initiate_message_set_accepted (self, accepted);
	initiate_message_set_reply (self, TRUE);
	initiate_message_set_name (self, name);
	_g_array_unref0 (chunks);
	return self;
}


InitiateMessage* initiate_message_new_initiate_reply (gboolean accepted, const gchar* name) {
	return initiate_message_construct_initiate_reply (TYPE_INITIATE_MESSAGE, accepted, name);
}


guint32 initiate_message_get_major (InitiateMessage* self) {
	guint32 result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_major;
	return result;
}


static void initiate_message_set_major (InitiateMessage* self, guint32 value) {
	g_return_if_fail (self != NULL);
	self->priv->_major = value;
	g_object_notify ((GObject *) self, "major");
}


guint32 initiate_message_get_minor (InitiateMessage* self) {
	guint32 result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_minor;
	return result;
}


static void initiate_message_set_minor (InitiateMessage* self, guint32 value) {
	g_return_if_fail (self != NULL);
	self->priv->_minor = value;
	g_object_notify ((GObject *) self, "minor");
}


guint32 initiate_message_get_revision (InitiateMessage* self) {
	guint32 result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_revision;
	return result;
}


static void initiate_message_set_revision (InitiateMessage* self, guint32 value) {
	g_return_if_fail (self != NULL);
	self->priv->_revision = value;
	g_object_notify ((GObject *) self, "revision");
}


gboolean initiate_message_get_accepted (InitiateMessage* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_accepted;
	return result;
}


static void initiate_message_set_accepted (InitiateMessage* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_accepted = value;
	g_object_notify ((GObject *) self, "accepted");
}


gboolean initiate_message_get_reply (InitiateMessage* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_reply;
	return result;
}


static void initiate_message_set_reply (InitiateMessage* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_reply = value;
	g_object_notify ((GObject *) self, "reply");
}


const gchar* initiate_message_get_name (InitiateMessage* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_name;
	return result;
}


static void initiate_message_set_name (InitiateMessage* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp0_;
	g_object_notify ((GObject *) self, "name");
}


static void initiate_message_class_init (InitiateMessageClass * klass) {
	initiate_message_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (InitiateMessagePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_initiate_message_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_initiate_message_set_property;
	G_OBJECT_CLASS (klass)->finalize = initiate_message_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), INITIATE_MESSAGE_MAJOR, g_param_spec_uint ("major", "major", "major", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INITIATE_MESSAGE_MINOR, g_param_spec_uint ("minor", "minor", "minor", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INITIATE_MESSAGE_REVISION, g_param_spec_uint ("revision", "revision", "revision", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INITIATE_MESSAGE_ACCEPTED, g_param_spec_boolean ("accepted", "accepted", "accepted", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INITIATE_MESSAGE_REPLY, g_param_spec_boolean ("reply", "reply", "reply", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INITIATE_MESSAGE_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void initiate_message_instance_init (InitiateMessage * self) {
	self->priv = INITIATE_MESSAGE_GET_PRIVATE (self);
}


static void initiate_message_finalize (GObject* obj) {
	InitiateMessage * self;
	self = INITIATE_MESSAGE (obj);
	_g_free0 (self->priv->_name);
	G_OBJECT_CLASS (initiate_message_parent_class)->finalize (obj);
}


GType initiate_message_get_type (void) {
	static volatile gsize initiate_message_type_id__volatile = 0;
	if (g_once_init_enter (&initiate_message_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (InitiateMessageClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) initiate_message_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (InitiateMessage), 0, (GInstanceInitFunc) initiate_message_instance_init, NULL };
		GType initiate_message_type_id;
		initiate_message_type_id = g_type_register_static (TYPE_GAME_MESSAGE, "InitiateMessage", &g_define_type_info, 0);
		g_once_init_leave (&initiate_message_type_id__volatile, initiate_message_type_id);
	}
	return initiate_message_type_id__volatile;
}


static void _vala_initiate_message_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	InitiateMessage * self;
	self = INITIATE_MESSAGE (object);
	switch (property_id) {
		case INITIATE_MESSAGE_MAJOR:
		g_value_set_uint (value, initiate_message_get_major (self));
		break;
		case INITIATE_MESSAGE_MINOR:
		g_value_set_uint (value, initiate_message_get_minor (self));
		break;
		case INITIATE_MESSAGE_REVISION:
		g_value_set_uint (value, initiate_message_get_revision (self));
		break;
		case INITIATE_MESSAGE_ACCEPTED:
		g_value_set_boolean (value, initiate_message_get_accepted (self));
		break;
		case INITIATE_MESSAGE_REPLY:
		g_value_set_boolean (value, initiate_message_get_reply (self));
		break;
		case INITIATE_MESSAGE_NAME:
		g_value_set_string (value, initiate_message_get_name (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_initiate_message_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	InitiateMessage * self;
	self = INITIATE_MESSAGE (object);
	switch (property_id) {
		case INITIATE_MESSAGE_MAJOR:
		initiate_message_set_major (self, g_value_get_uint (value));
		break;
		case INITIATE_MESSAGE_MINOR:
		initiate_message_set_minor (self, g_value_get_uint (value));
		break;
		case INITIATE_MESSAGE_REVISION:
		initiate_message_set_revision (self, g_value_get_uint (value));
		break;
		case INITIATE_MESSAGE_ACCEPTED:
		initiate_message_set_accepted (self, g_value_get_boolean (value));
		break;
		case INITIATE_MESSAGE_REPLY:
		initiate_message_set_reply (self, g_value_get_boolean (value));
		break;
		case INITIATE_MESSAGE_NAME:
		initiate_message_set_name (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



