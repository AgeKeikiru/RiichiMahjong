/* GameNetworking.c generated by valac 0.12.0, the Vala compiler
 * generated from GameNetworking.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define TYPE_GAME_NETWORKING (game_networking_get_type ())
#define GAME_NETWORKING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_NETWORKING, GameNetworking))
#define GAME_NETWORKING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_NETWORKING, GameNetworkingClass))
#define IS_GAME_NETWORKING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_NETWORKING))
#define IS_GAME_NETWORKING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_NETWORKING))
#define GAME_NETWORKING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_NETWORKING, GameNetworkingClass))

typedef struct _GameNetworking GameNetworking;
typedef struct _GameNetworkingClass GameNetworkingClass;
typedef struct _GameNetworkingPrivate GameNetworkingPrivate;

#define TYPE_GAME_CONNECTION (game_connection_get_type ())
#define GAME_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_CONNECTION, GameConnection))
#define GAME_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_CONNECTION, GameConnectionClass))
#define IS_GAME_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_CONNECTION))
#define IS_GAME_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_CONNECTION))
#define GAME_CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_CONNECTION, GameConnectionClass))

typedef struct _GameConnection GameConnection;
typedef struct _GameConnectionClass GameConnectionClass;

#define TYPE_MESSAGE_SIGNAL (message_signal_get_type ())
#define MESSAGE_SIGNAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MESSAGE_SIGNAL, MessageSignal))
#define MESSAGE_SIGNAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MESSAGE_SIGNAL, MessageSignalClass))
#define IS_MESSAGE_SIGNAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MESSAGE_SIGNAL))
#define IS_MESSAGE_SIGNAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MESSAGE_SIGNAL))
#define MESSAGE_SIGNAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MESSAGE_SIGNAL, MessageSignalClass))

typedef struct _MessageSignal MessageSignal;
typedef struct _MessageSignalClass MessageSignalClass;

#define TYPE_CONNECTION (connection_get_type ())
#define CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONNECTION, Connection))
#define CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONNECTION, ConnectionClass))
#define IS_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONNECTION))
#define IS_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONNECTION))
#define CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONNECTION, ConnectionClass))

typedef struct _Connection Connection;
typedef struct _ConnectionClass ConnectionClass;

#define TYPE_MESSAGE (message_get_type ())
#define MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MESSAGE, Message))
#define MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MESSAGE, MessageClass))
#define IS_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MESSAGE))
#define IS_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MESSAGE))
#define MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MESSAGE, MessageClass))

typedef struct _Message Message;
typedef struct _MessageClass MessageClass;
#define __g_list_free__game_connection_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__game_connection_unref0_ (var), NULL)))

#define TYPE_GAME_MESSAGE (game_message_get_type ())
#define GAME_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_MESSAGE, GameMessage))
#define GAME_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_MESSAGE, GameMessageClass))
#define IS_GAME_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_MESSAGE))
#define IS_GAME_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_MESSAGE))
#define GAME_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_MESSAGE, GameMessageClass))

typedef struct _GameMessage GameMessage;
typedef struct _GameMessageClass GameMessageClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_INITIATE_MESSAGE (initiate_message_get_type ())
#define INITIATE_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INITIATE_MESSAGE, InitiateMessage))
#define INITIATE_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INITIATE_MESSAGE, InitiateMessageClass))
#define IS_INITIATE_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INITIATE_MESSAGE))
#define IS_INITIATE_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INITIATE_MESSAGE))
#define INITIATE_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INITIATE_MESSAGE, InitiateMessageClass))

typedef struct _InitiateMessage InitiateMessage;
typedef struct _InitiateMessageClass InitiateMessageClass;

#define TYPE_HOST_MESSAGE (host_message_get_type ())
#define HOST_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HOST_MESSAGE, HostMessage))
#define HOST_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_HOST_MESSAGE, HostMessageClass))
#define IS_HOST_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HOST_MESSAGE))
#define IS_HOST_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_HOST_MESSAGE))
#define HOST_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HOST_MESSAGE, HostMessageClass))

typedef struct _HostMessage HostMessage;
typedef struct _HostMessageClass HostMessageClass;

#define TYPE_PLAYER_CONNECTED_MESSAGE (player_connected_message_get_type ())
#define PLAYER_CONNECTED_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONNECTED_MESSAGE, PlayerConnectedMessage))
#define PLAYER_CONNECTED_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONNECTED_MESSAGE, PlayerConnectedMessageClass))
#define IS_PLAYER_CONNECTED_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONNECTED_MESSAGE))
#define IS_PLAYER_CONNECTED_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONNECTED_MESSAGE))
#define PLAYER_CONNECTED_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONNECTED_MESSAGE, PlayerConnectedMessageClass))

typedef struct _PlayerConnectedMessage PlayerConnectedMessage;
typedef struct _PlayerConnectedMessageClass PlayerConnectedMessageClass;
#define _game_connection_unref0(var) ((var == NULL) ? NULL : (var = (game_connection_unref (var), NULL)))

#define TYPE_GAME_START_MESSAGE (game_start_message_get_type ())
#define GAME_START_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_START_MESSAGE, GameStartMessage))
#define GAME_START_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_START_MESSAGE, GameStartMessageClass))
#define IS_GAME_START_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_START_MESSAGE))
#define IS_GAME_START_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_START_MESSAGE))
#define GAME_START_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_START_MESSAGE, GameStartMessageClass))

typedef struct _GameStartMessage GameStartMessage;
typedef struct _GameStartMessageClass GameStartMessageClass;
#define _g_rand_free0(var) ((var == NULL) ? NULL : (var = (g_rand_free (var), NULL)))

#define TYPE_PLAYER_MESSAGE (player_message_get_type ())
#define PLAYER_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_MESSAGE, PlayerMessage))
#define PLAYER_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_MESSAGE, PlayerMessageClass))
#define IS_PLAYER_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_MESSAGE))
#define IS_PLAYER_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_MESSAGE))
#define PLAYER_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_MESSAGE, PlayerMessageClass))

typedef struct _PlayerMessage PlayerMessage;
typedef struct _PlayerMessageClass PlayerMessageClass;
typedef struct _ParamSpecGameNetworking ParamSpecGameNetworking;
typedef struct _GameConnectionPrivate GameConnectionPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_CALL_ACTION_MESSAGE (call_action_message_get_type ())
#define CALL_ACTION_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CALL_ACTION_MESSAGE, CallActionMessage))
#define CALL_ACTION_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CALL_ACTION_MESSAGE, CallActionMessageClass))
#define IS_CALL_ACTION_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CALL_ACTION_MESSAGE))
#define IS_CALL_ACTION_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CALL_ACTION_MESSAGE))
#define CALL_ACTION_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CALL_ACTION_MESSAGE, CallActionMessageClass))

typedef struct _CallActionMessage CallActionMessage;
typedef struct _CallActionMessageClass CallActionMessageClass;

#define TYPE_CALL_ACTION (call_action_get_type ())
#define CALL_ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CALL_ACTION, CallAction))
#define CALL_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CALL_ACTION, CallActionClass))
#define IS_CALL_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CALL_ACTION))
#define IS_CALL_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CALL_ACTION))
#define CALL_ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CALL_ACTION, CallActionClass))

typedef struct _CallAction CallAction;
typedef struct _CallActionClass CallActionClass;

#define TYPE_TURN_ACTION_MESSAGE (turn_action_message_get_type ())
#define TURN_ACTION_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TURN_ACTION_MESSAGE, TurnActionMessage))
#define TURN_ACTION_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TURN_ACTION_MESSAGE, TurnActionMessageClass))
#define IS_TURN_ACTION_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TURN_ACTION_MESSAGE))
#define IS_TURN_ACTION_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TURN_ACTION_MESSAGE))
#define TURN_ACTION_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TURN_ACTION_MESSAGE, TurnActionMessageClass))

typedef struct _TurnActionMessage TurnActionMessage;
typedef struct _TurnActionMessageClass TurnActionMessageClass;

#define TYPE_TURN_ACTION (turn_action_get_type ())
#define TURN_ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TURN_ACTION, TurnAction))
#define TURN_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TURN_ACTION, TurnActionClass))
#define IS_TURN_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TURN_ACTION))
#define IS_TURN_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TURN_ACTION))
#define TURN_ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TURN_ACTION, TurnActionClass))

typedef struct _TurnAction TurnAction;
typedef struct _TurnActionClass TurnActionClass;
typedef struct _ParamSpecGameConnection ParamSpecGameConnection;

struct _GameNetworking {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GameNetworkingPrivate * priv;
};

struct _GameNetworkingClass {
	GTypeClass parent_class;
	void (*finalize) (GameNetworking *self);
};

struct _GameNetworkingPrivate {
	GList* _players;
	gboolean hosting;
	guint32 connection_id;
};

struct _ParamSpecGameNetworking {
	GParamSpec parent_instance;
};

struct _GameConnection {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GameConnectionPrivate * priv;
};

struct _GameConnectionClass {
	GTypeClass parent_class;
	void (*finalize) (GameConnection *self);
};

struct _GameConnectionPrivate {
	Connection* _connection;
	guint32 _id;
	gchar* _name;
};

struct _ParamSpecGameConnection {
	GParamSpec parent_instance;
};


static gpointer game_networking_parent_class = NULL;
extern MessageSignal* networking_message_received;
static gpointer game_connection_parent_class = NULL;

gpointer game_networking_ref (gpointer instance);
void game_networking_unref (gpointer instance);
GParamSpec* param_spec_game_networking (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_game_networking (GValue* value, gpointer v_object);
void value_take_game_networking (GValue* value, gpointer v_object);
gpointer value_get_game_networking (const GValue* value);
GType game_networking_get_type (void) G_GNUC_CONST;
gpointer game_connection_ref (gpointer instance);
void game_connection_unref (gpointer instance);
GParamSpec* param_spec_game_connection (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_game_connection (GValue* value, gpointer v_object);
void value_take_game_connection (GValue* value, gpointer v_object);
gpointer value_get_game_connection (const GValue* value);
GType game_connection_get_type (void) G_GNUC_CONST;
#define GAME_NETWORKING_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GAME_NETWORKING, GameNetworkingPrivate))
enum  {
	GAME_NETWORKING_DUMMY_PROPERTY
};
gpointer message_signal_ref (gpointer instance);
void message_signal_unref (gpointer instance);
GParamSpec* param_spec_message_signal (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_message_signal (GValue* value, gpointer v_object);
void value_take_message_signal (GValue* value, gpointer v_object);
gpointer value_get_message_signal (const GValue* value);
GType message_signal_get_type (void) G_GNUC_CONST;
GType connection_get_type (void) G_GNUC_CONST;
GType message_get_type (void) G_GNUC_CONST;
static void game_networking_message_received (GameNetworking* self, Connection* connection, Message* message);
static void _game_networking_message_received_message_signal_message (MessageSignal* _sender, Connection* connection, Message* message, gpointer self);
void networking_close_connections (void);
static void _game_connection_unref0_ (gpointer var);
static void _g_list_free__game_connection_unref0_ (GList* self);
#define GAME_NETWORKING_PORT ((guint16) 1337)
GameNetworking* game_networking_new (void);
GameNetworking* game_networking_construct (GType object_type);
GType game_message_get_type (void) G_GNUC_CONST;
GameMessage* game_message_parse (Message* message);
static void game_networking_host_received (GameNetworking* self, Connection* connection, GameMessage* message);
static void game_networking_client_received (GameNetworking* self, Connection* connection, GameMessage* message);
GType initiate_message_get_type (void) G_GNUC_CONST;
gboolean initiate_message_get_reply (InitiateMessage* self);
gboolean environment_is_compatible (guint32 major, guint32 minor, guint32 revision);
guint32 initiate_message_get_major (InitiateMessage* self);
guint32 initiate_message_get_minor (InitiateMessage* self);
guint32 initiate_message_get_revision (InitiateMessage* self);
void connection_send (Connection* self, Message* message);
InitiateMessage* initiate_message_new_initiate_reply (gboolean accepted, const gchar* name);
InitiateMessage* initiate_message_construct_initiate_reply (GType object_type, gboolean accepted, const gchar* name);
void connection_close (Connection* self);
gboolean initiate_message_get_accepted (InitiateMessage* self);
const gchar* initiate_message_get_name (InitiateMessage* self);
GameConnection* game_connection_new (Connection* connection, guint32 id, const gchar* name);
GameConnection* game_connection_construct (GType object_type, Connection* connection, guint32 id, const gchar* name);
guint32 game_connection_get_id (GameConnection* self);
const gchar* game_connection_get_name (GameConnection* self);
PlayerConnectedMessage* player_connected_message_new_message (guint32 id, const gchar* name, gboolean silent);
PlayerConnectedMessage* player_connected_message_construct_message (GType object_type, guint32 id, const gchar* name, gboolean silent);
GType host_message_get_type (void) G_GNUC_CONST;
GType player_connected_message_get_type (void) G_GNUC_CONST;
static void game_networking_send_to_all (GameNetworking* self, GameMessage* message);
Connection* game_connection_get_connection (GameConnection* self);
GameStartMessage* game_start_message_new_message (guint8 delay, guint8* tile_seed, int tile_seed_length1, guint8 wall_split, guint8 seat);
GameStartMessage* game_start_message_construct_message (GType object_type, guint8 delay, guint8* tile_seed, int tile_seed_length1, guint8 wall_split, guint8 seat);
GType game_start_message_get_type (void) G_GNUC_CONST;
GType player_message_get_type (void) G_GNUC_CONST;
guint32 player_message_get_id (PlayerMessage* self);
guint8* message_get_data (Message* self, int* result_length1);
guint32 player_connected_message_get_id (PlayerConnectedMessage* self);
const gchar* player_connected_message_get_name (PlayerConnectedMessage* self);
void game_connection_message_received (GameConnection* self, GameMessage* message);
gboolean game_networking_host (GameNetworking* self);
gboolean networking_host (guint16 port);
gboolean game_networking_join (GameNetworking* self, const gchar* address);
Connection* networking_join (const gchar* addr, guint16 port);
guint32 environment_get_version_major (void);
guint32 environment_get_version_minor (void);
guint32 environment_get_version_revision (void);
InitiateMessage* initiate_message_new_initiate (guint32 major, guint32 minor, guint32 revision);
InitiateMessage* initiate_message_construct_initiate (GType object_type, guint32 major, guint32 minor, guint32 revision);
GList* game_networking_get_players (GameNetworking* self);
static void game_networking_finalize (GameNetworking* obj);
#define GAME_CONNECTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GAME_CONNECTION, GameConnectionPrivate))
enum  {
	GAME_CONNECTION_DUMMY_PROPERTY
};
static void game_connection_set_connection (GameConnection* self, Connection* value);
static void game_connection_set_id (GameConnection* self, guint32 value);
static void game_connection_set_name (GameConnection* self, const gchar* value);
GType call_action_message_get_type (void) G_GNUC_CONST;
gpointer call_action_ref (gpointer instance);
void call_action_unref (gpointer instance);
GParamSpec* param_spec_call_action (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_call_action (GValue* value, gpointer v_object);
void value_take_call_action (GValue* value, gpointer v_object);
gpointer value_get_call_action (const GValue* value);
GType call_action_get_type (void) G_GNUC_CONST;
CallAction* call_action_message_get_call_action (CallActionMessage* self);
GType turn_action_message_get_type (void) G_GNUC_CONST;
gpointer turn_action_ref (gpointer instance);
void turn_action_unref (gpointer instance);
GParamSpec* param_spec_turn_action (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_turn_action (GValue* value, gpointer v_object);
void value_take_turn_action (GValue* value, gpointer v_object);
gpointer value_get_turn_action (const GValue* value);
GType turn_action_get_type (void) G_GNUC_CONST;
TurnAction* turn_action_message_get_turn_action (TurnActionMessage* self);
void game_connection_send_call_action (GameConnection* self, CallAction* action);
CallActionMessage* call_action_message_new_message (guint32 id, CallAction* action);
CallActionMessage* call_action_message_construct_message (GType object_type, guint32 id, CallAction* action);
void game_connection_send_turn_action (GameConnection* self, TurnAction* action);
TurnActionMessage* turn_action_message_new_message (guint32 id, TurnAction* action);
TurnActionMessage* turn_action_message_construct_message (GType object_type, guint32 id, TurnAction* action);
static void g_cclosure_user_marshal_VOID__CALL_ACTION (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__TURN_ACTION (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void game_connection_finalize (GameConnection* obj);


static void _game_networking_message_received_message_signal_message (MessageSignal* _sender, Connection* connection, Message* message, gpointer self) {
	game_networking_message_received (self, connection, message);
}


static void _game_connection_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (game_connection_unref (var), NULL));
}


static void _g_list_free__game_connection_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _game_connection_unref0_, NULL);
	g_list_free (self);
}


GameNetworking* game_networking_construct (GType object_type) {
	GameNetworking* self = NULL;
	self = (GameNetworking*) g_type_create_instance (object_type);
	g_signal_connect (networking_message_received, "message", (GCallback) _game_networking_message_received_message_signal_message, self);
	return self;
}


GameNetworking* game_networking_new (void) {
	return game_networking_construct (TYPE_GAME_NETWORKING);
}


static void game_networking_message_received (GameNetworking* self, Connection* connection, Message* message) {
	GameMessage* _tmp0_ = NULL;
	GameMessage* msg;
	g_return_if_fail (self != NULL);
	g_return_if_fail (connection != NULL);
	g_return_if_fail (message != NULL);
	_tmp0_ = game_message_parse (message);
	msg = _tmp0_;
	if (self->priv->hosting) {
		game_networking_host_received (self, connection, msg);
	} else {
		game_networking_client_received (self, connection, msg);
	}
	_g_object_unref0 (msg);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _game_connection_ref0 (gpointer self) {
	return self ? game_connection_ref (self) : NULL;
}


static void game_networking_host_received (GameNetworking* self, Connection* connection, GameMessage* message) {
	GType _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (connection != NULL);
	g_return_if_fail (message != NULL);
	_tmp0_ = G_TYPE_FROM_INSTANCE ((GObject*) message);
	if (_tmp0_ == TYPE_INITIATE_MESSAGE) {
		InitiateMessage* _tmp1_;
		InitiateMessage* i;
		gboolean _tmp2_;
		_tmp1_ = _g_object_ref0 (INITIATE_MESSAGE (message));
		i = _tmp1_;
		_tmp2_ = initiate_message_get_reply (i);
		if (!_tmp2_) {
			guint32 _tmp3_;
			guint32 _tmp4_;
			guint32 _tmp5_;
			gboolean _tmp6_;
			gboolean accepted;
			InitiateMessage* _tmp7_ = NULL;
			InitiateMessage* _tmp8_;
			_tmp3_ = initiate_message_get_major (i);
			_tmp4_ = initiate_message_get_minor (i);
			_tmp5_ = initiate_message_get_revision (i);
			_tmp6_ = environment_is_compatible (_tmp3_, _tmp4_, _tmp5_);
			accepted = _tmp6_;
			_tmp7_ = initiate_message_new_initiate_reply (accepted, "");
			_tmp8_ = _tmp7_;
			connection_send (connection, (Message*) _tmp8_);
			_g_object_unref0 (_tmp8_);
			if (!accepted) {
				connection_close (connection);
			}
		} else {
			gboolean _tmp9_;
			_tmp9_ = initiate_message_get_accepted (i);
			if (!_tmp9_) {
				connection_close (connection);
			} else {
				guint32 _tmp10_;
				const gchar* _tmp11_ = NULL;
				GameConnection* _tmp12_ = NULL;
				GameConnection* g;
				guint32 _tmp13_;
				const gchar* _tmp14_ = NULL;
				PlayerConnectedMessage* _tmp15_ = NULL;
				PlayerConnectedMessage* msg;
				GameConnection* _tmp21_;
				guint _tmp22_;
				_tmp10_ = self->priv->connection_id;
				self->priv->connection_id = _tmp10_ + 1;
				_tmp11_ = initiate_message_get_name (i);
				_tmp12_ = game_connection_new (connection, _tmp10_, _tmp11_);
				g = _tmp12_;
				_tmp13_ = game_connection_get_id (g);
				_tmp14_ = game_connection_get_name (g);
				_tmp15_ = player_connected_message_new_message (_tmp13_, _tmp14_, FALSE);
				msg = _tmp15_;
				connection_send (connection, (Message*) msg);
				{
					GList* gc_collection;
					GList* gc_it;
					gc_collection = self->priv->_players;
					for (gc_it = gc_collection; gc_it != NULL; gc_it = gc_it->next) {
						GameConnection* _tmp16_;
						GameConnection* gc;
						_tmp16_ = _game_connection_ref0 ((GameConnection*) gc_it->data);
						gc = _tmp16_;
						{
							guint32 _tmp17_;
							const gchar* _tmp18_ = NULL;
							PlayerConnectedMessage* _tmp19_ = NULL;
							PlayerConnectedMessage* _tmp20_;
							_tmp17_ = game_connection_get_id (gc);
							_tmp18_ = game_connection_get_name (gc);
							_tmp19_ = player_connected_message_new_message (_tmp17_, _tmp18_, TRUE);
							_tmp20_ = _tmp19_;
							connection_send (connection, (Message*) _tmp20_);
							_g_object_unref0 (_tmp20_);
							_game_connection_unref0 (gc);
						}
					}
				}
				game_networking_send_to_all (self, (GameMessage*) msg);
				_tmp21_ = _game_connection_ref0 (g);
				self->priv->_players = g_list_append (self->priv->_players, _tmp21_);
				_tmp22_ = g_list_length (self->priv->_players);
				if (_tmp22_ == 2) {
					GRand* _tmp23_ = NULL;
					GRand* rnd;
					guint8* _tmp24_ = NULL;
					guint8* tiles;
					gint tiles_length1;
					gint _tiles_size_;
					gint32 _tmp28_;
					guint8 wall_split;
					_tmp23_ = g_rand_new ();
					rnd = _tmp23_;
					_tmp24_ = g_new0 (guint8, 136);
					tiles = _tmp24_;
					tiles_length1 = 136;
					_tiles_size_ = 136;
					{
						guint8 j;
						j = (guint8) 0;
						{
							gboolean _tmp25_;
							_tmp25_ = TRUE;
							while (TRUE) {
								if (!_tmp25_) {
									j++;
								}
								_tmp25_ = FALSE;
								if (!(j < tiles_length1)) {
									break;
								}
								tiles[j] = j;
							}
						}
					}
					{
						guint8 j;
						j = (guint8) 0;
						{
							gboolean _tmp26_;
							_tmp26_ = TRUE;
							while (TRUE) {
								gint32 _tmp27_;
								gint r;
								guint8 t;
								if (!_tmp26_) {
									j++;
								}
								_tmp26_ = FALSE;
								if (!(j < tiles_length1)) {
									break;
								}
								_tmp27_ = g_rand_int_range (rnd, (gint32) 0, (gint32) (tiles_length1 - 1));
								r = (gint) _tmp27_;
								t = tiles[r];
								tiles[r] = tiles[j];
								tiles[j] = t;
							}
						}
					}
					_tmp28_ = g_rand_int_range (rnd, (gint32) 2, (gint32) 12);
					wall_split = (guint8) _tmp28_;
					{
						gint j;
						j = 0;
						{
							gboolean _tmp29_;
							_tmp29_ = TRUE;
							while (TRUE) {
								guint _tmp30_;
								gconstpointer _tmp31_ = NULL;
								Connection* _tmp32_ = NULL;
								GameStartMessage* _tmp33_ = NULL;
								GameStartMessage* _tmp34_;
								if (!_tmp29_) {
									j++;
								}
								_tmp29_ = FALSE;
								_tmp30_ = g_list_length (self->priv->_players);
								if (!(j < _tmp30_)) {
									break;
								}
								_tmp31_ = g_list_nth_data (self->priv->_players, (guint) j);
								_tmp32_ = game_connection_get_connection ((GameConnection*) _tmp31_);
								_tmp33_ = game_start_message_new_message ((guint8) 0, tiles, tiles_length1, wall_split, (guint8) j);
								_tmp34_ = _tmp33_;
								connection_send (_tmp32_, (Message*) _tmp34_);
								_g_object_unref0 (_tmp34_);
							}
						}
					}
					tiles = (g_free (tiles), NULL);
					_g_rand_free0 (rnd);
				}
				_g_object_unref0 (msg);
				_game_connection_unref0 (g);
			}
		}
		_g_object_unref0 (i);
	} else {
		g_print ("IsClientMessage\n");
		{
			GList* gc_collection;
			GList* gc_it;
			gc_collection = self->priv->_players;
			for (gc_it = gc_collection; gc_it != NULL; gc_it = gc_it->next) {
				GameConnection* _tmp35_;
				GameConnection* gc;
				_tmp35_ = _game_connection_ref0 ((GameConnection*) gc_it->data);
				gc = _tmp35_;
				{
					Connection* _tmp36_ = NULL;
					_tmp36_ = game_connection_get_connection (gc);
					if (connection == _tmp36_) {
						guint32 _tmp37_;
						guint32 _tmp38_;
						_tmp37_ = player_message_get_id (PLAYER_MESSAGE (message));
						_tmp38_ = game_connection_get_id (gc);
						if (_tmp37_ == _tmp38_) {
							guint32 _tmp39_;
							guint8* _tmp40_ = NULL;
							gint _tmp41_;
							_tmp39_ = game_connection_get_id (gc);
							_tmp40_ = message_get_data ((Message*) message, &_tmp41_);
							g_print ("ID: %d\nMsg len: %d\n", (gint) _tmp39_, _tmp41_);
							game_networking_send_to_all (self, message);
						}
						_game_connection_unref0 (gc);
						return;
					}
					_game_connection_unref0 (gc);
				}
			}
		}
	}
}


static void game_networking_send_to_all (GameNetworking* self, GameMessage* message) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	g_print ("Spreading message\n");
	{
		GList* gc_collection;
		GList* gc_it;
		gc_collection = self->priv->_players;
		for (gc_it = gc_collection; gc_it != NULL; gc_it = gc_it->next) {
			GameConnection* _tmp0_;
			GameConnection* gc;
			_tmp0_ = _game_connection_ref0 ((GameConnection*) gc_it->data);
			gc = _tmp0_;
			{
				Connection* _tmp1_ = NULL;
				_tmp1_ = game_connection_get_connection (gc);
				connection_send (_tmp1_, (Message*) message);
				_game_connection_unref0 (gc);
			}
		}
	}
}


static void game_networking_client_received (GameNetworking* self, Connection* connection, GameMessage* message) {
	GType _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (connection != NULL);
	g_return_if_fail (message != NULL);
	_tmp0_ = G_TYPE_FROM_INSTANCE ((GObject*) message);
	if (_tmp0_ == TYPE_INITIATE_MESSAGE) {
		InitiateMessage* _tmp1_;
		InitiateMessage* i;
		gboolean _tmp2_;
		_tmp1_ = _g_object_ref0 (INITIATE_MESSAGE (message));
		i = _tmp1_;
		_tmp2_ = initiate_message_get_accepted (i);
		if (_tmp2_) {
			guint32 _tmp3_;
			guint32 _tmp4_;
			guint32 _tmp5_;
			gboolean _tmp6_;
			gboolean accepted;
			InitiateMessage* _tmp7_ = NULL;
			InitiateMessage* _tmp8_;
			_tmp3_ = initiate_message_get_major (i);
			_tmp4_ = initiate_message_get_minor (i);
			_tmp5_ = initiate_message_get_revision (i);
			_tmp6_ = environment_is_compatible (_tmp3_, _tmp4_, _tmp5_);
			accepted = _tmp6_;
			_tmp7_ = initiate_message_new_initiate_reply (accepted, "Human-I");
			_tmp8_ = _tmp7_;
			connection_send (connection, (Message*) _tmp8_);
			_g_object_unref0 (_tmp8_);
			if (!accepted) {
				connection_close (connection);
			}
		}
		_g_object_unref0 (i);
	} else {
		GType _tmp9_;
		_tmp9_ = G_TYPE_FROM_INSTANCE ((GObject*) message);
		if (_tmp9_ == TYPE_PLAYER_CONNECTED_MESSAGE) {
			PlayerConnectedMessage* _tmp10_;
			PlayerConnectedMessage* msg;
			guint32 _tmp11_;
			const gchar* _tmp12_ = NULL;
			GameConnection* _tmp13_ = NULL;
			GameConnection* gc;
			GameConnection* _tmp14_;
			guint32 _tmp15_;
			_tmp10_ = _g_object_ref0 (PLAYER_CONNECTED_MESSAGE (message));
			msg = _tmp10_;
			_tmp11_ = player_connected_message_get_id (msg);
			_tmp12_ = player_connected_message_get_name (msg);
			_tmp13_ = game_connection_new (connection, _tmp11_, _tmp12_);
			gc = _tmp13_;
			_tmp14_ = _game_connection_ref0 (gc);
			self->priv->_players = g_list_append (self->priv->_players, _tmp14_);
			_tmp15_ = player_connected_message_get_id (msg);
			g_print ("Added player to list with id: %d\n", (gint) _tmp15_);
			_game_connection_unref0 (gc);
			_g_object_unref0 (msg);
		} else {
			GType _tmp16_;
			_tmp16_ = G_TYPE_FROM_INSTANCE ((GObject*) message);
			if (_tmp16_ == TYPE_GAME_START_MESSAGE) {
				GameStartMessage* _tmp17_;
				GameStartMessage* msg;
				_tmp17_ = _g_object_ref0 (GAME_START_MESSAGE (message));
				msg = _tmp17_;
				g_signal_emit_by_name (self, "game-start", msg);
				_g_object_unref0 (msg);
			} else {
				PlayerMessage* _tmp18_;
				PlayerMessage* msg;
				guint32 _tmp19_;
				_tmp18_ = _g_object_ref0 (PLAYER_MESSAGE (message));
				msg = _tmp18_;
				_tmp19_ = player_message_get_id (msg);
				g_print ("Got player message with id: %d", (gint) _tmp19_);
				{
					GList* gc_collection;
					GList* gc_it;
					gc_collection = self->priv->_players;
					for (gc_it = gc_collection; gc_it != NULL; gc_it = gc_it->next) {
						GameConnection* _tmp20_;
						GameConnection* gc;
						_tmp20_ = _game_connection_ref0 ((GameConnection*) gc_it->data);
						gc = _tmp20_;
						{
							guint32 _tmp21_;
							guint32 _tmp22_;
							_tmp21_ = player_message_get_id (msg);
							_tmp22_ = game_connection_get_id (gc);
							if (_tmp21_ == _tmp22_) {
								game_connection_message_received (gc, message);
								_game_connection_unref0 (gc);
								_g_object_unref0 (msg);
								return;
							}
							_game_connection_unref0 (gc);
						}
					}
				}
				_g_object_unref0 (msg);
			}
		}
	}
}


gboolean game_networking_host (GameNetworking* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->hosting) {
		result = FALSE;
		return result;
	}
	_tmp0_ = networking_host (GAME_NETWORKING_PORT);
	if (_tmp0_) {
		self->priv->hosting = TRUE;
		self->priv->connection_id = (guint32) 1;
	}
	result = self->priv->hosting;
	return result;
}


gboolean game_networking_join (GameNetworking* self, const gchar* address) {
	gboolean result = FALSE;
	Connection* _tmp0_ = NULL;
	Connection* connection;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (address != NULL, FALSE);
	if (self->priv->hosting) {
		result = FALSE;
		return result;
	}
	_tmp0_ = networking_join (address, GAME_NETWORKING_PORT);
	connection = _tmp0_;
	if (connection != NULL) {
		guint32 _tmp1_;
		guint32 _tmp2_;
		guint32 _tmp3_;
		InitiateMessage* _tmp4_ = NULL;
		InitiateMessage* _tmp5_;
		_tmp1_ = environment_get_version_major ();
		_tmp2_ = environment_get_version_minor ();
		_tmp3_ = environment_get_version_revision ();
		_tmp4_ = initiate_message_new_initiate (_tmp1_, _tmp2_, _tmp3_);
		_tmp5_ = _tmp4_;
		connection_send (connection, (Message*) _tmp5_);
		_g_object_unref0 (_tmp5_);
	}
	result = connection != NULL;
	_g_object_unref0 (connection);
	return result;
}


GList* game_networking_get_players (GameNetworking* self) {
	GList* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_players;
	return result;
}


static void value_game_networking_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_game_networking_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		game_networking_unref (value->data[0].v_pointer);
	}
}


static void value_game_networking_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = game_networking_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_game_networking_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_game_networking_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GameNetworking* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = game_networking_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_game_networking_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GameNetworking** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = game_networking_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_game_networking (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecGameNetworking* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GAME_NETWORKING), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_game_networking (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GAME_NETWORKING), NULL);
	return value->data[0].v_pointer;
}


void value_set_game_networking (GValue* value, gpointer v_object) {
	GameNetworking* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GAME_NETWORKING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GAME_NETWORKING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		game_networking_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		game_networking_unref (old);
	}
}


void value_take_game_networking (GValue* value, gpointer v_object) {
	GameNetworking* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GAME_NETWORKING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GAME_NETWORKING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		game_networking_unref (old);
	}
}


static void game_networking_class_init (GameNetworkingClass * klass) {
	game_networking_parent_class = g_type_class_peek_parent (klass);
	GAME_NETWORKING_CLASS (klass)->finalize = game_networking_finalize;
	g_type_class_add_private (klass, sizeof (GameNetworkingPrivate));
	g_signal_new ("game_start", TYPE_GAME_NETWORKING, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, TYPE_GAME_START_MESSAGE);
}


static void game_networking_instance_init (GameNetworking * self) {
	self->priv = GAME_NETWORKING_GET_PRIVATE (self);
	self->priv->_players = NULL;
	self->priv->hosting = FALSE;
	self->ref_count = 1;
}


static void game_networking_finalize (GameNetworking* obj) {
	GameNetworking * self;
	guint _tmp0_;
	self = GAME_NETWORKING (obj);
	g_signal_parse_name ("message", TYPE_MESSAGE_SIGNAL, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (networking_message_received, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _game_networking_message_received_message_signal_message, self);
	networking_close_connections ();
	__g_list_free__game_connection_unref0_0 (self->priv->_players);
}


GType game_networking_get_type (void) {
	static volatile gsize game_networking_type_id__volatile = 0;
	if (g_once_init_enter (&game_networking_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_game_networking_init, value_game_networking_free_value, value_game_networking_copy_value, value_game_networking_peek_pointer, "p", value_game_networking_collect_value, "p", value_game_networking_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GameNetworkingClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) game_networking_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GameNetworking), 0, (GInstanceInitFunc) game_networking_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType game_networking_type_id;
		game_networking_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GameNetworking", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&game_networking_type_id__volatile, game_networking_type_id);
	}
	return game_networking_type_id__volatile;
}


gpointer game_networking_ref (gpointer instance) {
	GameNetworking* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void game_networking_unref (gpointer instance) {
	GameNetworking* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GAME_NETWORKING_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


GameConnection* game_connection_construct (GType object_type, Connection* connection, guint32 id, const gchar* name) {
	GameConnection* self = NULL;
	g_return_val_if_fail (connection != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	self = (GameConnection*) g_type_create_instance (object_type);
	game_connection_set_connection (self, connection);
	game_connection_set_id (self, id);
	game_connection_set_name (self, name);
	return self;
}


GameConnection* game_connection_new (Connection* connection, guint32 id, const gchar* name) {
	return game_connection_construct (TYPE_GAME_CONNECTION, connection, id, name);
}


void game_connection_message_received (GameConnection* self, GameMessage* message) {
	GType _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	g_print ("Got player message\n");
	_tmp0_ = G_TYPE_FROM_INSTANCE ((GObject*) message);
	if (_tmp0_ == TYPE_CALL_ACTION_MESSAGE) {
		CallAction* _tmp1_ = NULL;
		_tmp1_ = call_action_message_get_call_action (CALL_ACTION_MESSAGE (message));
		g_signal_emit_by_name (self, "call-action", _tmp1_);
	} else {
		GType _tmp2_;
		_tmp2_ = G_TYPE_FROM_INSTANCE ((GObject*) message);
		if (_tmp2_ == TYPE_TURN_ACTION_MESSAGE) {
			TurnAction* _tmp3_ = NULL;
			_tmp3_ = turn_action_message_get_turn_action (TURN_ACTION_MESSAGE (message));
			g_signal_emit_by_name (self, "turn-action", _tmp3_);
		}
	}
}


void game_connection_send_call_action (GameConnection* self, CallAction* action) {
	CallActionMessage* _tmp0_ = NULL;
	CallActionMessage* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = call_action_message_new_message (self->priv->_id, action);
	_tmp1_ = _tmp0_;
	connection_send (self->priv->_connection, (Message*) _tmp1_);
	_g_object_unref0 (_tmp1_);
	g_print ("sent call action\n");
}


void game_connection_send_turn_action (GameConnection* self, TurnAction* action) {
	TurnActionMessage* _tmp0_ = NULL;
	TurnActionMessage* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = turn_action_message_new_message (self->priv->_id, action);
	_tmp1_ = _tmp0_;
	connection_send (self->priv->_connection, (Message*) _tmp1_);
	_g_object_unref0 (_tmp1_);
	g_print ("sent turn action\n");
}


Connection* game_connection_get_connection (GameConnection* self) {
	Connection* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_connection;
	return result;
}


static void game_connection_set_connection (GameConnection* self, Connection* value) {
	Connection* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_g_object_unref0 (self->priv->_connection);
	self->priv->_connection = _tmp0_;
}


guint32 game_connection_get_id (GameConnection* self) {
	guint32 result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_id;
	return result;
}


static void game_connection_set_id (GameConnection* self, guint32 value) {
	g_return_if_fail (self != NULL);
	self->priv->_id = value;
}


const gchar* game_connection_get_name (GameConnection* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_name;
	return result;
}


static void game_connection_set_name (GameConnection* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp0_;
}


static void g_cclosure_user_marshal_VOID__CALL_ACTION (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__CALL_ACTION) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__CALL_ACTION callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__CALL_ACTION) (marshal_data ? marshal_data : cc->callback);
	callback (data1, value_get_call_action (param_values + 1), data2);
}


static void g_cclosure_user_marshal_VOID__TURN_ACTION (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__TURN_ACTION) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__TURN_ACTION callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__TURN_ACTION) (marshal_data ? marshal_data : cc->callback);
	callback (data1, value_get_turn_action (param_values + 1), data2);
}


static void value_game_connection_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_game_connection_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		game_connection_unref (value->data[0].v_pointer);
	}
}


static void value_game_connection_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = game_connection_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_game_connection_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_game_connection_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GameConnection* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = game_connection_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_game_connection_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GameConnection** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = game_connection_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_game_connection (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecGameConnection* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GAME_CONNECTION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_game_connection (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GAME_CONNECTION), NULL);
	return value->data[0].v_pointer;
}


void value_set_game_connection (GValue* value, gpointer v_object) {
	GameConnection* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GAME_CONNECTION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GAME_CONNECTION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		game_connection_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		game_connection_unref (old);
	}
}


void value_take_game_connection (GValue* value, gpointer v_object) {
	GameConnection* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GAME_CONNECTION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GAME_CONNECTION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		game_connection_unref (old);
	}
}


static void game_connection_class_init (GameConnectionClass * klass) {
	game_connection_parent_class = g_type_class_peek_parent (klass);
	GAME_CONNECTION_CLASS (klass)->finalize = game_connection_finalize;
	g_type_class_add_private (klass, sizeof (GameConnectionPrivate));
	g_signal_new ("call_action", TYPE_GAME_CONNECTION, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__CALL_ACTION, G_TYPE_NONE, 1, TYPE_CALL_ACTION);
	g_signal_new ("turn_action", TYPE_GAME_CONNECTION, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__TURN_ACTION, G_TYPE_NONE, 1, TYPE_TURN_ACTION);
}


static void game_connection_instance_init (GameConnection * self) {
	self->priv = GAME_CONNECTION_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void game_connection_finalize (GameConnection* obj) {
	GameConnection * self;
	self = GAME_CONNECTION (obj);
	_g_object_unref0 (self->priv->_connection);
	_g_free0 (self->priv->_name);
}


GType game_connection_get_type (void) {
	static volatile gsize game_connection_type_id__volatile = 0;
	if (g_once_init_enter (&game_connection_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_game_connection_init, value_game_connection_free_value, value_game_connection_copy_value, value_game_connection_peek_pointer, "p", value_game_connection_collect_value, "p", value_game_connection_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GameConnectionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) game_connection_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GameConnection), 0, (GInstanceInitFunc) game_connection_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType game_connection_type_id;
		game_connection_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GameConnection", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&game_connection_type_id__volatile, game_connection_type_id);
	}
	return game_connection_type_id__volatile;
}


gpointer game_connection_ref (gpointer instance) {
	GameConnection* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void game_connection_unref (gpointer instance) {
	GameConnection* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GAME_CONNECTION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



