/* Tile.c generated by valac 0.12.0, the Vala compiler
 * generated from Tile.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <GL/glew.h>
#include <gee.h>


#define TYPE_TILE (tile_get_type ())
#define TILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TILE, Tile))
#define TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TILE, TileClass))
#define IS_TILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TILE))
#define IS_TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TILE))
#define TILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TILE, TileClass))

typedef struct _Tile Tile;
typedef struct _TileClass TileClass;
typedef struct _TilePrivate TilePrivate;

#define TYPE_TEXTURE (texture_get_type ())
#define TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TEXTURE, Texture))
#define TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TEXTURE, TextureClass))
#define IS_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TEXTURE))
#define IS_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TEXTURE))
#define TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TEXTURE, TextureClass))

typedef struct _Texture Texture;
typedef struct _TextureClass TextureClass;

#define TYPE_VECTOR (vector_get_type ())
#define VECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VECTOR, Vector))
#define VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VECTOR, VectorClass))
#define IS_VECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VECTOR))
#define IS_VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VECTOR))
#define VECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VECTOR, VectorClass))

typedef struct _Vector Vector;
typedef struct _VectorClass VectorClass;
#define _texture_unref0(var) ((var == NULL) ? NULL : (var = (texture_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vector_unref0(var) ((var == NULL) ? NULL : (var = (vector_unref (var), NULL)))

#define TYPE_TILE_TYPE (tile_type_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _Tile {
	GObject parent_instance;
	TilePrivate * priv;
};

struct _TileClass {
	GObjectClass parent_class;
};

struct _TilePrivate {
	Texture* tile_texture;
	gchar* _name;
	Vector* _position;
	Vector* _rotation;
	guint _color_ID;
	gboolean _hovering;
	gfloat _size;
	gint _tile_type;
	gint _id;
};

typedef enum  {
	TILE_TYPE_MAN1 = 0,
	TILE_TYPE_MAN2,
	TILE_TYPE_MAN3,
	TILE_TYPE_MAN4,
	TILE_TYPE_MAN5,
	TILE_TYPE_MAN6,
	TILE_TYPE_MAN7,
	TILE_TYPE_MAN8,
	TILE_TYPE_MAN9,
	TILE_TYPE_PIN1,
	TILE_TYPE_PIN2,
	TILE_TYPE_PIN3,
	TILE_TYPE_PIN4,
	TILE_TYPE_PIN5,
	TILE_TYPE_PIN6,
	TILE_TYPE_PIN7,
	TILE_TYPE_PIN8,
	TILE_TYPE_PIN9,
	TILE_TYPE_SOU1,
	TILE_TYPE_SOU2,
	TILE_TYPE_SOU3,
	TILE_TYPE_SOU4,
	TILE_TYPE_SOU5,
	TILE_TYPE_SOU6,
	TILE_TYPE_SOU7,
	TILE_TYPE_SOU8,
	TILE_TYPE_SOU9,
	TILE_TYPE_HIGASHI,
	TILE_TYPE_MINAMI,
	TILE_TYPE_NISHI,
	TILE_TYPE_KITA,
	TILE_TYPE_HATSU,
	TILE_TYPE_HAKU,
	TILE_TYPE_CHUN
} TILE_TYPE;


static gpointer tile_parent_class = NULL;

GType tile_get_type (void) G_GNUC_CONST;
gpointer texture_ref (gpointer instance);
void texture_unref (gpointer instance);
GParamSpec* param_spec_texture (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_texture (GValue* value, gpointer v_object);
void value_take_texture (GValue* value, gpointer v_object);
gpointer value_get_texture (const GValue* value);
GType texture_get_type (void) G_GNUC_CONST;
gpointer vector_ref (gpointer instance);
void vector_unref (gpointer instance);
GParamSpec* param_spec_vector (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_vector (GValue* value, gpointer v_object);
void value_take_vector (GValue* value, gpointer v_object);
gpointer value_get_vector (const GValue* value);
GType vector_get_type (void) G_GNUC_CONST;
#define TILE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TILE, TilePrivate))
enum  {
	TILE_DUMMY_PROPERTY,
	TILE_NAME,
	TILE_POSITION,
	TILE_ROTATION,
	TILE_COLOR_ID,
	TILE_HOVERING,
	TILE_SIZE,
	TILE_TILE_TYPE,
	TILE_ID
};
#define TILE_tile_size 0.1f
#define TILE_TILE_WIDTH (1.94f * TILE_tile_size)
#define TILE_TILE_HEIGHT (2.6f * TILE_tile_size)
#define TILE_TILE_LENGTH (1.59f * TILE_tile_size)
#define TILE_TILE_SPACING 0.005f
#define TILE_HOVER_MULT 2.5f
#define TILE_HOVER_ADD (1 - (1 / (((TILE_HOVER_MULT - 1) / 3) + 1)))
#define TILE_CUBE_NONE 0
#define TILE_CUBE_TOP 1
#define TILE_CUBE_BOTTOM 2
#define TILE_CUBE_LEFT 4
#define TILE_CUBE_RIGHT 8
#define TILE_CUBE_FRONT 16
#define TILE_CUBE_BACK 32
#define TILE_CUBE_ALL 63
Tile* tile_new (gfloat size, gint id, gint type);
Tile* tile_construct (GType object_type, gfloat size, gint id, gint type);
static void tile_set_size (Tile* self, gfloat value);
static void tile_set_tile_type (Tile* self, gint value);
static void tile_set_id (Tile* self, gint value);
Vector* vector_new_empty (void);
Vector* vector_construct_empty (GType object_type);
void tile_set_position (Tile* self, Vector* value);
void tile_set_rotation (Tile* self, Vector* value);
GType tile_type_get_type (void) G_GNUC_CONST;
static void tile_set_name (Tile* self, const gchar* value);
Texture* texture_load_texture (const gchar* name);
static void tile_renderSide (Tile* self, gfloat size);
static void tile_renderPartialCube (Tile* self, gfloat size, gint cubePart);
static void tile_renderBackBox (Tile* self);
gfloat tile_get_size (Tile* self);
static void tile_renderFrontBox (Tile* self, gboolean front);
static void tile_renderFront (Tile* self);
GLuint texture_get_texture (Texture* self);
gboolean tile_get_hovering (Tile* self);
void tile_render (Tile* self);
Vector* tile_get_position (Tile* self);
gfloat vector_get_x (Vector* self);
gfloat vector_get_y (Vector* self);
gfloat vector_get_z (Vector* self);
Vector* tile_get_rotation (Tile* self);
void tile_render_selection (Tile* self);
guint tile_get_color_ID (Tile* self);
void tile_sort_tiles (GeeArrayList* tiles);
gint tile_get_tile_type (Tile* self);
const gchar* tile_get_name (Tile* self);
void tile_set_color_ID (Tile* self, guint value);
void tile_set_hovering (Tile* self, gboolean value);
gint tile_get_id (Tile* self);
static void tile_finalize (GObject* obj);
static void _vala_tile_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_tile_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


Tile* tile_construct (GType object_type, gfloat size, gint id, gint type) {
	Tile * self = NULL;
	Vector* _tmp0_ = NULL;
	Vector* _tmp1_;
	Vector* _tmp2_ = NULL;
	Vector* _tmp3_;
	gchar* name = NULL;
	gchar* _tmp21_;
	gchar* _tmp22_;
	Texture* _tmp23_ = NULL;
	self = (Tile*) g_object_new (object_type, NULL);
	tile_set_size (self, size / 2);
	tile_set_tile_type (self, type);
	tile_set_id (self, id);
	_tmp0_ = vector_new_empty ();
	_tmp1_ = _tmp0_;
	tile_set_position (self, _tmp1_);
	_vector_unref0 (_tmp1_);
	_tmp2_ = vector_new_empty ();
	_tmp3_ = _tmp2_;
	tile_set_rotation (self, _tmp3_);
	_vector_unref0 (_tmp3_);
	if (type <= TILE_TYPE_MAN9) {
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp4_ = g_strdup_printf ("%i", type + 1);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_strconcat ("Man", _tmp5_, NULL);
		_g_free0 (name);
		name = _tmp6_;
		_g_free0 (_tmp5_);
	} else {
		if (type <= TILE_TYPE_PIN9) {
			gchar* _tmp7_ = NULL;
			gchar* _tmp8_;
			gchar* _tmp9_;
			_tmp7_ = g_strdup_printf ("%i", (type % 9) + 1);
			_tmp8_ = _tmp7_;
			_tmp9_ = g_strconcat ("Pin", _tmp8_, NULL);
			_g_free0 (name);
			name = _tmp9_;
			_g_free0 (_tmp8_);
		} else {
			if (type <= TILE_TYPE_SOU9) {
				gchar* _tmp10_ = NULL;
				gchar* _tmp11_;
				gchar* _tmp12_;
				_tmp10_ = g_strdup_printf ("%i", (type % 9) + 1);
				_tmp11_ = _tmp10_;
				_tmp12_ = g_strconcat ("Sou", _tmp11_, NULL);
				_g_free0 (name);
				name = _tmp12_;
				_g_free0 (_tmp11_);
			} else {
				if (type == TILE_TYPE_HIGASHI) {
					gchar* _tmp13_;
					_tmp13_ = g_strdup ("Higashi");
					_g_free0 (name);
					name = _tmp13_;
				} else {
					if (type == TILE_TYPE_MINAMI) {
						gchar* _tmp14_;
						_tmp14_ = g_strdup ("Minami");
						_g_free0 (name);
						name = _tmp14_;
					} else {
						if (type == TILE_TYPE_NISHI) {
							gchar* _tmp15_;
							_tmp15_ = g_strdup ("Nishi");
							_g_free0 (name);
							name = _tmp15_;
						} else {
							if (type == TILE_TYPE_KITA) {
								gchar* _tmp16_;
								_tmp16_ = g_strdup ("Kita");
								_g_free0 (name);
								name = _tmp16_;
							} else {
								if (type == TILE_TYPE_HAKU) {
									gchar* _tmp17_;
									_tmp17_ = g_strdup ("Haku");
									_g_free0 (name);
									name = _tmp17_;
								} else {
									if (type == TILE_TYPE_HATSU) {
										gchar* _tmp18_;
										_tmp18_ = g_strdup ("Hatsu");
										_g_free0 (name);
										name = _tmp18_;
									} else {
										if (type == TILE_TYPE_CHUN) {
											gchar* _tmp19_;
											_tmp19_ = g_strdup ("Chun");
											_g_free0 (name);
											name = _tmp19_;
										} else {
											gchar* _tmp20_;
											_tmp20_ = g_strdup ("");
											_g_free0 (name);
											name = _tmp20_;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	tile_set_name (self, name);
	_tmp21_ = g_strconcat ("tiles/", name, NULL);
	_tmp22_ = _tmp21_;
	_tmp23_ = texture_load_texture (_tmp22_);
	_texture_unref0 (self->priv->tile_texture);
	self->priv->tile_texture = _tmp23_;
	_g_free0 (_tmp22_);
	_g_free0 (name);
	return self;
}


Tile* tile_new (gfloat size, gint id, gint type) {
	return tile_construct (TYPE_TILE, size, id, type);
}


static void tile_renderSide (Tile* self, gfloat size) {
	g_return_if_fail (self != NULL);
	glBegin ((GLenum) GL_QUADS);
	glVertex3f (-((GLfloat) size), -((GLfloat) size), -((GLfloat) size));
	glVertex3f (-((GLfloat) size), (GLfloat) size, -((GLfloat) size));
	glVertex3f ((GLfloat) size, (GLfloat) size, -((GLfloat) size));
	glVertex3f ((GLfloat) size, -((GLfloat) size), -((GLfloat) size));
	glEnd ();
}


static void tile_renderPartialCube (Tile* self, gfloat size, gint cubePart) {
	g_return_if_fail (self != NULL);
	size = size / ((gfloat) 2);
	if ((cubePart & TILE_CUBE_BACK) != 0) {
		glPushMatrix ();
		tile_renderSide (self, size);
		glPopMatrix ();
	}
	if ((cubePart & TILE_CUBE_FRONT) != 0) {
		glPushMatrix ();
		glRotatef ((GLfloat) 180, (GLfloat) 1, (GLfloat) 0, (GLfloat) 0);
		tile_renderSide (self, size);
		glPopMatrix ();
	}
	if ((cubePart & TILE_CUBE_TOP) != 0) {
		glPushMatrix ();
		glRotatef ((GLfloat) 90, (GLfloat) 1, (GLfloat) 0, (GLfloat) 0);
		tile_renderSide (self, size);
		glPopMatrix ();
	}
	if ((cubePart & TILE_CUBE_BOTTOM) != 0) {
		glPushMatrix ();
		glRotatef ((GLfloat) (-90), (GLfloat) 1, (GLfloat) 0, (GLfloat) 0);
		tile_renderSide (self, size);
		glPopMatrix ();
	}
	if ((cubePart & TILE_CUBE_LEFT) != 0) {
		glPushMatrix ();
		glRotatef ((GLfloat) 90, (GLfloat) 0, (GLfloat) 1, (GLfloat) 0);
		tile_renderSide (self, size);
		glPopMatrix ();
	}
	if ((cubePart & TILE_CUBE_RIGHT) != 0) {
		glPushMatrix ();
		glRotatef ((GLfloat) (-90), (GLfloat) 0, (GLfloat) 1, (GLfloat) 0);
		tile_renderSide (self, size);
		glPopMatrix ();
	}
}


static void tile_renderBackBox (Tile* self) {
	g_return_if_fail (self != NULL);
	glPushMatrix ();
	glTranslatef ((GLfloat) 0, (GLfloat) 0, (GLfloat) (self->priv->_size * 0.2));
	glScalef ((GLfloat) 1, (GLfloat) 1, (GLfloat) 0.2);
	tile_renderPartialCube (self, self->priv->_size * 2, TILE_CUBE_ALL & (~TILE_CUBE_FRONT));
	glPopMatrix ();
}


static void tile_renderFrontBox (Tile* self, gboolean front) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	glScalef ((GLfloat) 1, (GLfloat) 1, (GLfloat) 0.8);
	glTranslatef ((GLfloat) 0, (GLfloat) 0, (GLfloat) (self->priv->_size * 1.5));
	if (front) {
		_tmp0_ = 0;
	} else {
		_tmp0_ = TILE_CUBE_FRONT;
	}
	tile_renderPartialCube (self, self->priv->_size * 2, (TILE_CUBE_ALL & (~_tmp0_)) & (~TILE_CUBE_BACK));
}


static void tile_renderFront (Tile* self) {
	GLuint _tmp0_;
	gfloat _tmp1_ = 0.0F;
	gfloat add;
	g_return_if_fail (self != NULL);
	glTranslatef ((GLfloat) 0, (GLfloat) 0, (GLfloat) self->priv->_size);
	glEnable ((GLenum) GL_TEXTURE_2D);
	_tmp0_ = texture_get_texture (self->priv->tile_texture);
	glBindTexture ((GLenum) GL_TEXTURE_2D, _tmp0_);
	glDisable ((GLenum) GL_LIGHTING);
	glEnable ((GLenum) GL_COLOR_SUM);
	if (self->priv->_hovering) {
		_tmp1_ = TILE_HOVER_ADD;
	} else {
		_tmp1_ = (gfloat) 0;
	}
	add = _tmp1_;
	glSecondaryColor3f ((GLfloat) add, (GLfloat) add, (GLfloat) add);
	glTexParameteri ((GLenum) GL_TEXTURE_2D, (GLenum) GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
	glTexParameteri ((GLenum) GL_TEXTURE_2D, (GLenum) GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
	glBegin ((GLenum) GL_QUADS);
	glTexCoord2f ((GLfloat) 0, (GLfloat) 1);
	glVertex3f (-((GLfloat) self->priv->_size), -((GLfloat) self->priv->_size), (GLfloat) 0);
	glTexCoord2f ((GLfloat) 1, (GLfloat) 1);
	glVertex3f ((GLfloat) self->priv->_size, -((GLfloat) self->priv->_size), (GLfloat) 0);
	glTexCoord2f ((GLfloat) 1, (GLfloat) 0);
	glVertex3f ((GLfloat) self->priv->_size, (GLfloat) self->priv->_size, (GLfloat) 0);
	glTexCoord2f ((GLfloat) 0, (GLfloat) 0);
	glVertex3f (-((GLfloat) self->priv->_size), (GLfloat) self->priv->_size, (GLfloat) 0);
	glEnd ();
	glDisable ((GLenum) GL_COLOR_SUM);
	glEnable ((GLenum) GL_LIGHTING);
	glDisable ((GLenum) GL_TEXTURE_2D);
}


void tile_render (Tile* self) {
	gfloat _tmp0_ = 0.0F;
	gfloat colorMult;
	gfloat _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	gfloat _tmp4_;
	gfloat _tmp5_;
	gfloat _tmp6_;
	g_return_if_fail (self != NULL);
	if (self->priv->_hovering) {
		_tmp0_ = TILE_HOVER_MULT;
	} else {
		_tmp0_ = (gfloat) 1;
	}
	colorMult = _tmp0_;
	glPushMatrix ();
	_tmp1_ = vector_get_x (self->priv->_position);
	_tmp2_ = vector_get_y (self->priv->_position);
	_tmp3_ = vector_get_z (self->priv->_position);
	glTranslatef ((GLfloat) _tmp1_, (GLfloat) _tmp2_, (GLfloat) _tmp3_);
	_tmp4_ = vector_get_x (self->priv->_rotation);
	glRotatef ((GLfloat) (_tmp4_ / 1.0f), (GLfloat) 1, (GLfloat) 0, (GLfloat) 0);
	_tmp5_ = vector_get_y (self->priv->_rotation);
	glRotatef ((GLfloat) (_tmp5_ / 1.0f), (GLfloat) 0, (GLfloat) 1, (GLfloat) 0);
	_tmp6_ = vector_get_z (self->priv->_rotation);
	glRotatef ((GLfloat) (_tmp6_ / 1.0f), (GLfloat) 0, (GLfloat) 0, (GLfloat) 1);
	glTranslatef ((GLfloat) 0, ((GLfloat) TILE_TILE_HEIGHT) / 2, (GLfloat) 0);
	glScalef ((GLfloat) TILE_TILE_WIDTH, (GLfloat) TILE_TILE_HEIGHT, (GLfloat) TILE_TILE_LENGTH);
	glColor3f ((GLfloat) (1 * colorMult), (GLfloat) (0.8 * colorMult), (GLfloat) (0.2 * colorMult));
	tile_renderBackBox (self);
	glColor3f ((GLfloat) ((245 / 255.0) * colorMult), (GLfloat) ((245 / 255.0) * colorMult), (GLfloat) ((233 / 255.0) * colorMult));
	tile_renderFrontBox (self, FALSE);
	glColor3f (((GLfloat) colorMult) + 2, ((GLfloat) colorMult) + 2, ((GLfloat) colorMult) + 2);
	tile_renderFront (self);
	glPopMatrix ();
}


void tile_render_selection (Tile* self) {
	guint r;
	guint g;
	guint b;
	gfloat _tmp0_;
	gfloat _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	gfloat _tmp4_;
	gfloat _tmp5_;
	g_return_if_fail (self != NULL);
	r = (self->priv->_color_ID >> 16) % 256;
	g = (self->priv->_color_ID >> 8) % 256;
	b = self->priv->_color_ID % 256;
	glDisable ((GLenum) GL_LIGHTING);
	glPushMatrix ();
	_tmp0_ = vector_get_x (self->priv->_position);
	_tmp1_ = vector_get_y (self->priv->_position);
	_tmp2_ = vector_get_z (self->priv->_position);
	glTranslatef ((GLfloat) _tmp0_, (GLfloat) _tmp1_, (GLfloat) _tmp2_);
	_tmp3_ = vector_get_x (self->priv->_rotation);
	glRotatef ((GLfloat) (_tmp3_ / 1.0f), (GLfloat) 1, (GLfloat) 0, (GLfloat) 0);
	_tmp4_ = vector_get_y (self->priv->_rotation);
	glRotatef ((GLfloat) (_tmp4_ / 1.0f), (GLfloat) 0, (GLfloat) 1, (GLfloat) 0);
	_tmp5_ = vector_get_z (self->priv->_rotation);
	glRotatef ((GLfloat) (_tmp5_ / 1.0f), (GLfloat) 0, (GLfloat) 0, (GLfloat) 1);
	glTranslatef ((GLfloat) 0, ((GLfloat) TILE_TILE_HEIGHT) / 2, (GLfloat) 0);
	glScalef ((GLfloat) TILE_TILE_WIDTH, (GLfloat) TILE_TILE_HEIGHT, (GLfloat) TILE_TILE_LENGTH);
	glColor3f ((GLfloat) (r / 255.0f), (GLfloat) (g / 255.0f), (GLfloat) (b / 255.0f));
	tile_renderBackBox (self);
	tile_renderFrontBox (self, TRUE);
	glPopMatrix ();
	glEnable ((GLenum) GL_LIGHTING);
}


void tile_sort_tiles (GeeArrayList* tiles) {
	g_return_if_fail (tiles != NULL);
	while (TRUE) {
		gboolean sorted;
		sorted = TRUE;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp0_;
				_tmp0_ = TRUE;
				while (TRUE) {
					gint _tmp1_;
					gpointer _tmp2_ = NULL;
					Tile* _tmp3_;
					gpointer _tmp4_ = NULL;
					Tile* _tmp5_;
					gboolean _tmp6_;
					if (!_tmp0_) {
						i++;
					}
					_tmp0_ = FALSE;
					_tmp1_ = gee_collection_get_size ((GeeCollection*) tiles);
					if (!(i < (_tmp1_ - 1))) {
						break;
					}
					_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) tiles, i);
					_tmp3_ = (Tile*) _tmp2_;
					_tmp4_ = gee_abstract_list_get ((GeeAbstractList*) tiles, i + 1);
					_tmp5_ = (Tile*) _tmp4_;
					_tmp6_ = _tmp3_->priv->_tile_type > _tmp5_->priv->_tile_type;
					_g_object_unref0 (_tmp5_);
					_g_object_unref0 (_tmp3_);
					if (_tmp6_) {
						gpointer _tmp7_ = NULL;
						Tile* t;
						gpointer _tmp8_ = NULL;
						Tile* _tmp9_;
						_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) tiles, i);
						t = (Tile*) _tmp7_;
						_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) tiles, i + 1);
						_tmp9_ = (Tile*) _tmp8_;
						gee_abstract_list_set ((GeeAbstractList*) tiles, i, _tmp9_);
						_g_object_unref0 (_tmp9_);
						gee_abstract_list_set ((GeeAbstractList*) tiles, i + 1, t);
						sorted = FALSE;
						_g_object_unref0 (t);
					}
				}
			}
		}
		if (sorted) {
			break;
		}
	}
}


const gchar* tile_get_name (Tile* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_name;
	return result;
}


static void tile_set_name (Tile* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp0_;
	g_object_notify ((GObject *) self, "name");
}


Vector* tile_get_position (Tile* self) {
	Vector* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_position;
	return result;
}


static gpointer _vector_ref0 (gpointer self) {
	return self ? vector_ref (self) : NULL;
}


void tile_set_position (Tile* self, Vector* value) {
	Vector* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _vector_ref0 (value);
	_vector_unref0 (self->priv->_position);
	self->priv->_position = _tmp0_;
	g_object_notify ((GObject *) self, "position");
}


Vector* tile_get_rotation (Tile* self) {
	Vector* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_rotation;
	return result;
}


void tile_set_rotation (Tile* self, Vector* value) {
	Vector* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _vector_ref0 (value);
	_vector_unref0 (self->priv->_rotation);
	self->priv->_rotation = _tmp0_;
	g_object_notify ((GObject *) self, "rotation");
}


guint tile_get_color_ID (Tile* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_color_ID;
	return result;
}


void tile_set_color_ID (Tile* self, guint value) {
	g_return_if_fail (self != NULL);
	self->priv->_color_ID = value;
	g_object_notify ((GObject *) self, "color-ID");
}


gboolean tile_get_hovering (Tile* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_hovering;
	return result;
}


void tile_set_hovering (Tile* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_hovering = value;
	g_object_notify ((GObject *) self, "hovering");
}


gfloat tile_get_size (Tile* self) {
	gfloat result;
	g_return_val_if_fail (self != NULL, 0.0F);
	result = self->priv->_size;
	return result;
}


static void tile_set_size (Tile* self, gfloat value) {
	g_return_if_fail (self != NULL);
	self->priv->_size = value;
	g_object_notify ((GObject *) self, "size");
}


gint tile_get_tile_type (Tile* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_tile_type;
	return result;
}


static void tile_set_tile_type (Tile* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_tile_type = value;
	g_object_notify ((GObject *) self, "tile-type");
}


gint tile_get_id (Tile* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_id;
	return result;
}


static void tile_set_id (Tile* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_id = value;
	g_object_notify ((GObject *) self, "id");
}


static void tile_class_init (TileClass * klass) {
	tile_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TilePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_tile_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_tile_set_property;
	G_OBJECT_CLASS (klass)->finalize = tile_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), TILE_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TILE_POSITION, param_spec_vector ("position", "position", "position", TYPE_VECTOR, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TILE_ROTATION, param_spec_vector ("rotation", "rotation", "rotation", TYPE_VECTOR, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TILE_COLOR_ID, g_param_spec_uint ("color-ID", "color-ID", "color-ID", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TILE_HOVERING, g_param_spec_boolean ("hovering", "hovering", "hovering", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TILE_SIZE, g_param_spec_float ("size", "size", "size", -G_MAXFLOAT, G_MAXFLOAT, 0.0F, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TILE_TILE_TYPE, g_param_spec_int ("tile-type", "tile-type", "tile-type", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TILE_ID, g_param_spec_int ("id", "id", "id", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void tile_instance_init (Tile * self) {
	self->priv = TILE_GET_PRIVATE (self);
}


static void tile_finalize (GObject* obj) {
	Tile * self;
	self = TILE (obj);
	_texture_unref0 (self->priv->tile_texture);
	_g_free0 (self->priv->_name);
	_vector_unref0 (self->priv->_position);
	_vector_unref0 (self->priv->_rotation);
	G_OBJECT_CLASS (tile_parent_class)->finalize (obj);
}


GType tile_get_type (void) {
	static volatile gsize tile_type_id__volatile = 0;
	if (g_once_init_enter (&tile_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) tile_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Tile), 0, (GInstanceInitFunc) tile_instance_init, NULL };
		GType tile_type_id;
		tile_type_id = g_type_register_static (G_TYPE_OBJECT, "Tile", &g_define_type_info, 0);
		g_once_init_leave (&tile_type_id__volatile, tile_type_id);
	}
	return tile_type_id__volatile;
}


static void _vala_tile_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Tile * self;
	self = TILE (object);
	switch (property_id) {
		case TILE_NAME:
		g_value_set_string (value, tile_get_name (self));
		break;
		case TILE_POSITION:
		value_set_vector (value, tile_get_position (self));
		break;
		case TILE_ROTATION:
		value_set_vector (value, tile_get_rotation (self));
		break;
		case TILE_COLOR_ID:
		g_value_set_uint (value, tile_get_color_ID (self));
		break;
		case TILE_HOVERING:
		g_value_set_boolean (value, tile_get_hovering (self));
		break;
		case TILE_SIZE:
		g_value_set_float (value, tile_get_size (self));
		break;
		case TILE_TILE_TYPE:
		g_value_set_int (value, tile_get_tile_type (self));
		break;
		case TILE_ID:
		g_value_set_int (value, tile_get_id (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_tile_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Tile * self;
	self = TILE (object);
	switch (property_id) {
		case TILE_NAME:
		tile_set_name (self, g_value_get_string (value));
		break;
		case TILE_POSITION:
		tile_set_position (self, value_get_vector (value));
		break;
		case TILE_ROTATION:
		tile_set_rotation (self, value_get_vector (value));
		break;
		case TILE_COLOR_ID:
		tile_set_color_ID (self, g_value_get_uint (value));
		break;
		case TILE_HOVERING:
		tile_set_hovering (self, g_value_get_boolean (value));
		break;
		case TILE_SIZE:
		tile_set_size (self, g_value_get_float (value));
		break;
		case TILE_TILE_TYPE:
		tile_set_tile_type (self, g_value_get_int (value));
		break;
		case TILE_ID:
		tile_set_id (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


GType tile_type_get_type (void) {
	static volatile gsize tile_type_type_id__volatile = 0;
	if (g_once_init_enter (&tile_type_type_id__volatile)) {
		static const GEnumValue values[] = {{TILE_TYPE_MAN1, "TILE_TYPE_MAN1", "man1"}, {TILE_TYPE_MAN2, "TILE_TYPE_MAN2", "man2"}, {TILE_TYPE_MAN3, "TILE_TYPE_MAN3", "man3"}, {TILE_TYPE_MAN4, "TILE_TYPE_MAN4", "man4"}, {TILE_TYPE_MAN5, "TILE_TYPE_MAN5", "man5"}, {TILE_TYPE_MAN6, "TILE_TYPE_MAN6", "man6"}, {TILE_TYPE_MAN7, "TILE_TYPE_MAN7", "man7"}, {TILE_TYPE_MAN8, "TILE_TYPE_MAN8", "man8"}, {TILE_TYPE_MAN9, "TILE_TYPE_MAN9", "man9"}, {TILE_TYPE_PIN1, "TILE_TYPE_PIN1", "pin1"}, {TILE_TYPE_PIN2, "TILE_TYPE_PIN2", "pin2"}, {TILE_TYPE_PIN3, "TILE_TYPE_PIN3", "pin3"}, {TILE_TYPE_PIN4, "TILE_TYPE_PIN4", "pin4"}, {TILE_TYPE_PIN5, "TILE_TYPE_PIN5", "pin5"}, {TILE_TYPE_PIN6, "TILE_TYPE_PIN6", "pin6"}, {TILE_TYPE_PIN7, "TILE_TYPE_PIN7", "pin7"}, {TILE_TYPE_PIN8, "TILE_TYPE_PIN8", "pin8"}, {TILE_TYPE_PIN9, "TILE_TYPE_PIN9", "pin9"}, {TILE_TYPE_SOU1, "TILE_TYPE_SOU1", "sou1"}, {TILE_TYPE_SOU2, "TILE_TYPE_SOU2", "sou2"}, {TILE_TYPE_SOU3, "TILE_TYPE_SOU3", "sou3"}, {TILE_TYPE_SOU4, "TILE_TYPE_SOU4", "sou4"}, {TILE_TYPE_SOU5, "TILE_TYPE_SOU5", "sou5"}, {TILE_TYPE_SOU6, "TILE_TYPE_SOU6", "sou6"}, {TILE_TYPE_SOU7, "TILE_TYPE_SOU7", "sou7"}, {TILE_TYPE_SOU8, "TILE_TYPE_SOU8", "sou8"}, {TILE_TYPE_SOU9, "TILE_TYPE_SOU9", "sou9"}, {TILE_TYPE_HIGASHI, "TILE_TYPE_HIGASHI", "higashi"}, {TILE_TYPE_MINAMI, "TILE_TYPE_MINAMI", "minami"}, {TILE_TYPE_NISHI, "TILE_TYPE_NISHI", "nishi"}, {TILE_TYPE_KITA, "TILE_TYPE_KITA", "kita"}, {TILE_TYPE_HATSU, "TILE_TYPE_HATSU", "hatsu"}, {TILE_TYPE_HAKU, "TILE_TYPE_HAKU", "haku"}, {TILE_TYPE_CHUN, "TILE_TYPE_CHUN", "chun"}, {0, NULL, NULL}};
		GType tile_type_type_id;
		tile_type_type_id = g_enum_register_static ("TILE_TYPE", values);
		g_once_init_leave (&tile_type_type_id__volatile, tile_type_type_id);
	}
	return tile_type_type_id__volatile;
}



