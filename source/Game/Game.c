/* Game.c generated by valac 0.12.0, the Vala compiler
 * generated from Game.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <GL/glew.h>
#include <gobject/gvaluecollector.h>


#define TYPE_GAME (game_get_type ())
#define GAME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME, Game))
#define GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME, GameClass))
#define IS_GAME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME))
#define IS_GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME))
#define GAME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME, GameClass))

typedef struct _Game Game;
typedef struct _GameClass GameClass;
typedef struct _GamePrivate GamePrivate;

#define TYPE_GAME_INTERFACE (game_interface_get_type ())
#define GAME_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_INTERFACE, GameInterface))
#define GAME_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_INTERFACE, GameInterfaceClass))
#define IS_GAME_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_INTERFACE))
#define IS_GAME_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_INTERFACE))
#define GAME_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_INTERFACE, GameInterfaceClass))

typedef struct _GameInterface GameInterface;
typedef struct _GameInterfaceClass GameInterfaceClass;

#define GAME_TYPE_GAME_STATE (game_game_state_get_type ())

#define TYPE_BOARD (board_get_type ())
#define BOARD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BOARD, Board))
#define BOARD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BOARD, BoardClass))
#define IS_BOARD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BOARD))
#define IS_BOARD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BOARD))
#define BOARD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BOARD, BoardClass))

typedef struct _Board Board;
typedef struct _BoardClass BoardClass;

#define TYPE_PLAYER (player_get_type ())
#define PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER, Player))
#define PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER, PlayerClass))
#define IS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER))
#define IS_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER))
#define PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER, PlayerClass))

typedef struct _Player Player;
typedef struct _PlayerClass PlayerClass;

#define TYPE_TILE (tile_get_type ())
#define TILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TILE, Tile))
#define TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TILE, TileClass))
#define IS_TILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TILE))
#define IS_TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TILE))
#define TILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TILE, TileClass))

typedef struct _Tile Tile;
typedef struct _TileClass TileClass;
#define _game_interface_unref0(var) ((var == NULL) ? NULL : (var = (game_interface_unref (var), NULL)))
#define _board_unref0(var) ((var == NULL) ? NULL : (var = (board_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_GAME_CONNECTION (game_connection_get_type ())
#define GAME_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_CONNECTION, GameConnection))
#define GAME_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_CONNECTION, GameConnectionClass))
#define IS_GAME_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_CONNECTION))
#define IS_GAME_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_CONNECTION))
#define GAME_CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_CONNECTION, GameConnectionClass))

typedef struct _GameConnection GameConnection;
typedef struct _GameConnectionClass GameConnectionClass;

#define TYPE_VECTOR (vector_get_type ())
#define VECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VECTOR, Vector))
#define VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VECTOR, VectorClass))
#define IS_VECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VECTOR))
#define IS_VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VECTOR))
#define VECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VECTOR, VectorClass))

typedef struct _Vector Vector;
typedef struct _VectorClass VectorClass;
#define _vector_unref0(var) ((var == NULL) ? NULL : (var = (vector_unref (var), NULL)))
#define _game_connection_unref0(var) ((var == NULL) ? NULL : (var = (game_connection_unref (var), NULL)))

#define TYPE_GAME_PLAYER (game_player_get_type ())
#define GAME_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_PLAYER, GamePlayer))
#define GAME_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_PLAYER, GamePlayerClass))
#define IS_GAME_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_PLAYER))
#define IS_GAME_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_PLAYER))
#define GAME_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_PLAYER, GamePlayerClass))

typedef struct _GamePlayer GamePlayer;
typedef struct _GamePlayerClass GamePlayerClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_NETWORK_PLAYER (network_player_get_type ())
#define NETWORK_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NETWORK_PLAYER, NetworkPlayer))
#define NETWORK_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NETWORK_PLAYER, NetworkPlayerClass))
#define IS_NETWORK_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NETWORK_PLAYER))
#define IS_NETWORK_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NETWORK_PLAYER))
#define NETWORK_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NETWORK_PLAYER, NetworkPlayerClass))

typedef struct _NetworkPlayer NetworkPlayer;
typedef struct _NetworkPlayerClass NetworkPlayerClass;

#define TYPE_COMPUTER_PLAYER (computer_player_get_type ())
#define COMPUTER_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPUTER_PLAYER, ComputerPlayer))
#define COMPUTER_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPUTER_PLAYER, ComputerPlayerClass))
#define IS_COMPUTER_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPUTER_PLAYER))
#define IS_COMPUTER_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPUTER_PLAYER))
#define COMPUTER_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPUTER_PLAYER, ComputerPlayerClass))

typedef struct _ComputerPlayer ComputerPlayer;
typedef struct _ComputerPlayerClass ComputerPlayerClass;

#define PLAYER_TYPE_PLAYER_STATE (player_player_state_get_type ())

#define TYPE_CALL_ACTION (call_action_get_type ())
#define CALL_ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CALL_ACTION, CallAction))
#define CALL_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CALL_ACTION, CallActionClass))
#define IS_CALL_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CALL_ACTION))
#define IS_CALL_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CALL_ACTION))
#define CALL_ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CALL_ACTION, CallActionClass))

typedef struct _CallAction CallAction;
typedef struct _CallActionClass CallActionClass;

#define CALL_ACTION_TYPE_CALL_ACTION_ENUM (call_action_call_action_enum_get_type ())

#define TYPE_TURN_ACTION (turn_action_get_type ())
#define TURN_ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TURN_ACTION, TurnAction))
#define TURN_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TURN_ACTION, TurnActionClass))
#define IS_TURN_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TURN_ACTION))
#define IS_TURN_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TURN_ACTION))
#define TURN_ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TURN_ACTION, TurnActionClass))

typedef struct _TurnAction TurnAction;
typedef struct _TurnActionClass TurnActionClass;

#define TURN_ACTION_TYPE_TURN_ACTION_ENUM (turn_action_turn_action_enum_get_type ())

#define TYPE_CALL (call_get_type ())
#define CALL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CALL, Call))
#define CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CALL, CallClass))
#define IS_CALL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CALL))
#define IS_CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CALL))
#define CALL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CALL, CallClass))

typedef struct _Call Call;
typedef struct _CallClass CallClass;

#define TYPE_PON (pon_get_type ())
#define PON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PON, Pon))
#define PON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PON, PonClass))
#define IS_PON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PON))
#define IS_PON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PON))
#define PON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PON, PonClass))

typedef struct _Pon Pon;
typedef struct _PonClass PonClass;
#define _call_unref0(var) ((var == NULL) ? NULL : (var = (call_unref (var), NULL)))

#define TYPE_BUTTON (button_get_type ())
#define BUTTON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BUTTON, Button))
#define BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BUTTON, ButtonClass))
#define IS_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BUTTON))
#define IS_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BUTTON))
#define BUTTON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BUTTON, ButtonClass))

typedef struct _Button Button;
typedef struct _ButtonClass ButtonClass;
#define _turn_action_unref0(var) ((var == NULL) ? NULL : (var = (turn_action_unref (var), NULL)))
#define _call_action_unref0(var) ((var == NULL) ? NULL : (var = (call_action_unref (var), NULL)))
#define _button_unref0(var) ((var == NULL) ? NULL : (var = (button_unref (var), NULL)))

#define ENVIRONMENT_TYPE_CURSOR_TYPE (environment_cursor_type_get_type ())
typedef struct _ParamSpecGame ParamSpecGame;

#define TYPE_DIRECTION (direction_get_type ())

struct _Game {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GamePrivate * priv;
};

struct _GameClass {
	GTypeClass parent_class;
	void (*finalize) (Game *self);
};

typedef enum  {
	GAME_GAME_STATE_WAITING_CALLS,
	GAME_GAME_STATE_WAITING_TURN,
	GAME_GAME_STATE_WAITING_CLOSED_OR_LATE_KAN,
	GAME_GAME_STATE_WAITING_CHI,
	GAME_GAME_STATE_WAITING_RIICHI_DISCARD,
	GAME_GAME_STATE_FINISHED
} GameGameState;

struct _GamePrivate {
	GameInterface* ui;
	GameGameState state;
	Board* board;
	Player** players;
	gint players_length1;
	gint _players_size_;
	Tile** tiles;
	gint tiles_length1;
	gint _tiles_size_;
	Tile** game_tiles;
	gint game_tiles_length1;
	gint _game_tiles_size_;
	GeeArrayList* dead_wall;
	GeeArrayList* wall_tiles;
	GeeArrayList* dora_tiles;
	Tile* last_played_tile;
	gint drawing_tile;
	gint kan_count;
	gint current_player;
	gint game_turn;
	gboolean first_round;
	gint player_seat;
};

typedef enum  {
	PLAYER_PLAYER_STATE_READY,
	PLAYER_PLAYER_STATE_DECIDING,
	PLAYER_PLAYER_STATE_WAITING_PON,
	PLAYER_PLAYER_STATE_WAITING_KAN,
	PLAYER_PLAYER_STATE_WAITING_CHI
} PlayerPlayerState;

typedef enum  {
	CALL_ACTION_CALL_ACTION_ENUM_NONE,
	CALL_ACTION_CALL_ACTION_ENUM_OPEN_KAN,
	CALL_ACTION_CALL_ACTION_ENUM_PON,
	CALL_ACTION_CALL_ACTION_ENUM_CHI,
	CALL_ACTION_CALL_ACTION_ENUM_RON
} CallActionCallActionEnum;

typedef enum  {
	TURN_ACTION_TURN_ACTION_ENUM_DISCARD,
	TURN_ACTION_TURN_ACTION_ENUM_CLOSED_KAN,
	TURN_ACTION_TURN_ACTION_ENUM_LATE_KAN,
	TURN_ACTION_TURN_ACTION_ENUM_RIICHI,
	TURN_ACTION_TURN_ACTION_ENUM_OPEN_RIICHI,
	TURN_ACTION_TURN_ACTION_ENUM_TSUMO
} TurnActionTurnActionEnum;

typedef enum  {
	ENVIRONMENT_CURSOR_TYPE_DEFAULT,
	ENVIRONMENT_CURSOR_TYPE_HOVER
} EnvironmentCursorType;

struct _ParamSpecGame {
	GParamSpec parent_instance;
};

typedef enum  {
	DIRECTION_LEFT = -1,
	DIRECTION_FRONT = 0,
	DIRECTION_RIGHT = 1
} Direction;


static gpointer game_parent_class = NULL;
static GRand* game_rnd;
static GRand* game_rnd = NULL;

gpointer game_ref (gpointer instance);
void game_unref (gpointer instance);
GParamSpec* param_spec_game (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_game (GValue* value, gpointer v_object);
void value_take_game (GValue* value, gpointer v_object);
gpointer value_get_game (const GValue* value);
GType game_get_type (void) G_GNUC_CONST;
gpointer game_interface_ref (gpointer instance);
void game_interface_unref (gpointer instance);
GParamSpec* param_spec_game_interface (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_game_interface (GValue* value, gpointer v_object);
void value_take_game_interface (GValue* value, gpointer v_object);
gpointer value_get_game_interface (const GValue* value);
GType game_interface_get_type (void) G_GNUC_CONST;
static GType game_game_state_get_type (void) G_GNUC_UNUSED;
gpointer board_ref (gpointer instance);
void board_unref (gpointer instance);
GParamSpec* param_spec_board (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_board (GValue* value, gpointer v_object);
void value_take_board (GValue* value, gpointer v_object);
gpointer value_get_board (const GValue* value);
GType board_get_type (void) G_GNUC_CONST;
GType player_get_type (void) G_GNUC_CONST;
GType tile_get_type (void) G_GNUC_CONST;
#define GAME_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GAME, GamePrivate))
enum  {
	GAME_DUMMY_PROPERTY
};
GameInterface* game_interface_new (void);
GameInterface* game_interface_construct (GType object_type);
Board* board_new (gfloat size);
Board* board_construct (GType object_type, gfloat size);
Game* game_new (void);
Game* game_construct (GType object_type);
gpointer game_connection_ref (gpointer instance);
void game_connection_unref (gpointer instance);
GParamSpec* param_spec_game_connection (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_game_connection (GValue* value, gpointer v_object);
void value_take_game_connection (GValue* value, gpointer v_object);
gpointer value_get_game_connection (const GValue* value);
GType game_connection_get_type (void) G_GNUC_CONST;
Game* game_new_seed (guint8* tile_seed, int tile_seed_length1, guint8 wall_split, guint8 seat, GList* connections);
Game* game_construct_seed (GType object_type, guint8* tile_seed, int tile_seed_length1, guint8 wall_split, guint8 seat, GList* connections);
Tile* tile_new (gfloat size, guint8 id, gint type);
Tile* tile_construct (GType object_type, gfloat size, guint8 id, gint type);
Vector* vector_new (gfloat x, gfloat y, gfloat z);
Vector* vector_construct (GType object_type, gfloat x, gfloat y, gfloat z);
gpointer vector_ref (gpointer instance);
void vector_unref (gpointer instance);
GParamSpec* param_spec_vector (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_vector (GValue* value, gpointer v_object);
void value_take_vector (GValue* value, gpointer v_object);
gpointer value_get_vector (const GValue* value);
GType vector_get_type (void) G_GNUC_CONST;
void tile_set_rotation (Tile* self, Vector* value);
void tile_set_color_ID (Tile* self, guint value);
#define TILE_tile_size 0.1f
#define TILE_TILE_WIDTH (1.94f * TILE_tile_size)
#define TILE_TILE_SPACING 0.005f
#define TILE_TILE_LENGTH (1.59f * TILE_tile_size)
void tile_set_position (Tile* self, Vector* value);
static void game_dead_wall_split (Game* self, gint player, gint number);
static void game_flip_dora (Game* self);
GamePlayer* game_player_new (gint position, const gchar* name, GameConnection* connection);
GamePlayer* game_player_construct (GType object_type, gint position, const gchar* name, GameConnection* connection);
GType game_player_get_type (void) G_GNUC_CONST;
NetworkPlayer* network_player_new (gint position, GameConnection* connection);
NetworkPlayer* network_player_construct (GType object_type, gint position, GameConnection* connection);
GType network_player_get_type (void) G_GNUC_CONST;
ComputerPlayer* computer_player_new (gint position, const gchar* name);
ComputerPlayer* computer_player_construct (GType object_type, gint position, const gchar* name);
GType computer_player_get_type (void) G_GNUC_CONST;
void player_add_tile (Player* self, Tile* t);
void player_arrange_hand (Player* self);
static void game_game_start (Game* self);
void game_process (Game* self, gdouble dt);
GType player_player_state_get_type (void) G_GNUC_CONST;
PlayerPlayerState player_get_state (Player* self);
gpointer call_action_ref (gpointer instance);
void call_action_unref (gpointer instance);
GParamSpec* param_spec_call_action (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_call_action (GValue* value, gpointer v_object);
void value_take_call_action (GValue* value, gpointer v_object);
gpointer value_get_call_action (const GValue* value);
GType call_action_get_type (void) G_GNUC_CONST;
CallAction* player_get_call_action (Player* self);
GType call_action_call_action_enum_get_type (void) G_GNUC_CONST;
CallActionCallActionEnum call_action_get_action (CallAction* self);
void player_steal_tile (Player* self, Tile* t);
void player_do_ron (Player* self, Tile* tile);
static void game_toggle_interface (Game* self, gboolean show);
void player_do_open_kan (Player* self, Tile** tiles, int tiles_length1, Tile* discard_tile, gint discard_player);
Tile** tile_ints_to_tiles (Tile** tiles, int tiles_length1, guint8* ids, int ids_length1, int* result_length1);
guint8* call_action_get_tiles (CallAction* self, int* result_length1);
void player_set_call_action (Player* self, CallAction* value);
gint player_get_position (Player* self);
static void game_draw_dead_wall (Game* self);
void player_do_pon (Player* self, Tile** tiles, int tiles_length1, Tile* discard_tile, gint discard_player);
void player_do_chi (Player* self, Tile** tiles, int tiles_length1, Tile* discard_tile);
static void game_draw_tile (Game* self);
gboolean player_turn_decision (Player* self);
gpointer turn_action_ref (gpointer instance);
void turn_action_unref (gpointer instance);
GParamSpec* param_spec_turn_action (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_turn_action (GValue* value, gpointer v_object);
void value_take_turn_action (GValue* value, gpointer v_object);
gpointer value_get_turn_action (const GValue* value);
GType turn_action_get_type (void) G_GNUC_CONST;
TurnAction* player_get_turn_action (Player* self);
GType turn_action_turn_action_enum_get_type (void) G_GNUC_CONST;
TurnActionTurnActionEnum turn_action_get_action (TurnAction* self);
void player_discard_tile (Player* self, Tile* t);
guint8* turn_action_get_discard_tile (TurnAction* self);
static void game_discard_tile (Game* self, Tile* t);
void player_do_closed_kan (Player* self, Tile** tiles, int tiles_length1);
guint8* turn_action_get_kan_tiles (TurnAction* self, int* result_length1);
gpointer call_ref (gpointer instance);
void call_unref (gpointer instance);
GParamSpec* param_spec_call (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_call (GValue* value, gpointer v_object);
void value_take_call (GValue* value, gpointer v_object);
gpointer value_get_call (const GValue* value);
GType call_get_type (void) G_GNUC_CONST;
GType pon_get_type (void) G_GNUC_CONST;
void player_do_late_kan (Player* self, Tile* tile, Pon* pon);
guint8* turn_action_get_late_kan_tile (TurnAction* self);
GeeArrayList* player_get_pons (Player* self);
guint8* turn_action_get_late_kan_pon (TurnAction* self);
void player_do_riichi (Player* self, gboolean open, gint turn, Tile* tile);
void player_do_tsumo (Player* self);
Vector* tile_get_rotation (Tile* self);
gfloat vector_get_z (Vector* self);
gfloat vector_get_y (Vector* self);
void vector_set_y (Vector* self, gfloat value);
gfloat vector_get_x (Vector* self);
void vector_set_x (Vector* self, gfloat value);
Vector* tile_get_position (Tile* self);
void vector_set_z (Vector* self, gfloat value);
void player_draw_tile (Player* self, Tile* t);
gboolean player_call_decision (Player* self, Tile* discard_tile, gboolean can_chi);
void game_render (Game* self);
void board_render (Board* self);
void player_render (Player* self);
void tile_render (Tile* self);
void game_render_selection (Game* self);
void player_render_selection (Player* self);
void game_render_interface (Game* self);
void game_interface_render (GameInterface* self);
void game_render_interface_selection (Game* self);
void game_interface_render_selection (GameInterface* self);
void game_interface_set_visible (GameInterface* self, gboolean value);
gboolean player_get_in_riichi (Player* self);
gboolean logic_can_pon (Tile* played_tile, GeeArrayList* hand);
GeeArrayList* player_get_hand (Player* self);
void game_interface_set_show_pon (GameInterface* self, gboolean value);
gboolean logic_can_open_kan (Tile* played_tile, GeeArrayList* hand);
void game_interface_set_show_kan (GameInterface* self, gboolean value);
gboolean logic_can_chi (Tile* played_tile, GeeArrayList* hand);
void game_interface_set_show_chi (GameInterface* self, gboolean value);
void game_interface_set_show_riichi (GameInterface* self, gboolean value);
void game_interface_set_show_tsumo (GameInterface* self, gboolean value);
gboolean logic_can_win_with (GeeArrayList* hand, Tile* tile);
void game_interface_set_show_ron (GameInterface* self, gboolean value);
gboolean logic_can_riichi_closed_kan (GeeArrayList* hand);
gboolean logic_can_closed_kan (GeeArrayList* hand);
gboolean logic_can_late_kan (GeeArrayList* hand, GeeArrayList* pons);
gboolean player_get_open_hand (Player* self);
GeeArrayList* logic_can_tenpai (GeeArrayList* hand);
gboolean logic_winning_hand (GeeArrayList* hand);
void game_mouse_click (Game* self, gint x, gint y, guint color_id, gboolean mouse_state);
gpointer button_ref (gpointer instance);
void button_unref (gpointer instance);
GParamSpec* param_spec_button (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_button (GValue* value, gpointer v_object);
void value_take_button (GValue* value, gpointer v_object);
gpointer value_get_button (const GValue* value);
GType button_get_type (void) G_GNUC_CONST;
Button* game_interface_click (GameInterface* self, gint x, gint y, guint color_id, gboolean state);
const gchar* button_get_name (Button* self);
static void game_do_continue (Game* self);
static void game_do_pon (Game* self);
static void game_do_open_kan (Game* self);
static void game_do_closed_or_late_kan (Game* self);
static void game_do_chi (Game* self);
gboolean logic_has_yaku (Player* player, Tile* ron_tile, gboolean last_piece, gboolean kan_piece);
TurnAction* turn_action_new_tsumo (void);
TurnAction* turn_action_construct_tsumo (GType object_type);
void player_set_turn_action (Player* self, TurnAction* value);
void player_set_state (Player* self, PlayerPlayerState value);
guint8 tile_get_id (Tile* self);
CallAction* call_action_new_ron (guint8 tile);
CallAction* call_action_construct_ron (GType object_type, guint8 tile);
Tile* player_tile_press (Player* self, guint color_ID);
void tile_set_hovering (Tile* self, gboolean value);
TurnAction* turn_action_new_discard (guint8 discard_tile);
TurnAction* turn_action_construct_discard (GType object_type, guint8 discard_tile);
Tile* logic_chi_combination (Tile* discard_tile, Tile* selected_tile, GeeArrayList* hand);
guint8* tile_tiles_to_ints (Tile** tiles, int tiles_length1, int* result_length1);
CallAction* call_action_new (CallActionCallActionEnum action, guint8* tiles, int tiles_length1);
CallAction* call_action_construct (GType object_type, CallActionCallActionEnum action, guint8* tiles, int tiles_length1);
gint tile_get_tile_type (Tile* self);
Tile** call_get_tiles (Call* self, int* result_length1);
TurnAction* turn_action_new_late_kan (guint8 kan_tile, guint8 pon);
TurnAction* turn_action_construct_late_kan (GType object_type, guint8 kan_tile, guint8 pon);
TurnAction* turn_action_new_closed_kan (guint8* kan, int kan_length1);
TurnAction* turn_action_construct_closed_kan (GType object_type, guint8* kan, int kan_length1);
TurnAction* turn_action_new_riichi (guint8 discard_tile);
TurnAction* turn_action_construct_riichi (GType object_type, guint8 discard_tile);
void game_mouse_move (Game* self, gint x, gint y, guint color_id);
gboolean game_interface_hover (GameInterface* self, gint x, gint y, guint color_id);
GType environment_cursor_type_get_type (void) G_GNUC_CONST;
void environment_set_cursor (EnvironmentCursorType type);
void player_clear_hover (Player* self);
gboolean player_hover (Player* self, guint tile_ID);
static guint8* _uint8_dup (guint8* self);
static Tile** _vala_array_dup6 (Tile** self, int length);
Tile** logic_auto_chi (Tile* discard_tile, GeeArrayList* hand, int* result_length1);
static void game_finalize (Game* obj);
GType direction_get_type (void) G_GNUC_CONST;
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static GType game_game_state_get_type (void) {
	static volatile gsize game_game_state_type_id__volatile = 0;
	if (g_once_init_enter (&game_game_state_type_id__volatile)) {
		static const GEnumValue values[] = {{GAME_GAME_STATE_WAITING_CALLS, "GAME_GAME_STATE_WAITING_CALLS", "waiting-calls"}, {GAME_GAME_STATE_WAITING_TURN, "GAME_GAME_STATE_WAITING_TURN", "waiting-turn"}, {GAME_GAME_STATE_WAITING_CLOSED_OR_LATE_KAN, "GAME_GAME_STATE_WAITING_CLOSED_OR_LATE_KAN", "waiting-closed-or-late-kan"}, {GAME_GAME_STATE_WAITING_CHI, "GAME_GAME_STATE_WAITING_CHI", "waiting-chi"}, {GAME_GAME_STATE_WAITING_RIICHI_DISCARD, "GAME_GAME_STATE_WAITING_RIICHI_DISCARD", "waiting-riichi-discard"}, {GAME_GAME_STATE_FINISHED, "GAME_GAME_STATE_FINISHED", "finished"}, {0, NULL, NULL}};
		GType game_game_state_type_id;
		game_game_state_type_id = g_enum_register_static ("GameGameState", values);
		g_once_init_leave (&game_game_state_type_id__volatile, game_game_state_type_id);
	}
	return game_game_state_type_id__volatile;
}


Game* game_construct (GType object_type) {
	Game* self = NULL;
	gint32 _tmp0_;
	guint8 wall_split;
	guint8* _tmp1_ = NULL;
	guint8* tiles;
	gint tiles_length1;
	gint _tiles_size_;
	gint32 _tmp5_;
	self = (Game*) g_type_create_instance (object_type);
	_tmp0_ = g_rand_int_range (game_rnd, (gint32) 2, (gint32) 12);
	wall_split = (guint8) _tmp0_;
	_tmp1_ = g_new0 (guint8, self->priv->tiles_length1);
	tiles = _tmp1_;
	tiles_length1 = self->priv->tiles_length1;
	_tiles_size_ = self->priv->tiles_length1;
	{
		guint8 i;
		i = (guint8) 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					i++;
				}
				_tmp2_ = FALSE;
				if (!(i < tiles_length1)) {
					break;
				}
				tiles[i] = i;
			}
		}
	}
	{
		guint8 i;
		i = (guint8) 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint32 _tmp4_;
				gint r;
				guint8 t;
				if (!_tmp3_) {
					i++;
				}
				_tmp3_ = FALSE;
				if (!(i < tiles_length1)) {
					break;
				}
				_tmp4_ = g_rand_int_range (game_rnd, (gint32) 0, (gint32) (tiles_length1 - 1));
				r = (gint) _tmp4_;
				t = tiles[r];
				tiles[r] = tiles[i];
				tiles[i] = t;
			}
		}
	}
	_tmp5_ = g_rand_int_range (game_rnd, (gint32) 0, (gint32) 4);
	self = (Game*) game_construct_seed (object_type, tiles, tiles_length1, wall_split, (guint8) _tmp5_, NULL);
	tiles = (g_free (tiles), NULL);
	return self;
}


Game* game_new (void) {
	return game_construct (TYPE_GAME);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _game_connection_ref0 (gpointer self) {
	return self ? game_connection_ref (self) : NULL;
}


Game* game_construct_seed (GType object_type, guint8* tile_seed, int tile_seed_length1, guint8 wall_split, guint8 seat, GList* connections) {
	Game* self = NULL;
	gint starting_player;
	gint _tmp14_;
	gint a;
	self = (Game*) g_type_create_instance (object_type);
	g_print ("Game seed\n");
	self->priv->player_seat = ((gint) seat) % 4;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				Tile* _tmp1_ = NULL;
				Tile* t;
				Vector* _tmp2_ = NULL;
				Vector* _tmp3_;
				Tile* _tmp4_;
				Tile* _tmp5_;
				Tile* _tmp6_;
				Tile* _tmp7_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->tiles_length1)) {
					break;
				}
				_tmp1_ = tile_new ((gfloat) 1, (guint8) i, i / 4);
				t = _tmp1_;
				_tmp2_ = vector_new ((gfloat) 90, (gfloat) 0, (gfloat) 0);
				_tmp3_ = _tmp2_;
				tile_set_rotation (t, _tmp3_);
				_vector_unref0 (_tmp3_);
				tile_set_color_ID (t, (guint) (i + 1));
				_tmp4_ = _g_object_ref0 (t);
				_tmp5_ = _tmp4_;
				_g_object_unref0 (self->priv->tiles[i]);
				self->priv->tiles[i] = _tmp5_;
				_tmp6_ = _g_object_ref0 (t);
				_tmp7_ = _tmp6_;
				_g_object_unref0 (self->priv->game_tiles[tile_seed[i]]);
				self->priv->game_tiles[tile_seed[i]] = _tmp7_;
				_g_object_unref0 (t);
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp8_;
			_tmp8_ = TRUE;
			while (TRUE) {
				gfloat rot;
				gfloat x;
				gfloat y;
				gint _tmp9_ = 0;
				gfloat z;
				Vector* _tmp10_ = NULL;
				Vector* _tmp11_;
				Vector* _tmp12_ = NULL;
				Vector* _tmp13_;
				if (!_tmp8_) {
					i++;
				}
				_tmp8_ = FALSE;
				if (!(i < self->priv->game_tiles_length1)) {
					break;
				}
				gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->wall_tiles, self->priv->game_tiles[i]);
				rot = (gfloat) ((i / 34) * 90);
				x = (((i % 34) / 2) - 8.f) * (TILE_TILE_WIDTH + TILE_TILE_SPACING);
				y = 2.2f;
				if ((i % 2) == 0) {
					_tmp9_ = 2;
				} else {
					_tmp9_ = 1;
				}
				z = TILE_TILE_LENGTH * _tmp9_;
				if ((i / 34) == 1) {
					gfloat a;
					a = x;
					x = y;
					y = -a;
				} else {
					if ((i / 34) == 2) {
						x = -x;
						y = -y;
					} else {
						if ((i / 34) == 3) {
							gfloat a;
							a = x;
							x = -y;
							y = a;
						}
					}
				}
				_tmp10_ = vector_new ((gfloat) 180, (gfloat) 0, rot);
				_tmp11_ = _tmp10_;
				tile_set_rotation (self->priv->game_tiles[i], _tmp11_);
				_vector_unref0 (_tmp11_);
				_tmp12_ = vector_new (x, y, z);
				_tmp13_ = _tmp12_;
				tile_set_position (self->priv->game_tiles[i], _tmp13_);
				_vector_unref0 (_tmp13_);
			}
		}
	}
	starting_player = wall_split % 4;
	_tmp14_ = MAX (((starting_player * 34) + (wall_split * 2)) - 14, 0);
	self->priv->drawing_tile = _tmp14_;
	game_dead_wall_split (self, starting_player, (gint) wall_split);
	game_flip_dora (self);
	a = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp15_;
			_tmp15_ = TRUE;
			while (TRUE) {
				gboolean _tmp26_ = FALSE;
				if (!_tmp15_) {
					i++;
				}
				_tmp15_ = FALSE;
				if (!(i < 4)) {
					break;
				}
				if (i == seat) {
					GameConnection* g;
					gboolean _tmp16_ = FALSE;
					gchar* _tmp20_ = NULL;
					gchar* _tmp21_;
					gchar* _tmp22_;
					gchar* _tmp23_;
					GamePlayer* _tmp24_ = NULL;
					Player* _tmp25_;
					g = NULL;
					if (connections != NULL) {
						guint _tmp17_;
						_tmp17_ = g_list_length (connections);
						_tmp16_ = _tmp17_ > 1;
					} else {
						_tmp16_ = FALSE;
					}
					if (_tmp16_) {
						gconstpointer _tmp18_ = NULL;
						GameConnection* _tmp19_;
						_tmp18_ = g_list_nth_data (connections, (guint) 0);
						_tmp19_ = _game_connection_ref0 ((GameConnection*) _tmp18_);
						_game_connection_unref0 (g);
						g = _tmp19_;
					}
					_tmp20_ = g_strdup_printf ("%i", i);
					_tmp21_ = _tmp20_;
					_tmp22_ = g_strconcat ("Player", _tmp21_, NULL);
					_tmp23_ = _tmp22_;
					_tmp24_ = game_player_new (i, _tmp23_, g);
					_tmp25_ = (Player*) _tmp24_;
					_g_object_unref0 (self->priv->players[i]);
					self->priv->players[i] = _tmp25_;
					_g_free0 (_tmp23_);
					_g_free0 (_tmp21_);
					_game_connection_unref0 (g);
					continue;
				}
				if (connections != NULL) {
					guint _tmp27_;
					_tmp27_ = g_list_length (connections);
					a = a + 1;
					_tmp26_ = _tmp27_ > a;
				} else {
					_tmp26_ = FALSE;
				}
				if (_tmp26_) {
					gconstpointer _tmp28_ = NULL;
					NetworkPlayer* _tmp29_ = NULL;
					Player* _tmp30_;
					_tmp28_ = g_list_nth_data (connections, (guint) a);
					_tmp29_ = network_player_new (i, (GameConnection*) _tmp28_);
					_tmp30_ = (Player*) _tmp29_;
					_g_object_unref0 (self->priv->players[i]);
					self->priv->players[i] = _tmp30_;
				} else {
					gchar* _tmp31_ = NULL;
					gchar* _tmp32_;
					gchar* _tmp33_;
					gchar* _tmp34_;
					ComputerPlayer* _tmp35_ = NULL;
					Player* _tmp36_;
					_tmp31_ = g_strdup_printf ("%i", i);
					_tmp32_ = _tmp31_;
					_tmp33_ = g_strconcat ("Computer", _tmp32_, NULL);
					_tmp34_ = _tmp33_;
					_tmp35_ = computer_player_new (i, _tmp34_);
					_tmp36_ = (Player*) _tmp35_;
					_g_object_unref0 (self->priv->players[i]);
					self->priv->players[i] = _tmp36_;
					_g_free0 (_tmp34_);
					_g_free0 (_tmp32_);
				}
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp37_;
			_tmp37_ = TRUE;
			while (TRUE) {
				gint _tmp38_ = 0;
				gint p;
				gint _tmp39_;
				gpointer _tmp40_ = NULL;
				Tile* _tmp41_;
				gpointer _tmp42_ = NULL;
				Tile* _tmp43_;
				if (!_tmp37_) {
					i++;
				}
				_tmp37_ = FALSE;
				if (!(i < 52)) {
					break;
				}
				if (i < 48) {
					_tmp38_ = (i / 4) % 4;
				} else {
					_tmp38_ = i % 4;
				}
				p = _tmp38_;
				_tmp39_ = gee_collection_get_size ((GeeCollection*) self->priv->wall_tiles);
				self->priv->drawing_tile = self->priv->drawing_tile % _tmp39_;
				_tmp40_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->wall_tiles, self->priv->drawing_tile);
				_tmp41_ = (Tile*) _tmp40_;
				player_add_tile (self->priv->players[p], _tmp41_);
				_g_object_unref0 (_tmp41_);
				_tmp42_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->wall_tiles, self->priv->drawing_tile);
				_tmp43_ = (Tile*) _tmp42_;
				gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->wall_tiles, _tmp43_);
				_g_object_unref0 (_tmp43_);
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp44_;
			_tmp44_ = TRUE;
			while (TRUE) {
				if (!_tmp44_) {
					i++;
				}
				_tmp44_ = FALSE;
				if (!(i < 4)) {
					break;
				}
				player_arrange_hand (self->priv->players[i]);
			}
		}
	}
	game_game_start (self);
	g_print ("Game seeded\n");
	return self;
}


Game* game_new_seed (guint8* tile_seed, int tile_seed_length1, guint8 wall_split, guint8 seat, GList* connections) {
	return game_construct_seed (TYPE_GAME, tile_seed, tile_seed_length1, wall_split, seat, connections);
}


void game_process (Game* self, gdouble dt) {
	g_return_if_fail (self != NULL);
	if (self->priv->state == GAME_GAME_STATE_WAITING_CALLS) {
		gint player;
		gboolean _tmp41_ = FALSE;
		gboolean _tmp42_;
		{
			Player** p_collection;
			int p_collection_length1;
			int p_it;
			p_collection = self->priv->players;
			p_collection_length1 = self->priv->players_length1;
			for (p_it = 0; p_it < self->priv->players_length1; p_it = p_it + 1) {
				Player* _tmp0_;
				Player* p;
				_tmp0_ = _g_object_ref0 (p_collection[p_it]);
				p = _tmp0_;
				{
					PlayerPlayerState _tmp1_;
					_tmp1_ = player_get_state (p);
					if (_tmp1_ != PLAYER_PLAYER_STATE_READY) {
						_g_object_unref0 (p);
						return;
					}
					_g_object_unref0 (p);
				}
			}
		}
		player = -1;
		{
			Player** p_collection;
			int p_collection_length1;
			int p_it;
			p_collection = self->priv->players;
			p_collection_length1 = self->priv->players_length1;
			for (p_it = 0; p_it < self->priv->players_length1; p_it = p_it + 1) {
				Player* _tmp2_;
				Player* p;
				_tmp2_ = _g_object_ref0 (p_collection[p_it]);
				p = _tmp2_;
				{
					gboolean _tmp3_ = FALSE;
					if (p == self->priv->players[self->priv->current_player]) {
						_tmp3_ = TRUE;
					} else {
						CallAction* _tmp4_ = NULL;
						_tmp4_ = player_get_call_action (p);
						_tmp3_ = _tmp4_ == NULL;
					}
					if (_tmp3_) {
						_g_object_unref0 (p);
						continue;
					} else {
						CallAction* _tmp5_ = NULL;
						CallActionCallActionEnum _tmp6_;
						_tmp5_ = player_get_call_action (p);
						_tmp6_ = call_action_get_action (_tmp5_);
						if (_tmp6_ == CALL_ACTION_CALL_ACTION_ENUM_RON) {
							player_steal_tile (self->priv->players[self->priv->current_player], self->priv->last_played_tile);
							player_do_ron (p, self->priv->last_played_tile);
							self->priv->state = GAME_GAME_STATE_FINISHED;
							game_toggle_interface (self, FALSE);
							_g_object_unref0 (p);
							return;
						}
					}
					_g_object_unref0 (p);
				}
			}
		}
		{
			Player** p_collection;
			int p_collection_length1;
			int p_it;
			p_collection = self->priv->players;
			p_collection_length1 = self->priv->players_length1;
			for (p_it = 0; p_it < self->priv->players_length1; p_it = p_it + 1) {
				Player* _tmp7_;
				Player* p;
				_tmp7_ = _g_object_ref0 (p_collection[p_it]);
				p = _tmp7_;
				{
					gboolean _tmp8_ = FALSE;
					if (p == self->priv->players[self->priv->current_player]) {
						_tmp8_ = TRUE;
					} else {
						CallAction* _tmp9_ = NULL;
						_tmp9_ = player_get_call_action (p);
						_tmp8_ = _tmp9_ == NULL;
					}
					if (_tmp8_) {
						_g_object_unref0 (p);
						continue;
					} else {
						CallAction* _tmp10_ = NULL;
						CallActionCallActionEnum _tmp11_;
						_tmp10_ = player_get_call_action (p);
						_tmp11_ = call_action_get_action (_tmp10_);
						if (_tmp11_ == CALL_ACTION_CALL_ACTION_ENUM_OPEN_KAN) {
							CallAction* _tmp12_ = NULL;
							guint8* _tmp13_ = NULL;
							gint _tmp14_;
							gint _tmp15_;
							Tile** _tmp16_ = NULL;
							Tile** _tmp17_;
							gint _tmp17__length1;
							gint _tmp18_;
							_tmp12_ = player_get_call_action (p);
							_tmp13_ = call_action_get_tiles (_tmp12_, &_tmp14_);
							_tmp16_ = tile_ints_to_tiles (self->priv->tiles, self->priv->tiles_length1, _tmp13_, _tmp14_, &_tmp15_);
							_tmp17_ = _tmp16_;
							_tmp17__length1 = _tmp15_;
							player_do_open_kan (p, _tmp17_, _tmp15_, self->priv->last_played_tile, self->priv->current_player);
							_tmp17_ = (_vala_array_free (_tmp17_, _tmp17__length1, (GDestroyNotify) g_object_unref), NULL);
							player_set_call_action (p, NULL);
							player_steal_tile (self->priv->players[self->priv->current_player], self->priv->last_played_tile);
							_tmp18_ = player_get_position (p);
							player = _tmp18_;
							self->priv->current_player = player;
							game_draw_dead_wall (self);
						} else {
							CallAction* _tmp19_ = NULL;
							CallActionCallActionEnum _tmp20_;
							_tmp19_ = player_get_call_action (p);
							_tmp20_ = call_action_get_action (_tmp19_);
							if (_tmp20_ == CALL_ACTION_CALL_ACTION_ENUM_PON) {
								CallAction* _tmp21_ = NULL;
								guint8* _tmp22_ = NULL;
								gint _tmp23_;
								gint _tmp24_;
								Tile** _tmp25_ = NULL;
								Tile** _tmp26_;
								gint _tmp26__length1;
								gint _tmp27_;
								_tmp21_ = player_get_call_action (p);
								_tmp22_ = call_action_get_tiles (_tmp21_, &_tmp23_);
								_tmp25_ = tile_ints_to_tiles (self->priv->tiles, self->priv->tiles_length1, _tmp22_, _tmp23_, &_tmp24_);
								_tmp26_ = _tmp25_;
								_tmp26__length1 = _tmp24_;
								player_do_pon (p, _tmp26_, _tmp24_, self->priv->last_played_tile, self->priv->current_player);
								_tmp26_ = (_vala_array_free (_tmp26_, _tmp26__length1, (GDestroyNotify) g_object_unref), NULL);
								player_set_call_action (p, NULL);
								player_steal_tile (self->priv->players[self->priv->current_player], self->priv->last_played_tile);
								_tmp27_ = player_get_position (p);
								player = _tmp27_;
							}
						}
					}
					_g_object_unref0 (p);
				}
			}
		}
		if (player == (-1)) {
			{
				Player** p_collection;
				int p_collection_length1;
				int p_it;
				p_collection = self->priv->players;
				p_collection_length1 = self->priv->players_length1;
				for (p_it = 0; p_it < self->priv->players_length1; p_it = p_it + 1) {
					Player* _tmp28_;
					Player* p;
					_tmp28_ = _g_object_ref0 (p_collection[p_it]);
					p = _tmp28_;
					{
						gboolean _tmp29_ = FALSE;
						CallAction* _tmp31_ = NULL;
						CallActionCallActionEnum _tmp32_;
						if (p == self->priv->players[self->priv->current_player]) {
							_tmp29_ = TRUE;
						} else {
							CallAction* _tmp30_ = NULL;
							_tmp30_ = player_get_call_action (p);
							_tmp29_ = _tmp30_ == NULL;
						}
						if (_tmp29_) {
							_g_object_unref0 (p);
							continue;
						}
						_tmp31_ = player_get_call_action (p);
						_tmp32_ = call_action_get_action (_tmp31_);
						if (_tmp32_ == CALL_ACTION_CALL_ACTION_ENUM_CHI) {
							CallAction* _tmp33_ = NULL;
							guint8* _tmp34_ = NULL;
							gint _tmp35_;
							gint _tmp36_;
							Tile** _tmp37_ = NULL;
							Tile** _tmp38_;
							gint _tmp38__length1;
							gint _tmp39_;
							_tmp33_ = player_get_call_action (p);
							_tmp34_ = call_action_get_tiles (_tmp33_, &_tmp35_);
							_tmp37_ = tile_ints_to_tiles (self->priv->tiles, self->priv->tiles_length1, _tmp34_, _tmp35_, &_tmp36_);
							_tmp38_ = _tmp37_;
							_tmp38__length1 = _tmp36_;
							player_do_chi (p, _tmp38_, _tmp36_, self->priv->last_played_tile);
							_tmp38_ = (_vala_array_free (_tmp38_, _tmp38__length1, (GDestroyNotify) g_object_unref), NULL);
							player_set_call_action (p, NULL);
							player_steal_tile (self->priv->players[self->priv->current_player], self->priv->last_played_tile);
							_tmp39_ = player_get_position (p);
							player = _tmp39_;
						}
						_g_object_unref0 (p);
					}
				}
			}
		}
		if (player == (-1)) {
			gint _tmp40_;
			_tmp40_ = gee_collection_get_size ((GeeCollection*) self->priv->wall_tiles);
			if ((_tmp40_ - self->priv->kan_count) <= 0) {
				self->priv->state = GAME_GAME_STATE_FINISHED;
				return;
			}
			self->priv->current_player = (self->priv->current_player + 1) % 4;
			game_draw_tile (self);
		} else {
			self->priv->current_player = player;
			self->priv->first_round = FALSE;
		}
		self->priv->game_turn++;
		if (self->priv->game_turn >= 4) {
			self->priv->first_round = FALSE;
		}
		self->priv->state = GAME_GAME_STATE_WAITING_TURN;
		_tmp42_ = player_turn_decision (self->priv->players[self->priv->current_player]);
		if (_tmp42_) {
			_tmp41_ = self->priv->current_player == self->priv->player_seat;
		} else {
			_tmp41_ = FALSE;
		}
		if (_tmp41_) {
			game_toggle_interface (self, TRUE);
		}
	}
	if (self->priv->state == GAME_GAME_STATE_WAITING_TURN) {
		PlayerPlayerState _tmp43_;
		_tmp43_ = player_get_state (self->priv->players[self->priv->current_player]);
		if (_tmp43_ == PLAYER_PLAYER_STATE_READY) {
			TurnAction* _tmp44_ = NULL;
			TurnActionTurnActionEnum _tmp45_;
			_tmp44_ = player_get_turn_action (self->priv->players[self->priv->current_player]);
			_tmp45_ = turn_action_get_action (_tmp44_);
			switch (_tmp45_) {
				case TURN_ACTION_TURN_ACTION_ENUM_DISCARD:
				{
					TurnAction* _tmp46_ = NULL;
					guint8* _tmp47_ = NULL;
					TurnAction* _tmp48_ = NULL;
					guint8* _tmp49_ = NULL;
					_tmp46_ = player_get_turn_action (self->priv->players[self->priv->current_player]);
					_tmp47_ = turn_action_get_discard_tile (_tmp46_);
					player_discard_tile (self->priv->players[self->priv->current_player], self->priv->tiles[(gint) (*_tmp47_)]);
					_tmp48_ = player_get_turn_action (self->priv->players[self->priv->current_player]);
					_tmp49_ = turn_action_get_discard_tile (_tmp48_);
					game_discard_tile (self, self->priv->tiles[(gint) (*_tmp49_)]);
					break;
				}
				case TURN_ACTION_TURN_ACTION_ENUM_CLOSED_KAN:
				{
					TurnAction* _tmp50_ = NULL;
					guint8* _tmp51_ = NULL;
					gint _tmp52_;
					gint _tmp53_;
					Tile** _tmp54_ = NULL;
					Tile** _tmp55_;
					gint _tmp55__length1;
					_tmp50_ = player_get_turn_action (self->priv->players[self->priv->current_player]);
					_tmp51_ = turn_action_get_kan_tiles (_tmp50_, &_tmp52_);
					_tmp54_ = tile_ints_to_tiles (self->priv->tiles, self->priv->tiles_length1, _tmp51_, _tmp52_, &_tmp53_);
					_tmp55_ = _tmp54_;
					_tmp55__length1 = _tmp53_;
					player_do_closed_kan (self->priv->players[self->priv->current_player], _tmp55_, _tmp53_);
					_tmp55_ = (_vala_array_free (_tmp55_, _tmp55__length1, (GDestroyNotify) g_object_unref), NULL);
					game_draw_dead_wall (self);
					player_turn_decision (self->priv->players[self->priv->current_player]);
					break;
				}
				case TURN_ACTION_TURN_ACTION_ENUM_LATE_KAN:
				{
					TurnAction* _tmp56_ = NULL;
					guint8* _tmp57_ = NULL;
					GeeArrayList* _tmp58_ = NULL;
					TurnAction* _tmp59_ = NULL;
					guint8* _tmp60_ = NULL;
					gpointer _tmp61_ = NULL;
					Pon* _tmp62_;
					_tmp56_ = player_get_turn_action (self->priv->players[self->priv->current_player]);
					_tmp57_ = turn_action_get_late_kan_tile (_tmp56_);
					_tmp58_ = player_get_pons (self->priv->players[self->priv->current_player]);
					_tmp59_ = player_get_turn_action (self->priv->players[self->priv->current_player]);
					_tmp60_ = turn_action_get_late_kan_pon (_tmp59_);
					_tmp61_ = gee_abstract_list_get ((GeeAbstractList*) _tmp58_, (gint) (*_tmp60_));
					_tmp62_ = (Pon*) _tmp61_;
					player_do_late_kan (self->priv->players[self->priv->current_player], self->priv->tiles[(gint) (*_tmp57_)], _tmp62_);
					_call_unref0 (_tmp62_);
					game_draw_dead_wall (self);
					player_turn_decision (self->priv->players[self->priv->current_player]);
					break;
				}
				case TURN_ACTION_TURN_ACTION_ENUM_RIICHI:
				{
					TurnAction* _tmp63_ = NULL;
					TurnActionTurnActionEnum _tmp64_;
					TurnAction* _tmp65_ = NULL;
					guint8* _tmp66_ = NULL;
					TurnAction* _tmp67_ = NULL;
					guint8* _tmp68_ = NULL;
					_tmp63_ = player_get_turn_action (self->priv->players[self->priv->current_player]);
					_tmp64_ = turn_action_get_action (_tmp63_);
					_tmp65_ = player_get_turn_action (self->priv->players[self->priv->current_player]);
					_tmp66_ = turn_action_get_discard_tile (_tmp65_);
					player_do_riichi (self->priv->players[self->priv->current_player], _tmp64_ == TURN_ACTION_TURN_ACTION_ENUM_OPEN_RIICHI, self->priv->game_turn, self->priv->tiles[(gint) (*_tmp66_)]);
					_tmp67_ = player_get_turn_action (self->priv->players[self->priv->current_player]);
					_tmp68_ = turn_action_get_discard_tile (_tmp67_);
					game_discard_tile (self, self->priv->tiles[(gint) (*_tmp68_)]);
					break;
				}
				case TURN_ACTION_TURN_ACTION_ENUM_TSUMO:
				{
					player_do_tsumo (self->priv->players[self->priv->current_player]);
					self->priv->state = GAME_GAME_STATE_FINISHED;
					game_toggle_interface (self, FALSE);
					break;
				}
				default:
				break;
			}
		}
	}
}


static void game_flip_dora (Game* self) {
	gint _tmp0_;
	gint _tmp1_;
	gint tile;
	gpointer _tmp2_ = NULL;
	Tile* _tmp3_;
	Vector* _tmp4_ = NULL;
	gfloat _tmp5_;
	gboolean _tmp6_;
	gpointer _tmp21_ = NULL;
	Tile* _tmp22_;
	Vector* _tmp23_ = NULL;
	gpointer _tmp24_ = NULL;
	Tile* _tmp25_;
	Vector* _tmp26_ = NULL;
	gfloat _tmp27_;
	gpointer _tmp28_ = NULL;
	Tile* _tmp29_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gee_collection_get_size ((GeeCollection*) self->priv->dora_tiles);
	if (_tmp0_ >= 5) {
		return;
	}
	_tmp1_ = gee_collection_get_size ((GeeCollection*) self->priv->dora_tiles);
	tile = 5 + _tmp1_;
	_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->dead_wall, tile);
	_tmp3_ = (Tile*) _tmp2_;
	_tmp4_ = tile_get_rotation (_tmp3_);
	_tmp5_ = vector_get_z (_tmp4_);
	_tmp6_ = fmodf (_tmp5_, 180) == 0;
	_g_object_unref0 (_tmp3_);
	if (_tmp6_) {
		gpointer _tmp7_ = NULL;
		Tile* _tmp8_;
		Vector* _tmp9_ = NULL;
		gpointer _tmp10_ = NULL;
		Tile* _tmp11_;
		Vector* _tmp12_ = NULL;
		gfloat _tmp13_;
		_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->dead_wall, tile);
		_tmp8_ = (Tile*) _tmp7_;
		_tmp9_ = tile_get_rotation (_tmp8_);
		_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->dead_wall, tile);
		_tmp11_ = (Tile*) _tmp10_;
		_tmp12_ = tile_get_rotation (_tmp11_);
		_tmp13_ = vector_get_y (_tmp12_);
		vector_set_y (_tmp12_, _tmp13_ + ((gfloat) 180));
		_g_object_unref0 (_tmp11_);
		_g_object_unref0 (_tmp8_);
	} else {
		gpointer _tmp14_ = NULL;
		Tile* _tmp15_;
		Vector* _tmp16_ = NULL;
		gpointer _tmp17_ = NULL;
		Tile* _tmp18_;
		Vector* _tmp19_ = NULL;
		gfloat _tmp20_;
		_tmp14_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->dead_wall, tile);
		_tmp15_ = (Tile*) _tmp14_;
		_tmp16_ = tile_get_rotation (_tmp15_);
		_tmp17_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->dead_wall, tile);
		_tmp18_ = (Tile*) _tmp17_;
		_tmp19_ = tile_get_rotation (_tmp18_);
		_tmp20_ = vector_get_x (_tmp19_);
		vector_set_x (_tmp19_, _tmp20_ + ((gfloat) 180));
		_g_object_unref0 (_tmp18_);
		_g_object_unref0 (_tmp15_);
	}
	_tmp21_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->dead_wall, tile);
	_tmp22_ = (Tile*) _tmp21_;
	_tmp23_ = tile_get_position (_tmp22_);
	_tmp24_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->dead_wall, tile);
	_tmp25_ = (Tile*) _tmp24_;
	_tmp26_ = tile_get_position (_tmp25_);
	_tmp27_ = vector_get_z (_tmp26_);
	vector_set_z (_tmp26_, _tmp27_ - TILE_TILE_LENGTH);
	_g_object_unref0 (_tmp25_);
	_g_object_unref0 (_tmp22_);
	_tmp28_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->dead_wall, tile);
	_tmp29_ = (Tile*) _tmp28_;
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->dora_tiles, _tmp29_);
	_g_object_unref0 (_tmp29_);
}


static void game_draw_tile (Game* self) {
	gint _tmp0_;
	gint _tmp1_;
	gpointer _tmp2_ = NULL;
	Tile* t;
	g_return_if_fail (self != NULL);
	_tmp0_ = gee_collection_get_size ((GeeCollection*) self->priv->wall_tiles);
	if ((_tmp0_ - self->priv->kan_count) <= 0) {
		return;
	}
	_tmp1_ = gee_collection_get_size ((GeeCollection*) self->priv->wall_tiles);
	self->priv->drawing_tile = self->priv->drawing_tile % _tmp1_;
	_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->wall_tiles, self->priv->drawing_tile);
	t = (Tile*) _tmp2_;
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->wall_tiles, t);
	player_draw_tile (self->priv->players[self->priv->current_player], t);
	_g_object_unref0 (t);
}


static void game_draw_dead_wall (Game* self) {
	gpointer _tmp0_ = NULL;
	Tile* t;
	g_return_if_fail (self != NULL);
	if (self->priv->kan_count >= 4) {
		return;
	}
	_tmp0_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->dead_wall, 1 - (self->priv->kan_count % 2));
	t = (Tile*) _tmp0_;
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->dead_wall, t);
	player_draw_tile (self->priv->players[self->priv->current_player], t);
	self->priv->kan_count++;
	game_flip_dora (self);
	_g_object_unref0 (t);
}


static void game_game_start (Game* self) {
	g_return_if_fail (self != NULL);
	self->priv->state = GAME_GAME_STATE_WAITING_TURN;
	game_draw_tile (self);
	player_turn_decision (self->priv->players[self->priv->current_player]);
}


static void game_discard_tile (Game* self, Tile* t) {
	Tile* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (t != NULL);
	_tmp0_ = _g_object_ref0 (t);
	_g_object_unref0 (self->priv->last_played_tile);
	self->priv->last_played_tile = _tmp0_;
	self->priv->state = GAME_GAME_STATE_WAITING_CALLS;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_ = FALSE;
				gboolean _tmp3_;
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < 4)) {
					break;
				}
				if (i == self->priv->current_player) {
					continue;
				}
				_tmp3_ = player_call_decision (self->priv->players[i], t, i == ((self->priv->current_player + 1) % 4));
				if (_tmp3_) {
					_tmp2_ = i == self->priv->player_seat;
				} else {
					_tmp2_ = FALSE;
				}
				if (_tmp2_) {
					game_toggle_interface (self, TRUE);
				}
			}
		}
	}
}


static void game_dead_wall_split (Game* self, gint player, gint number) {
	gint start;
	gint end;
	gfloat shift;
	gint a;
	g_return_if_fail (self != NULL);
	player = player % 4;
	number = number % 13;
	start = 34 * player;
	end = start + (number * 2);
	shift = TILE_TILE_SPACING * 10;
	a = 0;
	{
		gint i;
		i = end - 1;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp1_ = 0;
				gfloat offset;
				if (!_tmp0_) {
					i--;
				}
				_tmp0_ = FALSE;
				if (!(i >= start)) {
					break;
				}
				if (a < 14) {
					_tmp1_ = 1;
				} else {
					_tmp1_ = 2;
				}
				offset = shift * _tmp1_;
				if (player == self->priv->player_seat) {
					Vector* _tmp2_ = NULL;
					Vector* _tmp3_ = NULL;
					gfloat _tmp4_;
					_tmp2_ = tile_get_position (self->priv->game_tiles[i]);
					_tmp3_ = tile_get_position (self->priv->game_tiles[i]);
					_tmp4_ = vector_get_x (_tmp3_);
					vector_set_x (_tmp3_, _tmp4_ - offset);
				} else {
					if (player == 1) {
						Vector* _tmp5_ = NULL;
						Vector* _tmp6_ = NULL;
						gfloat _tmp7_;
						_tmp5_ = tile_get_position (self->priv->game_tiles[i]);
						_tmp6_ = tile_get_position (self->priv->game_tiles[i]);
						_tmp7_ = vector_get_y (_tmp6_);
						vector_set_y (_tmp6_, _tmp7_ + offset);
					} else {
						if (player == 2) {
							Vector* _tmp8_ = NULL;
							Vector* _tmp9_ = NULL;
							gfloat _tmp10_;
							_tmp8_ = tile_get_position (self->priv->game_tiles[i]);
							_tmp9_ = tile_get_position (self->priv->game_tiles[i]);
							_tmp10_ = vector_get_x (_tmp9_);
							vector_set_x (_tmp9_, _tmp10_ + offset);
						} else {
							Vector* _tmp11_ = NULL;
							Vector* _tmp12_ = NULL;
							gfloat _tmp13_;
							_tmp11_ = tile_get_position (self->priv->game_tiles[i]);
							_tmp12_ = tile_get_position (self->priv->game_tiles[i]);
							_tmp13_ = vector_get_y (_tmp12_);
							vector_set_y (_tmp12_, _tmp13_ - offset);
						}
					}
				}
				if (a < 14) {
					gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->dead_wall, self->priv->game_tiles[i]);
					gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->wall_tiles, self->priv->game_tiles[i]);
				}
				a++;
			}
		}
	}
	start = ((start - ((7 - number) * 2)) + 136) % 136;
	end = start + ((7 - number) * 2);
	{
		gint i;
		i = end - 1;
		{
			gboolean _tmp14_;
			_tmp14_ = TRUE;
			while (TRUE) {
				if (!_tmp14_) {
					i--;
				}
				_tmp14_ = FALSE;
				if (!(i >= start)) {
					break;
				}
				if (player == 0) {
					Vector* _tmp15_ = NULL;
					Vector* _tmp16_ = NULL;
					gfloat _tmp17_;
					_tmp15_ = tile_get_position (self->priv->game_tiles[i]);
					_tmp16_ = tile_get_position (self->priv->game_tiles[i]);
					_tmp17_ = vector_get_y (_tmp16_);
					vector_set_y (_tmp16_, _tmp17_ + shift);
				} else {
					if (player == 1) {
						Vector* _tmp18_ = NULL;
						Vector* _tmp19_ = NULL;
						gfloat _tmp20_;
						_tmp18_ = tile_get_position (self->priv->game_tiles[i]);
						_tmp19_ = tile_get_position (self->priv->game_tiles[i]);
						_tmp20_ = vector_get_x (_tmp19_);
						vector_set_x (_tmp19_, _tmp20_ + shift);
					} else {
						if (player == 2) {
							Vector* _tmp21_ = NULL;
							Vector* _tmp22_ = NULL;
							gfloat _tmp23_;
							_tmp21_ = tile_get_position (self->priv->game_tiles[i]);
							_tmp22_ = tile_get_position (self->priv->game_tiles[i]);
							_tmp23_ = vector_get_y (_tmp22_);
							vector_set_y (_tmp22_, _tmp23_ - shift);
						} else {
							Vector* _tmp24_ = NULL;
							Vector* _tmp25_ = NULL;
							gfloat _tmp26_;
							_tmp24_ = tile_get_position (self->priv->game_tiles[i]);
							_tmp25_ = tile_get_position (self->priv->game_tiles[i]);
							_tmp26_ = vector_get_x (_tmp25_);
							vector_set_x (_tmp25_, _tmp26_ - shift);
						}
					}
				}
				gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->dead_wall, self->priv->game_tiles[i]);
				gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->wall_tiles, self->priv->game_tiles[i]);
			}
		}
	}
}


void game_render (Game* self) {
	g_return_if_fail (self != NULL);
	glRotated ((-((GLdouble) self->priv->player_seat)) * 90, (GLdouble) 0, (GLdouble) 0, (GLdouble) 1);
	board_render (self->priv->board);
	{
		Player** p_collection;
		int p_collection_length1;
		int p_it;
		p_collection = self->priv->players;
		p_collection_length1 = self->priv->players_length1;
		for (p_it = 0; p_it < self->priv->players_length1; p_it = p_it + 1) {
			Player* _tmp0_;
			Player* p;
			_tmp0_ = _g_object_ref0 (p_collection[p_it]);
			p = _tmp0_;
			{
				player_render (p);
				_g_object_unref0 (p);
			}
		}
	}
	{
		GeeArrayList* _tmp1_;
		GeeArrayList* _t_list;
		gint _tmp2_;
		gint _t_size;
		gint _t_index;
		_tmp1_ = _g_object_ref0 (self->priv->wall_tiles);
		_t_list = _tmp1_;
		_tmp2_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp2_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp3_ = NULL;
			Tile* t;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp3_;
			tile_render (t);
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	{
		GeeArrayList* _tmp4_;
		GeeArrayList* _t_list;
		gint _tmp5_;
		gint _t_size;
		gint _t_index;
		_tmp4_ = _g_object_ref0 (self->priv->dead_wall);
		_t_list = _tmp4_;
		_tmp5_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp5_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp6_ = NULL;
			Tile* t;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp6_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp6_;
			tile_render (t);
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
}


void game_render_selection (Game* self) {
	g_return_if_fail (self != NULL);
	glRotated ((-((GLdouble) self->priv->player_seat)) * 90, (GLdouble) 0, (GLdouble) 0, (GLdouble) 1);
	{
		Player** p_collection;
		int p_collection_length1;
		int p_it;
		p_collection = self->priv->players;
		p_collection_length1 = self->priv->players_length1;
		for (p_it = 0; p_it < self->priv->players_length1; p_it = p_it + 1) {
			Player* _tmp0_;
			Player* p;
			_tmp0_ = _g_object_ref0 (p_collection[p_it]);
			p = _tmp0_;
			{
				player_render_selection (p);
				_g_object_unref0 (p);
			}
		}
	}
}


void game_render_interface (Game* self) {
	g_return_if_fail (self != NULL);
	game_interface_render (self->priv->ui);
}


void game_render_interface_selection (Game* self) {
	g_return_if_fail (self != NULL);
	game_interface_render_selection (self->priv->ui);
}


static void game_toggle_interface (Game* self, gboolean show) {
	gboolean _tmp0_;
	Player* _tmp1_;
	Player* p;
	g_return_if_fail (self != NULL);
	_tmp0_ = show;
	game_interface_set_visible (self->priv->ui, _tmp0_);
	if (!_tmp0_) {
		return;
	}
	_tmp1_ = _g_object_ref0 (self->priv->players[self->priv->player_seat]);
	p = _tmp1_;
	if (self->priv->state == GAME_GAME_STATE_WAITING_CALLS) {
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_;
		gboolean _tmp6_ = FALSE;
		gboolean _tmp7_;
		gboolean _tmp10_ = FALSE;
		gboolean _tmp11_;
		GeeArrayList* _tmp16_ = NULL;
		gboolean _tmp17_;
		_tmp3_ = player_get_in_riichi (p);
		if (!_tmp3_) {
			GeeArrayList* _tmp4_ = NULL;
			gboolean _tmp5_;
			_tmp4_ = player_get_hand (p);
			_tmp5_ = logic_can_pon (self->priv->last_played_tile, _tmp4_);
			_tmp2_ = _tmp5_;
		} else {
			_tmp2_ = FALSE;
		}
		game_interface_set_show_pon (self->priv->ui, _tmp2_);
		_tmp7_ = player_get_in_riichi (p);
		if (!_tmp7_) {
			GeeArrayList* _tmp8_ = NULL;
			gboolean _tmp9_;
			_tmp8_ = player_get_hand (p);
			_tmp9_ = logic_can_open_kan (self->priv->last_played_tile, _tmp8_);
			_tmp6_ = _tmp9_;
		} else {
			_tmp6_ = FALSE;
		}
		game_interface_set_show_kan (self->priv->ui, _tmp6_);
		_tmp11_ = player_get_in_riichi (p);
		if (!_tmp11_) {
			gboolean _tmp12_ = FALSE;
			gint _tmp13_;
			_tmp13_ = player_get_position (p);
			if (_tmp13_ == ((self->priv->current_player + 1) % 4)) {
				GeeArrayList* _tmp14_ = NULL;
				gboolean _tmp15_;
				_tmp14_ = player_get_hand (p);
				_tmp15_ = logic_can_chi (self->priv->last_played_tile, _tmp14_);
				_tmp12_ = _tmp15_;
			} else {
				_tmp12_ = FALSE;
			}
			_tmp10_ = _tmp12_;
		} else {
			_tmp10_ = FALSE;
		}
		game_interface_set_show_chi (self->priv->ui, _tmp10_);
		game_interface_set_show_riichi (self->priv->ui, FALSE);
		game_interface_set_show_tsumo (self->priv->ui, FALSE);
		_tmp16_ = player_get_hand (p);
		_tmp17_ = logic_can_win_with (_tmp16_, self->priv->last_played_tile);
		game_interface_set_show_ron (self->priv->ui, _tmp17_);
	} else {
		gboolean _tmp18_;
		gboolean _tmp27_ = FALSE;
		gboolean _tmp28_ = FALSE;
		gboolean _tmp29_;
		GeeArrayList* _tmp35_ = NULL;
		gboolean _tmp36_;
		game_interface_set_show_pon (self->priv->ui, FALSE);
		_tmp18_ = player_get_in_riichi (p);
		if (_tmp18_) {
			GeeArrayList* _tmp19_ = NULL;
			gboolean _tmp20_;
			_tmp19_ = player_get_hand (p);
			_tmp20_ = logic_can_riichi_closed_kan (_tmp19_);
			game_interface_set_show_kan (self->priv->ui, _tmp20_);
		} else {
			gboolean _tmp21_ = FALSE;
			GeeArrayList* _tmp22_ = NULL;
			gboolean _tmp23_;
			_tmp22_ = player_get_hand (p);
			_tmp23_ = logic_can_closed_kan (_tmp22_);
			if (_tmp23_) {
				_tmp21_ = TRUE;
			} else {
				GeeArrayList* _tmp24_ = NULL;
				GeeArrayList* _tmp25_ = NULL;
				gboolean _tmp26_;
				_tmp24_ = player_get_hand (p);
				_tmp25_ = player_get_pons (p);
				_tmp26_ = logic_can_late_kan (_tmp24_, _tmp25_);
				_tmp21_ = _tmp26_;
			}
			game_interface_set_show_kan (self->priv->ui, _tmp21_);
		}
		game_interface_set_show_chi (self->priv->ui, FALSE);
		_tmp29_ = player_get_open_hand (p);
		if (!_tmp29_) {
			gboolean _tmp30_;
			_tmp30_ = player_get_in_riichi (p);
			_tmp28_ = !_tmp30_;
		} else {
			_tmp28_ = FALSE;
		}
		if (_tmp28_) {
			GeeArrayList* _tmp31_ = NULL;
			GeeArrayList* _tmp32_ = NULL;
			GeeArrayList* _tmp33_;
			gint _tmp34_;
			_tmp31_ = player_get_hand (p);
			_tmp32_ = logic_can_tenpai (_tmp31_);
			_tmp33_ = _tmp32_;
			_tmp34_ = gee_collection_get_size ((GeeCollection*) _tmp33_);
			_tmp27_ = _tmp34_ != 0;
			_g_object_unref0 (_tmp33_);
		} else {
			_tmp27_ = FALSE;
		}
		game_interface_set_show_riichi (self->priv->ui, _tmp27_);
		_tmp35_ = player_get_hand (p);
		_tmp36_ = logic_winning_hand (_tmp35_);
		game_interface_set_show_tsumo (self->priv->ui, _tmp36_);
		game_interface_set_show_ron (self->priv->ui, FALSE);
	}
	_g_object_unref0 (p);
}


void game_mouse_click (Game* self, gint x, gint y, guint color_id, gboolean mouse_state) {
	Player* _tmp0_;
	Player* player;
	Button* _tmp1_ = NULL;
	Button* button;
	Tile* _tmp14_ = NULL;
	Tile* t;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (self->priv->players[self->priv->player_seat]);
	player = _tmp0_;
	_tmp1_ = game_interface_click (self->priv->ui, x, y, color_id, mouse_state);
	button = _tmp1_;
	if (button != NULL) {
		const gchar* _tmp2_ = NULL;
		const gchar* _tmp3_;
		GQuark _tmp4_;
		static GQuark _tmp4__label0 = 0;
		static GQuark _tmp4__label1 = 0;
		static GQuark _tmp4__label2 = 0;
		static GQuark _tmp4__label3 = 0;
		static GQuark _tmp4__label4 = 0;
		static GQuark _tmp4__label5 = 0;
		static GQuark _tmp4__label6 = 0;
		_tmp2_ = button_get_name (button);
		_tmp3_ = _tmp2_;
		_tmp4_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
		if (_tmp4_ == ((0 != _tmp4__label0) ? _tmp4__label0 : (_tmp4__label0 = g_quark_from_static_string ("Continue")))) {
			switch (0) {
				default:
				{
					game_do_continue (self);
					game_toggle_interface (self, FALSE);
					break;
				}
			}
		} else if (_tmp4_ == ((0 != _tmp4__label1) ? _tmp4__label1 : (_tmp4__label1 = g_quark_from_static_string ("Pon")))) {
			switch (0) {
				default:
				{
					game_do_pon (self);
					game_toggle_interface (self, FALSE);
					break;
				}
			}
		} else if (_tmp4_ == ((0 != _tmp4__label2) ? _tmp4__label2 : (_tmp4__label2 = g_quark_from_static_string ("Kan")))) {
			switch (0) {
				default:
				{
					if (self->priv->state == GAME_GAME_STATE_WAITING_CALLS) {
						game_do_open_kan (self);
						game_toggle_interface (self, FALSE);
					} else {
						game_do_closed_or_late_kan (self);
					}
					break;
				}
			}
		} else if (_tmp4_ == ((0 != _tmp4__label3) ? _tmp4__label3 : (_tmp4__label3 = g_quark_from_static_string ("Chi")))) {
			switch (0) {
				default:
				{
					game_do_chi (self);
					break;
				}
			}
		} else if (_tmp4_ == ((0 != _tmp4__label4) ? _tmp4__label4 : (_tmp4__label4 = g_quark_from_static_string ("Riichi")))) {
			switch (0) {
				default:
				{
					self->priv->state = GAME_GAME_STATE_WAITING_RIICHI_DISCARD;
					break;
				}
			}
		} else if (_tmp4_ == ((0 != _tmp4__label5) ? _tmp4__label5 : (_tmp4__label5 = g_quark_from_static_string ("Tsumo")))) {
			switch (0) {
				default:
				{
					gint _tmp5_;
					gboolean _tmp6_;
					_tmp5_ = gee_collection_get_size ((GeeCollection*) self->priv->wall_tiles);
					_tmp6_ = logic_has_yaku (player, NULL, (_tmp5_ - self->priv->kan_count) == 0, FALSE);
					if (_tmp6_) {
						TurnAction* _tmp7_ = NULL;
						TurnAction* _tmp8_;
						_tmp7_ = turn_action_new_tsumo ();
						_tmp8_ = _tmp7_;
						player_set_turn_action (player, _tmp8_);
						_turn_action_unref0 (_tmp8_);
						player_set_state (player, PLAYER_PLAYER_STATE_READY);
					} else {
					}
					break;
				}
			}
		} else if (_tmp4_ == ((0 != _tmp4__label6) ? _tmp4__label6 : (_tmp4__label6 = g_quark_from_static_string ("Ron")))) {
			switch (0) {
				default:
				{
					gint _tmp9_;
					gboolean _tmp10_;
					_tmp9_ = gee_collection_get_size ((GeeCollection*) self->priv->wall_tiles);
					_tmp10_ = logic_has_yaku (player, NULL, (_tmp9_ - self->priv->kan_count) == 0, FALSE);
					if (_tmp10_) {
						guint8 _tmp11_;
						CallAction* _tmp12_ = NULL;
						CallAction* _tmp13_;
						_tmp11_ = tile_get_id (self->priv->last_played_tile);
						_tmp12_ = call_action_new_ron (_tmp11_);
						_tmp13_ = _tmp12_;
						player_set_call_action (player, _tmp13_);
						_call_action_unref0 (_tmp13_);
						player_set_state (player, PLAYER_PLAYER_STATE_READY);
					}
					break;
				}
			}
		}
		_button_unref0 (button);
		_g_object_unref0 (player);
		return;
	}
	if (!mouse_state) {
		_button_unref0 (button);
		_g_object_unref0 (player);
		return;
	}
	_tmp14_ = player_tile_press (player, color_id);
	t = _tmp14_;
	if (t == NULL) {
		_g_object_unref0 (t);
		_button_unref0 (button);
		_g_object_unref0 (player);
		return;
	}
	tile_set_hovering (t, FALSE);
	if (self->priv->state == GAME_GAME_STATE_WAITING_TURN) {
		guint8 _tmp15_;
		TurnAction* _tmp16_ = NULL;
		TurnAction* _tmp17_;
		_tmp15_ = tile_get_id (t);
		_tmp16_ = turn_action_new_discard (_tmp15_);
		_tmp17_ = _tmp16_;
		player_set_turn_action (player, _tmp17_);
		_turn_action_unref0 (_tmp17_);
		player_set_state (player, PLAYER_PLAYER_STATE_READY);
		game_toggle_interface (self, FALSE);
	} else {
		if (self->priv->state == GAME_GAME_STATE_WAITING_CHI) {
			GeeArrayList* _tmp18_ = NULL;
			Tile* _tmp19_ = NULL;
			Tile* tile;
			_tmp18_ = player_get_hand (player);
			_tmp19_ = logic_chi_combination (self->priv->last_played_tile, t, _tmp18_);
			tile = _tmp19_;
			if (tile != NULL) {
				Tile* _tmp20_;
				Tile* _tmp21_;
				Tile** _tmp22_ = NULL;
				Tile** _tmp23_;
				gint _tmp23__length1;
				gint _tmp24_;
				guint8* _tmp25_ = NULL;
				guint8* _tmp26_;
				gint _tmp26__length1;
				CallAction* _tmp27_ = NULL;
				CallAction* _tmp28_;
				_tmp20_ = _g_object_ref0 (t);
				_tmp21_ = _g_object_ref0 (tile);
				_tmp22_ = g_new0 (Tile*, 2 + 1);
				_tmp22_[0] = _tmp20_;
				_tmp22_[1] = _tmp21_;
				_tmp23_ = _tmp22_;
				_tmp23__length1 = 2;
				_tmp25_ = tile_tiles_to_ints (_tmp23_, 2, &_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp26__length1 = _tmp24_;
				_tmp27_ = call_action_new (CALL_ACTION_CALL_ACTION_ENUM_CHI, _tmp26_, _tmp24_);
				_tmp28_ = _tmp27_;
				player_set_call_action (player, _tmp28_);
				_call_action_unref0 (_tmp28_);
				_tmp26_ = (g_free (_tmp26_), NULL);
				_tmp23_ = (_vala_array_free (_tmp23_, _tmp23__length1, (GDestroyNotify) g_object_unref), NULL);
				player_set_state (player, PLAYER_PLAYER_STATE_READY);
				self->priv->state = GAME_GAME_STATE_WAITING_CALLS;
				game_toggle_interface (self, FALSE);
			}
			_g_object_unref0 (tile);
		} else {
			if (self->priv->state == GAME_GAME_STATE_WAITING_CLOSED_OR_LATE_KAN) {
				Tile** _tmp43_ = NULL;
				Tile** tiles;
				gint tiles_length1;
				gint _tiles_size_;
				gint count;
				{
					guint8 p;
					p = (guint8) 0;
					{
						gboolean _tmp29_;
						_tmp29_ = TRUE;
						while (TRUE) {
							GeeArrayList* _tmp30_ = NULL;
							gint _tmp31_;
							gint _tmp32_;
							GeeArrayList* _tmp33_ = NULL;
							gpointer _tmp34_ = NULL;
							Pon* _tmp35_;
							Tile** _tmp36_ = NULL;
							gint _tmp37_;
							gint _tmp38_;
							gboolean _tmp39_;
							if (!_tmp29_) {
								p++;
							}
							_tmp29_ = FALSE;
							_tmp30_ = player_get_pons (player);
							_tmp31_ = gee_collection_get_size ((GeeCollection*) _tmp30_);
							if (!(p < _tmp31_)) {
								break;
							}
							_tmp32_ = tile_get_tile_type (t);
							_tmp33_ = player_get_pons (player);
							_tmp34_ = gee_abstract_list_get ((GeeAbstractList*) _tmp33_, (gint) p);
							_tmp35_ = (Pon*) _tmp34_;
							_tmp36_ = call_get_tiles ((Call*) _tmp35_, &_tmp37_);
							_tmp38_ = tile_get_tile_type (_tmp36_[0]);
							_tmp39_ = _tmp32_ == _tmp38_;
							_call_unref0 (_tmp35_);
							if (_tmp39_) {
								guint8 _tmp40_;
								TurnAction* _tmp41_ = NULL;
								TurnAction* _tmp42_;
								_tmp40_ = tile_get_id (t);
								_tmp41_ = turn_action_new_late_kan (_tmp40_, p);
								_tmp42_ = _tmp41_;
								player_set_turn_action (player, _tmp42_);
								_turn_action_unref0 (_tmp42_);
								player_set_state (player, PLAYER_PLAYER_STATE_READY);
								game_toggle_interface (self, FALSE);
							}
						}
					}
				}
				_tmp43_ = g_new0 (Tile*, 4 + 1);
				tiles = _tmp43_;
				tiles_length1 = 4;
				_tiles_size_ = 4;
				count = 0;
				{
					GeeArrayList* _tmp44_ = NULL;
					GeeArrayList* _tmp45_;
					GeeArrayList* _tile_list;
					gint _tmp46_;
					gint _tile_size;
					gint _tile_index;
					_tmp44_ = player_get_hand (player);
					_tmp45_ = _g_object_ref0 (_tmp44_);
					_tile_list = _tmp45_;
					_tmp46_ = gee_collection_get_size ((GeeCollection*) _tile_list);
					_tile_size = _tmp46_;
					_tile_index = -1;
					while (TRUE) {
						gpointer _tmp47_ = NULL;
						Tile* tile;
						gint _tmp48_;
						gint _tmp49_;
						_tile_index = _tile_index + 1;
						if (!(_tile_index < _tile_size)) {
							break;
						}
						_tmp47_ = gee_abstract_list_get ((GeeAbstractList*) _tile_list, _tile_index);
						tile = (Tile*) _tmp47_;
						_tmp48_ = tile_get_tile_type (t);
						_tmp49_ = tile_get_tile_type (tile);
						if (_tmp48_ == _tmp49_) {
							gint _tmp50_;
							Tile* _tmp51_;
							Tile* _tmp52_;
							_tmp50_ = count;
							count = _tmp50_ + 1;
							_tmp51_ = _g_object_ref0 (tile);
							_tmp52_ = _tmp51_;
							_g_object_unref0 (tiles[_tmp50_]);
							tiles[_tmp50_] = _tmp52_;
							if (count == 4) {
								gint _tmp53_;
								guint8* _tmp54_ = NULL;
								guint8* _tmp55_;
								gint _tmp55__length1;
								TurnAction* _tmp56_ = NULL;
								TurnAction* _tmp57_;
								_tmp54_ = tile_tiles_to_ints (tiles, tiles_length1, &_tmp53_);
								_tmp55_ = _tmp54_;
								_tmp55__length1 = _tmp53_;
								_tmp56_ = turn_action_new_closed_kan (_tmp55_, _tmp53_);
								_tmp57_ = _tmp56_;
								player_set_turn_action (player, _tmp57_);
								_turn_action_unref0 (_tmp57_);
								_tmp55_ = (g_free (_tmp55_), NULL);
								player_set_state (player, PLAYER_PLAYER_STATE_READY);
								game_toggle_interface (self, FALSE);
							}
						}
						_g_object_unref0 (tile);
					}
					_g_object_unref0 (_tile_list);
				}
				tiles = (_vala_array_free (tiles, tiles_length1, (GDestroyNotify) g_object_unref), NULL);
			} else {
				if (self->priv->state == GAME_GAME_STATE_WAITING_RIICHI_DISCARD) {
					guint8 _tmp58_;
					TurnAction* _tmp59_ = NULL;
					TurnAction* _tmp60_;
					_tmp58_ = tile_get_id (t);
					_tmp59_ = turn_action_new_riichi (_tmp58_);
					_tmp60_ = _tmp59_;
					player_set_turn_action (player, _tmp60_);
					_turn_action_unref0 (_tmp60_);
					player_set_state (player, PLAYER_PLAYER_STATE_READY);
					self->priv->state = GAME_GAME_STATE_WAITING_TURN;
					game_toggle_interface (self, FALSE);
				}
			}
		}
	}
	_g_object_unref0 (t);
	_button_unref0 (button);
	_g_object_unref0 (player);
}


void game_mouse_move (Game* self, gint x, gint y, guint color_id) {
	Player* _tmp0_;
	Player* player;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (self->priv->players[self->priv->player_seat]);
	player = _tmp0_;
	_tmp1_ = game_interface_hover (self->priv->ui, x, y, color_id);
	if (_tmp1_) {
		environment_set_cursor (ENVIRONMENT_CURSOR_TYPE_HOVER);
		player_clear_hover (player);
	} else {
		gboolean _tmp2_;
		_tmp2_ = player_hover (player, color_id);
		if (_tmp2_) {
			environment_set_cursor (ENVIRONMENT_CURSOR_TYPE_HOVER);
		} else {
			environment_set_cursor (ENVIRONMENT_CURSOR_TYPE_DEFAULT);
		}
	}
	_g_object_unref0 (player);
}


static void game_do_continue (Game* self) {
	Player* _tmp0_;
	Player* player;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (self->priv->players[self->priv->player_seat]);
	player = _tmp0_;
	if (self->priv->state == GAME_GAME_STATE_WAITING_CLOSED_OR_LATE_KAN) {
		self->priv->state = GAME_GAME_STATE_WAITING_TURN;
	} else {
		gboolean _tmp1_ = FALSE;
		gboolean _tmp2_ = FALSE;
		if (self->priv->state == GAME_GAME_STATE_WAITING_CHI) {
			_tmp2_ = TRUE;
		} else {
			_tmp2_ = self->priv->state == GAME_GAME_STATE_WAITING_CALLS;
		}
		if (_tmp2_) {
			_tmp1_ = TRUE;
		} else {
			_tmp1_ = self->priv->state == GAME_GAME_STATE_WAITING_RIICHI_DISCARD;
		}
		if (_tmp1_) {
			player_set_call_action (player, NULL);
			player_set_state (player, PLAYER_PLAYER_STATE_READY);
			self->priv->state = GAME_GAME_STATE_WAITING_CALLS;
		}
	}
	game_toggle_interface (self, FALSE);
	_g_object_unref0 (player);
}


static void game_do_open_kan (Game* self) {
	Player* _tmp0_;
	Player* player;
	Tile** _tmp1_ = NULL;
	Tile** tiles;
	gint tiles_length1;
	gint _tiles_size_;
	gint a;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (self->priv->players[self->priv->player_seat]);
	player = _tmp0_;
	_tmp1_ = g_new0 (Tile*, 3 + 1);
	tiles = _tmp1_;
	tiles_length1 = 3;
	_tiles_size_ = 3;
	a = 0;
	{
		GeeArrayList* _tmp2_ = NULL;
		GeeArrayList* _tmp3_;
		GeeArrayList* _t_list;
		gint _tmp4_;
		gint _t_size;
		gint _t_index;
		_tmp2_ = player_get_hand (player);
		_tmp3_ = _g_object_ref0 (_tmp2_);
		_t_list = _tmp3_;
		_tmp4_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp4_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp5_ = NULL;
			Tile* t;
			gint _tmp6_;
			gint _tmp7_;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp5_;
			_tmp6_ = tile_get_tile_type (t);
			_tmp7_ = tile_get_tile_type (self->priv->last_played_tile);
			if (_tmp6_ == _tmp7_) {
				gint _tmp8_;
				Tile* _tmp9_;
				Tile* _tmp10_;
				_tmp8_ = a;
				a = _tmp8_ + 1;
				_tmp9_ = _g_object_ref0 (t);
				_tmp10_ = _tmp9_;
				_g_object_unref0 (tiles[_tmp8_]);
				tiles[_tmp8_] = _tmp10_;
			}
			if (a == 3) {
				gint _tmp11_;
				guint8* _tmp12_ = NULL;
				guint8* _tmp13_;
				gint _tmp13__length1;
				CallAction* _tmp14_ = NULL;
				CallAction* _tmp15_;
				_tmp12_ = tile_tiles_to_ints (tiles, tiles_length1, &_tmp11_);
				_tmp13_ = _tmp12_;
				_tmp13__length1 = _tmp11_;
				_tmp14_ = call_action_new (CALL_ACTION_CALL_ACTION_ENUM_OPEN_KAN, _tmp13_, _tmp11_);
				_tmp15_ = _tmp14_;
				player_set_call_action (player, _tmp15_);
				_call_action_unref0 (_tmp15_);
				_tmp13_ = (g_free (_tmp13_), NULL);
				player_set_state (player, PLAYER_PLAYER_STATE_READY);
			}
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	tiles = (_vala_array_free (tiles, tiles_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (player);
}


static guint8* _uint8_dup (guint8* self) {
	guint8* dup;
	dup = g_new0 (guint8, 1);
	memcpy (dup, self, sizeof (guint8));
	return dup;
}


static gpointer __uint8_dup0 (gpointer self) {
	return self ? _uint8_dup (self) : NULL;
}


static Tile** _vala_array_dup6 (Tile** self, int length) {
	Tile** result;
	int i;
	result = g_new0 (Tile*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = _g_object_ref0 (self[i]);
	}
	return result;
}


static void game_do_closed_or_late_kan (Game* self) {
	Player* _tmp0_;
	Player* player;
	Tile* tile;
	guint8* pon;
	Tile** tiles;
	gint tiles_length1;
	gint _tiles_size_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (self->priv->players[self->priv->player_seat]);
	player = _tmp0_;
	tile = NULL;
	pon = NULL;
	{
		guint8 p;
		p = (guint8) 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				GeeArrayList* _tmp2_ = NULL;
				gint _tmp3_;
				if (!_tmp1_) {
					p++;
				}
				_tmp1_ = FALSE;
				_tmp2_ = player_get_pons (player);
				_tmp3_ = gee_collection_get_size ((GeeCollection*) _tmp2_);
				if (!(p < _tmp3_)) {
					break;
				}
				{
					GeeArrayList* _tmp4_ = NULL;
					GeeArrayList* _tmp5_;
					GeeArrayList* _t_list;
					gint _tmp6_;
					gint _t_size;
					gint _t_index;
					_tmp4_ = player_get_hand (player);
					_tmp5_ = _g_object_ref0 (_tmp4_);
					_t_list = _tmp5_;
					_tmp6_ = gee_collection_get_size ((GeeCollection*) _t_list);
					_t_size = _tmp6_;
					_t_index = -1;
					while (TRUE) {
						gpointer _tmp7_ = NULL;
						Tile* t;
						gint _tmp8_;
						GeeArrayList* _tmp9_ = NULL;
						gpointer _tmp10_ = NULL;
						Pon* _tmp11_;
						Tile** _tmp12_ = NULL;
						gint _tmp13_;
						gint _tmp14_;
						gboolean _tmp15_;
						_t_index = _t_index + 1;
						if (!(_t_index < _t_size)) {
							break;
						}
						_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
						t = (Tile*) _tmp7_;
						_tmp8_ = tile_get_tile_type (t);
						_tmp9_ = player_get_pons (player);
						_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp9_, (gint) p);
						_tmp11_ = (Pon*) _tmp10_;
						_tmp12_ = call_get_tiles ((Call*) _tmp11_, &_tmp13_);
						_tmp14_ = tile_get_tile_type (_tmp12_[0]);
						_tmp15_ = _tmp8_ == _tmp14_;
						_call_unref0 (_tmp11_);
						if (_tmp15_) {
							Tile* _tmp16_;
							guint8* _tmp17_;
							if (tile != NULL) {
								self->priv->state = GAME_GAME_STATE_WAITING_CLOSED_OR_LATE_KAN;
								_g_object_unref0 (t);
								_g_object_unref0 (_t_list);
								_g_free0 (pon);
								_g_object_unref0 (tile);
								_g_object_unref0 (player);
								return;
							}
							_tmp16_ = _g_object_ref0 (t);
							_g_object_unref0 (tile);
							tile = _tmp16_;
							_tmp17_ = __uint8_dup0 (&p);
							_g_free0 (pon);
							pon = _tmp17_;
							_g_object_unref0 (t);
							break;
						}
						_g_object_unref0 (t);
					}
					_g_object_unref0 (_t_list);
				}
			}
		}
	}
	tiles = NULL;
	tiles_length1 = 0;
	_tiles_size_ = 0;
	{
		GeeArrayList* _tmp18_ = NULL;
		GeeArrayList* _tmp19_;
		GeeArrayList* _t1_list;
		gint _tmp20_;
		gint _t1_size;
		gint _t1_index;
		_tmp18_ = player_get_hand (player);
		_tmp19_ = _g_object_ref0 (_tmp18_);
		_t1_list = _tmp19_;
		_tmp20_ = gee_collection_get_size ((GeeCollection*) _t1_list);
		_t1_size = _tmp20_;
		_t1_index = -1;
		while (TRUE) {
			gpointer _tmp21_ = NULL;
			Tile* t1;
			gboolean _tmp22_ = FALSE;
			gint count;
			Tile** _tmp25_ = NULL;
			Tile** temp;
			gint temp_length1;
			gint _temp_size_;
			_t1_index = _t1_index + 1;
			if (!(_t1_index < _t1_size)) {
				break;
			}
			_tmp21_ = gee_abstract_list_get ((GeeAbstractList*) _t1_list, _t1_index);
			t1 = (Tile*) _tmp21_;
			if (tiles != NULL) {
				gint _tmp23_;
				gint _tmp24_;
				_tmp23_ = tile_get_tile_type (tiles[0]);
				_tmp24_ = tile_get_tile_type (t1);
				_tmp22_ = _tmp23_ == _tmp24_;
			} else {
				_tmp22_ = FALSE;
			}
			if (_tmp22_) {
				_g_object_unref0 (t1);
				continue;
			}
			count = 0;
			_tmp25_ = g_new0 (Tile*, 4 + 1);
			temp = _tmp25_;
			temp_length1 = 4;
			_temp_size_ = 4;
			{
				GeeArrayList* _tmp26_ = NULL;
				GeeArrayList* _tmp27_;
				GeeArrayList* _t2_list;
				gint _tmp28_;
				gint _t2_size;
				gint _t2_index;
				_tmp26_ = player_get_hand (player);
				_tmp27_ = _g_object_ref0 (_tmp26_);
				_t2_list = _tmp27_;
				_tmp28_ = gee_collection_get_size ((GeeCollection*) _t2_list);
				_t2_size = _tmp28_;
				_t2_index = -1;
				while (TRUE) {
					gpointer _tmp29_ = NULL;
					Tile* t2;
					gint _tmp30_;
					gint _tmp31_;
					_t2_index = _t2_index + 1;
					if (!(_t2_index < _t2_size)) {
						break;
					}
					_tmp29_ = gee_abstract_list_get ((GeeAbstractList*) _t2_list, _t2_index);
					t2 = (Tile*) _tmp29_;
					_tmp30_ = tile_get_tile_type (t1);
					_tmp31_ = tile_get_tile_type (t2);
					if (_tmp30_ == _tmp31_) {
						gint _tmp32_;
						Tile* _tmp33_;
						Tile* _tmp34_;
						_tmp32_ = count;
						count = _tmp32_ + 1;
						_tmp33_ = _g_object_ref0 (t2);
						_tmp34_ = _tmp33_;
						_g_object_unref0 (temp[_tmp32_]);
						temp[_tmp32_] = _tmp34_;
						if (count == 4) {
							gboolean _tmp35_ = FALSE;
							Tile** _tmp36_;
							Tile** _tmp37_;
							if (tile != NULL) {
								_tmp35_ = TRUE;
							} else {
								_tmp35_ = tiles != NULL;
							}
							if (_tmp35_) {
								self->priv->state = GAME_GAME_STATE_WAITING_CLOSED_OR_LATE_KAN;
								_g_object_unref0 (t2);
								_g_object_unref0 (_t2_list);
								temp = (_vala_array_free (temp, temp_length1, (GDestroyNotify) g_object_unref), NULL);
								_g_object_unref0 (t1);
								_g_object_unref0 (_t1_list);
								tiles = (_vala_array_free (tiles, tiles_length1, (GDestroyNotify) g_object_unref), NULL);
								_g_free0 (pon);
								_g_object_unref0 (tile);
								_g_object_unref0 (player);
								return;
							}
							_tmp36_ = (_tmp37_ = temp, (_tmp37_ == NULL) ? ((gpointer) _tmp37_) : _vala_array_dup6 (_tmp37_, temp_length1));
							tiles = (_vala_array_free (tiles, tiles_length1, (GDestroyNotify) g_object_unref), NULL);
							tiles = _tmp36_;
							tiles_length1 = temp_length1;
							_tiles_size_ = temp_length1;
							_g_object_unref0 (t2);
							break;
						}
					}
					_g_object_unref0 (t2);
				}
				_g_object_unref0 (_t2_list);
			}
			temp = (_vala_array_free (temp, temp_length1, (GDestroyNotify) g_object_unref), NULL);
			_g_object_unref0 (t1);
		}
		_g_object_unref0 (_t1_list);
	}
	if (tile != NULL) {
		guint8 _tmp38_;
		TurnAction* _tmp39_ = NULL;
		TurnAction* _tmp40_;
		_tmp38_ = tile_get_id (tile);
		_tmp39_ = turn_action_new_late_kan (_tmp38_, *pon);
		_tmp40_ = _tmp39_;
		player_set_turn_action (player, _tmp40_);
		_turn_action_unref0 (_tmp40_);
	} else {
		gint _tmp41_;
		guint8* _tmp42_ = NULL;
		guint8* _tmp43_;
		gint _tmp43__length1;
		TurnAction* _tmp44_ = NULL;
		TurnAction* _tmp45_;
		_tmp42_ = tile_tiles_to_ints (tiles, tiles_length1, &_tmp41_);
		_tmp43_ = _tmp42_;
		_tmp43__length1 = _tmp41_;
		_tmp44_ = turn_action_new_closed_kan (_tmp43_, _tmp41_);
		_tmp45_ = _tmp44_;
		player_set_turn_action (player, _tmp45_);
		_turn_action_unref0 (_tmp45_);
		_tmp43_ = (g_free (_tmp43_), NULL);
	}
	player_set_state (player, PLAYER_PLAYER_STATE_READY);
	game_toggle_interface (self, FALSE);
	tiles = (_vala_array_free (tiles, tiles_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_free0 (pon);
	_g_object_unref0 (tile);
	_g_object_unref0 (player);
}


static void game_do_pon (Game* self) {
	Player* _tmp0_;
	Player* player;
	Tile** _tmp1_ = NULL;
	Tile** tiles;
	gint tiles_length1;
	gint _tiles_size_;
	gint a;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (self->priv->players[self->priv->player_seat]);
	player = _tmp0_;
	_tmp1_ = g_new0 (Tile*, 2 + 1);
	tiles = _tmp1_;
	tiles_length1 = 2;
	_tiles_size_ = 2;
	a = 0;
	{
		GeeArrayList* _tmp2_ = NULL;
		GeeArrayList* _tmp3_;
		GeeArrayList* _t_list;
		gint _tmp4_;
		gint _t_size;
		gint _t_index;
		_tmp2_ = player_get_hand (player);
		_tmp3_ = _g_object_ref0 (_tmp2_);
		_t_list = _tmp3_;
		_tmp4_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp4_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp5_ = NULL;
			Tile* t;
			gint _tmp6_;
			gint _tmp7_;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp5_;
			_tmp6_ = tile_get_tile_type (t);
			_tmp7_ = tile_get_tile_type (self->priv->last_played_tile);
			if (_tmp6_ == _tmp7_) {
				gint _tmp8_;
				Tile* _tmp9_;
				Tile* _tmp10_;
				_tmp8_ = a;
				a = _tmp8_ + 1;
				_tmp9_ = _g_object_ref0 (t);
				_tmp10_ = _tmp9_;
				_g_object_unref0 (tiles[_tmp8_]);
				tiles[_tmp8_] = _tmp10_;
			}
			if (a == 2) {
				gint _tmp11_;
				guint8* _tmp12_ = NULL;
				guint8* _tmp13_;
				gint _tmp13__length1;
				CallAction* _tmp14_ = NULL;
				CallAction* _tmp15_;
				_tmp12_ = tile_tiles_to_ints (tiles, tiles_length1, &_tmp11_);
				_tmp13_ = _tmp12_;
				_tmp13__length1 = _tmp11_;
				_tmp14_ = call_action_new (CALL_ACTION_CALL_ACTION_ENUM_PON, _tmp13_, _tmp11_);
				_tmp15_ = _tmp14_;
				player_set_call_action (player, _tmp15_);
				_call_action_unref0 (_tmp15_);
				_tmp13_ = (g_free (_tmp13_), NULL);
				player_set_state (player, PLAYER_PLAYER_STATE_READY);
			}
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	tiles = (_vala_array_free (tiles, tiles_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (player);
}


static void game_do_chi (Game* self) {
	Player* _tmp0_;
	Player* player;
	GeeArrayList* _tmp1_ = NULL;
	gint _tmp2_;
	Tile** _tmp3_ = NULL;
	Tile** tiles;
	gint tiles_length1;
	gint _tiles_size_;
	gint _tmp4_;
	guint8* _tmp5_ = NULL;
	guint8* _tmp6_;
	gint _tmp6__length1;
	CallAction* _tmp7_ = NULL;
	CallAction* _tmp8_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (self->priv->players[self->priv->player_seat]);
	player = _tmp0_;
	_tmp1_ = player_get_hand (player);
	_tmp3_ = logic_auto_chi (self->priv->last_played_tile, _tmp1_, &_tmp2_);
	tiles = _tmp3_;
	tiles_length1 = _tmp2_;
	_tiles_size_ = _tmp2_;
	if (tiles == NULL) {
		self->priv->state = GAME_GAME_STATE_WAITING_CHI;
		tiles = (_vala_array_free (tiles, tiles_length1, (GDestroyNotify) g_object_unref), NULL);
		_g_object_unref0 (player);
		return;
	}
	_tmp5_ = tile_tiles_to_ints (tiles, tiles_length1, &_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp6__length1 = _tmp4_;
	_tmp7_ = call_action_new (CALL_ACTION_CALL_ACTION_ENUM_CHI, _tmp6_, _tmp4_);
	_tmp8_ = _tmp7_;
	player_set_call_action (player, _tmp8_);
	_call_action_unref0 (_tmp8_);
	_tmp6_ = (g_free (_tmp6_), NULL);
	player_set_state (player, PLAYER_PLAYER_STATE_READY);
	game_toggle_interface (self, FALSE);
	tiles = (_vala_array_free (tiles, tiles_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (player);
}


static void value_game_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_game_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		game_unref (value->data[0].v_pointer);
	}
}


static void value_game_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = game_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_game_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_game_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Game* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = game_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_game_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Game** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = game_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_game (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecGame* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GAME), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_game (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GAME), NULL);
	return value->data[0].v_pointer;
}


void value_set_game (GValue* value, gpointer v_object) {
	Game* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GAME));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GAME));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		game_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		game_unref (old);
	}
}


void value_take_game (GValue* value, gpointer v_object) {
	Game* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GAME));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GAME));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		game_unref (old);
	}
}


static void game_class_init (GameClass * klass) {
	GRand* _tmp0_ = NULL;
	game_parent_class = g_type_class_peek_parent (klass);
	GAME_CLASS (klass)->finalize = game_finalize;
	g_type_class_add_private (klass, sizeof (GamePrivate));
	_tmp0_ = g_rand_new ();
	game_rnd = _tmp0_;
}


static void game_instance_init (Game * self) {
	GameInterface* _tmp0_ = NULL;
	Board* _tmp1_ = NULL;
	Player** _tmp2_ = NULL;
	Tile** _tmp3_ = NULL;
	Tile** _tmp4_ = NULL;
	GeeArrayList* _tmp5_ = NULL;
	GeeArrayList* _tmp6_ = NULL;
	GeeArrayList* _tmp7_ = NULL;
	self->priv = GAME_GET_PRIVATE (self);
	_tmp0_ = game_interface_new ();
	self->priv->ui = _tmp0_;
	self->priv->state = GAME_GAME_STATE_WAITING_TURN;
	_tmp1_ = board_new ((gfloat) 6);
	self->priv->board = _tmp1_;
	_tmp2_ = g_new0 (Player*, 4 + 1);
	self->priv->players = _tmp2_;
	self->priv->players_length1 = 4;
	self->priv->_players_size_ = self->priv->players_length1;
	_tmp3_ = g_new0 (Tile*, 136 + 1);
	self->priv->tiles = _tmp3_;
	self->priv->tiles_length1 = 136;
	self->priv->_tiles_size_ = self->priv->tiles_length1;
	_tmp4_ = g_new0 (Tile*, 136 + 1);
	self->priv->game_tiles = _tmp4_;
	self->priv->game_tiles_length1 = 136;
	self->priv->_game_tiles_size_ = self->priv->game_tiles_length1;
	_tmp5_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->dead_wall = _tmp5_;
	_tmp6_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->wall_tiles = _tmp6_;
	_tmp7_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->dora_tiles = _tmp7_;
	self->priv->kan_count = 0;
	self->priv->current_player = 0;
	self->priv->game_turn = 0;
	self->priv->first_round = TRUE;
	self->priv->player_seat = 0;
	self->ref_count = 1;
}


static void game_finalize (Game* obj) {
	Game * self;
	self = GAME (obj);
	_game_interface_unref0 (self->priv->ui);
	_board_unref0 (self->priv->board);
	self->priv->players = (_vala_array_free (self->priv->players, self->priv->players_length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->tiles = (_vala_array_free (self->priv->tiles, self->priv->tiles_length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->game_tiles = (_vala_array_free (self->priv->game_tiles, self->priv->game_tiles_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (self->priv->dead_wall);
	_g_object_unref0 (self->priv->wall_tiles);
	_g_object_unref0 (self->priv->dora_tiles);
	_g_object_unref0 (self->priv->last_played_tile);
}


GType game_get_type (void) {
	static volatile gsize game_type_id__volatile = 0;
	if (g_once_init_enter (&game_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_game_init, value_game_free_value, value_game_copy_value, value_game_peek_pointer, "p", value_game_collect_value, "p", value_game_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GameClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) game_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Game), 0, (GInstanceInitFunc) game_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType game_type_id;
		game_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Game", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&game_type_id__volatile, game_type_id);
	}
	return game_type_id__volatile;
}


gpointer game_ref (gpointer instance) {
	Game* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void game_unref (gpointer instance) {
	Game* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GAME_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


GType direction_get_type (void) {
	static volatile gsize direction_type_id__volatile = 0;
	if (g_once_init_enter (&direction_type_id__volatile)) {
		static const GEnumValue values[] = {{DIRECTION_LEFT, "DIRECTION_LEFT", "left"}, {DIRECTION_FRONT, "DIRECTION_FRONT", "front"}, {DIRECTION_RIGHT, "DIRECTION_RIGHT", "right"}, {0, NULL, NULL}};
		GType direction_type_id;
		direction_type_id = g_enum_register_static ("Direction", values);
		g_once_init_leave (&direction_type_id__volatile, direction_type_id);
	}
	return direction_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



