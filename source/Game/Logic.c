/* Logic.c generated by valac 0.12.0, the Vala compiler
 * generated from Logic.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <gobject/gvaluecollector.h>


#define TYPE_LOGIC (logic_get_type ())
#define LOGIC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIC, Logic))
#define LOGIC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOGIC, LogicClass))
#define IS_LOGIC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIC))
#define IS_LOGIC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOGIC))
#define LOGIC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOGIC, LogicClass))

typedef struct _Logic Logic;
typedef struct _LogicClass LogicClass;
typedef struct _LogicPrivate LogicPrivate;

#define TYPE_TILE (tile_get_type ())
#define TILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TILE, Tile))
#define TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TILE, TileClass))
#define IS_TILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TILE))
#define IS_TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TILE))
#define TILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TILE, TileClass))

typedef struct _Tile Tile;
typedef struct _TileClass TileClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_CALL (call_get_type ())
#define CALL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CALL, Call))
#define CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CALL, CallClass))
#define IS_CALL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CALL))
#define IS_CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CALL))
#define CALL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CALL, CallClass))

typedef struct _Call Call;
typedef struct _CallClass CallClass;

#define TYPE_PON (pon_get_type ())
#define PON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PON, Pon))
#define PON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PON, PonClass))
#define IS_PON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PON))
#define IS_PON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PON))
#define PON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PON, PonClass))

typedef struct _Pon Pon;
typedef struct _PonClass PonClass;
#define _call_unref0(var) ((var == NULL) ? NULL : (var = (call_unref (var), NULL)))

#define TYPE_PLAYER (player_get_type ())
#define PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER, Player))
#define PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER, PlayerClass))
#define IS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER))
#define IS_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER))
#define PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER, PlayerClass))

typedef struct _Player Player;
typedef struct _PlayerClass PlayerClass;

#define TYPE_YAKU (yaku_get_type ())
#define YAKU(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_YAKU, Yaku))
#define YAKU_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_YAKU, YakuClass))
#define IS_YAKU(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_YAKU))
#define IS_YAKU_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_YAKU))
#define YAKU_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_YAKU, YakuClass))

typedef struct _Yaku Yaku;
typedef struct _YakuClass YakuClass;
#define _yaku_unref0(var) ((var == NULL) ? NULL : (var = (yaku_unref (var), NULL)))
typedef struct _ParamSpecLogic ParamSpecLogic;

struct _Logic {
	GTypeInstance parent_instance;
	volatile int ref_count;
	LogicPrivate * priv;
};

struct _LogicClass {
	GTypeClass parent_class;
	void (*finalize) (Logic *self);
};

struct _ParamSpecLogic {
	GParamSpec parent_instance;
};


static gpointer logic_parent_class = NULL;

gpointer logic_ref (gpointer instance);
void logic_unref (gpointer instance);
GParamSpec* param_spec_logic (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_logic (GValue* value, gpointer v_object);
void value_take_logic (GValue* value, gpointer v_object);
gpointer value_get_logic (const GValue* value);
GType logic_get_type (void) G_GNUC_CONST;
enum  {
	LOGIC_DUMMY_PROPERTY
};
GType tile_get_type (void) G_GNUC_CONST;
gboolean logic_can_pon (Tile* played_tile, GeeArrayList* hand);
gint tile_get_tile_type (Tile* self);
gboolean logic_can_open_kan (Tile* played_tile, GeeArrayList* hand);
gboolean logic_can_closed_kan (GeeArrayList* hand);
gboolean logic_can_riichi_closed_kan (GeeArrayList* hand);
gpointer call_ref (gpointer instance);
void call_unref (gpointer instance);
GParamSpec* param_spec_call (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_call (GValue* value, gpointer v_object);
void value_take_call (GValue* value, gpointer v_object);
gpointer value_get_call (const GValue* value);
GType call_get_type (void) G_GNUC_CONST;
GType pon_get_type (void) G_GNUC_CONST;
gboolean logic_can_late_kan (GeeArrayList* hand, GeeArrayList* pons);
Tile** call_get_tiles (Call* self, int* result_length1);
gboolean logic_can_chi (Tile* played_tile, GeeArrayList* hand);
Tile** logic_auto_chi (Tile* discard_tile, GeeArrayList* hand, int* result_length1);
Tile* logic_chi_combination (Tile* discard_tile, Tile* selected_tile, GeeArrayList* hand);
gboolean logic_in_tenpai (GeeArrayList* hand);
static gboolean logic_tenpai_or_winning_hand (GeeArrayList* hand_in, gboolean tenpai_only);
gboolean logic_winning_hand (GeeArrayList* hand);
void tile_sort_tiles (GeeArrayList* tiles);
GeeArrayList* logic_can_tenpai (GeeArrayList* hand);
gboolean logic_can_win_with (GeeArrayList* hand, Tile* tile);
GType player_get_type (void) G_GNUC_CONST;
gboolean logic_has_yaku (Player* player, Tile* ron_tile, gboolean last_piece, gboolean kan_piece);
GeeArrayList* player_get_hand (Player* self);
gpointer yaku_ref (gpointer instance);
void yaku_unref (gpointer instance);
GParamSpec* param_spec_yaku (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_yaku (GValue* value, gpointer v_object);
void value_take_yaku (GValue* value, gpointer v_object);
gpointer value_get_yaku (const GValue* value);
GType yaku_get_type (void) G_GNUC_CONST;
Yaku* yaku_riichi (gint turn);
gint player_get_riichi_turn (Player* self);
Yaku* yaku_tsumo (gboolean open);
gboolean player_get_open_hand (Player* self);
Yaku* yaku_tan_yao (GeeArrayList* hand, GeeArrayList* calls);
GeeArrayList* player_get_calls (Player* self);
Logic* logic_new (void);
Logic* logic_construct (GType object_type);
static void logic_finalize (Logic* obj);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


gboolean logic_can_pon (Tile* played_tile, GeeArrayList* hand) {
	gboolean result = FALSE;
	gint count;
	g_return_val_if_fail (played_tile != NULL, FALSE);
	g_return_val_if_fail (hand != NULL, FALSE);
	count = 0;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _t_list;
		gint _tmp1_;
		gint _t_size;
		gint _t_index;
		_tmp0_ = _g_object_ref0 (hand);
		_t_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp1_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Tile* t;
			gint _tmp3_;
			gint _tmp4_;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp2_;
			_tmp3_ = tile_get_tile_type (t);
			_tmp4_ = tile_get_tile_type (played_tile);
			if (_tmp3_ == _tmp4_) {
				count++;
				if (count == 2) {
					result = TRUE;
					_g_object_unref0 (t);
					_g_object_unref0 (_t_list);
					return result;
				}
			}
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	result = FALSE;
	return result;
}


gboolean logic_can_open_kan (Tile* played_tile, GeeArrayList* hand) {
	gboolean result = FALSE;
	gint count;
	g_return_val_if_fail (played_tile != NULL, FALSE);
	g_return_val_if_fail (hand != NULL, FALSE);
	count = 0;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _t_list;
		gint _tmp1_;
		gint _t_size;
		gint _t_index;
		_tmp0_ = _g_object_ref0 (hand);
		_t_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp1_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Tile* t;
			gint _tmp3_;
			gint _tmp4_;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp2_;
			_tmp3_ = tile_get_tile_type (t);
			_tmp4_ = tile_get_tile_type (played_tile);
			if (_tmp3_ == _tmp4_) {
				count++;
				if (count == 3) {
					result = TRUE;
					_g_object_unref0 (t);
					_g_object_unref0 (_t_list);
					return result;
				}
			}
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	result = FALSE;
	return result;
}


gboolean logic_can_closed_kan (GeeArrayList* hand) {
	gboolean result = FALSE;
	g_return_val_if_fail (hand != NULL, FALSE);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _t_list;
		gint _tmp1_;
		gint _t_size;
		gint _t_index;
		_tmp0_ = _g_object_ref0 (hand);
		_t_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp1_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Tile* t;
			gint count;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp2_;
			count = 0;
			{
				GeeArrayList* _tmp3_;
				GeeArrayList* _o_list;
				gint _tmp4_;
				gint _o_size;
				gint _o_index;
				_tmp3_ = _g_object_ref0 (hand);
				_o_list = _tmp3_;
				_tmp4_ = gee_collection_get_size ((GeeCollection*) _o_list);
				_o_size = _tmp4_;
				_o_index = -1;
				while (TRUE) {
					gpointer _tmp5_ = NULL;
					Tile* o;
					gint _tmp6_;
					gint _tmp7_;
					_o_index = _o_index + 1;
					if (!(_o_index < _o_size)) {
						break;
					}
					_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) _o_list, _o_index);
					o = (Tile*) _tmp5_;
					_tmp6_ = tile_get_tile_type (t);
					_tmp7_ = tile_get_tile_type (o);
					if (_tmp6_ == _tmp7_) {
						count++;
					}
					if (count == 4) {
						result = TRUE;
						_g_object_unref0 (o);
						_g_object_unref0 (_o_list);
						_g_object_unref0 (t);
						_g_object_unref0 (_t_list);
						return result;
					}
					_g_object_unref0 (o);
				}
				_g_object_unref0 (_o_list);
			}
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	result = FALSE;
	return result;
}


gboolean logic_can_riichi_closed_kan (GeeArrayList* hand) {
	gboolean result = FALSE;
	g_return_val_if_fail (hand != NULL, FALSE);
	result = FALSE;
	return result;
}


gboolean logic_can_late_kan (GeeArrayList* hand, GeeArrayList* pons) {
	gboolean result = FALSE;
	g_return_val_if_fail (hand != NULL, FALSE);
	g_return_val_if_fail (pons != NULL, FALSE);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _p_list;
		gint _tmp1_;
		gint _p_size;
		gint _p_index;
		_tmp0_ = _g_object_ref0 (pons);
		_p_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _p_list);
		_p_size = _tmp1_;
		_p_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Pon* p;
			_p_index = _p_index + 1;
			if (!(_p_index < _p_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _p_list, _p_index);
			p = (Pon*) _tmp2_;
			{
				GeeArrayList* _tmp3_;
				GeeArrayList* _t_list;
				gint _tmp4_;
				gint _t_size;
				gint _t_index;
				_tmp3_ = _g_object_ref0 (hand);
				_t_list = _tmp3_;
				_tmp4_ = gee_collection_get_size ((GeeCollection*) _t_list);
				_t_size = _tmp4_;
				_t_index = -1;
				while (TRUE) {
					gpointer _tmp5_ = NULL;
					Tile* t;
					gint _tmp6_;
					Tile** _tmp7_ = NULL;
					gint _tmp8_;
					gint _tmp9_;
					_t_index = _t_index + 1;
					if (!(_t_index < _t_size)) {
						break;
					}
					_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
					t = (Tile*) _tmp5_;
					_tmp6_ = tile_get_tile_type (t);
					_tmp7_ = call_get_tiles ((Call*) p, &_tmp8_);
					_tmp9_ = tile_get_tile_type (_tmp7_[0]);
					if (_tmp6_ == _tmp9_) {
						result = TRUE;
						_g_object_unref0 (t);
						_g_object_unref0 (_t_list);
						_call_unref0 (p);
						_g_object_unref0 (_p_list);
						return result;
					}
					_g_object_unref0 (t);
				}
				_g_object_unref0 (_t_list);
			}
			_call_unref0 (p);
		}
		_g_object_unref0 (_p_list);
	}
	result = FALSE;
	return result;
}


gboolean logic_can_chi (Tile* played_tile, GeeArrayList* hand) {
	gboolean result = FALSE;
	gint _tmp0_;
	gboolean two_less;
	gboolean one_less;
	gboolean one_more;
	gboolean two_more;
	gint _tmp1_;
	gint _tmp2_;
	gint type;
	gboolean _tmp13_ = FALSE;
	gboolean _tmp14_ = FALSE;
	gboolean _tmp15_ = FALSE;
	g_return_val_if_fail (played_tile != NULL, FALSE);
	g_return_val_if_fail (hand != NULL, FALSE);
	_tmp0_ = tile_get_tile_type (played_tile);
	if (_tmp0_ > 26) {
		result = FALSE;
		return result;
	}
	two_less = FALSE;
	one_less = FALSE;
	one_more = FALSE;
	two_more = FALSE;
	_tmp1_ = tile_get_tile_type (played_tile);
	_tmp2_ = tile_get_tile_type (played_tile);
	type = _tmp1_ - (_tmp2_ % 9);
	{
		GeeArrayList* _tmp3_;
		GeeArrayList* _t_list;
		gint _tmp4_;
		gint _t_size;
		gint _t_index;
		_tmp3_ = _g_object_ref0 (hand);
		_t_list = _tmp3_;
		_tmp4_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp4_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp5_ = NULL;
			Tile* t;
			gboolean _tmp6_ = FALSE;
			gboolean _tmp7_ = FALSE;
			gint _tmp8_;
			gint _tmp11_;
			gint _tmp12_;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp5_;
			_tmp8_ = tile_get_tile_type (t);
			if (_tmp8_ < type) {
				_tmp7_ = TRUE;
			} else {
				gint _tmp9_;
				_tmp9_ = tile_get_tile_type (t);
				_tmp7_ = _tmp9_ >= (type + 9);
			}
			if (_tmp7_) {
				_tmp6_ = TRUE;
			} else {
				gint _tmp10_;
				_tmp10_ = tile_get_tile_type (t);
				_tmp6_ = _tmp10_ > 26;
			}
			if (_tmp6_) {
				_g_object_unref0 (t);
				continue;
			}
			_tmp11_ = tile_get_tile_type (t);
			_tmp12_ = tile_get_tile_type (played_tile);
			switch (_tmp11_ - _tmp12_) {
				case -2:
				{
					two_less = TRUE;
					break;
				}
				case -1:
				{
					one_less = TRUE;
					break;
				}
				case 1:
				{
					one_more = TRUE;
					break;
				}
				case 2:
				{
					two_more = TRUE;
					break;
				}
				default:
				break;
			}
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	if (two_less) {
		_tmp15_ = one_less;
	} else {
		_tmp15_ = FALSE;
	}
	if (_tmp15_) {
		_tmp14_ = TRUE;
	} else {
		gboolean _tmp16_ = FALSE;
		if (one_less) {
			_tmp16_ = one_more;
		} else {
			_tmp16_ = FALSE;
		}
		_tmp14_ = _tmp16_;
	}
	if (_tmp14_) {
		_tmp13_ = TRUE;
	} else {
		gboolean _tmp17_ = FALSE;
		if (one_more) {
			_tmp17_ = two_more;
		} else {
			_tmp17_ = FALSE;
		}
		_tmp13_ = _tmp17_;
	}
	result = _tmp13_;
	return result;
}


Tile** logic_auto_chi (Tile* discard_tile, GeeArrayList* hand, int* result_length1) {
	Tile** result = NULL;
	gint _tmp0_;
	gint _tmp2_;
	gint _tmp3_;
	gint type;
	Tile* two_less;
	Tile* one_less;
	Tile* one_more;
	Tile* two_more;
	gboolean _tmp18_ = FALSE;
	gboolean _tmp19_ = FALSE;
	g_return_val_if_fail (discard_tile != NULL, NULL);
	g_return_val_if_fail (hand != NULL, NULL);
	_tmp0_ = tile_get_tile_type (discard_tile);
	if (_tmp0_ > 26) {
		gpointer _tmp1_;
		_tmp1_ = NULL;
		*result_length1 = 0;
		result = _tmp1_;
		return result;
	}
	_tmp2_ = tile_get_tile_type (discard_tile);
	_tmp3_ = tile_get_tile_type (discard_tile);
	type = _tmp2_ - (_tmp3_ % 9);
	two_less = NULL;
	one_less = NULL;
	one_more = NULL;
	two_more = NULL;
	{
		GeeArrayList* _tmp4_;
		GeeArrayList* _t_list;
		gint _tmp5_;
		gint _t_size;
		gint _t_index;
		_tmp4_ = _g_object_ref0 (hand);
		_t_list = _tmp4_;
		_tmp5_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp5_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp6_ = NULL;
			Tile* t;
			gboolean _tmp7_ = FALSE;
			gboolean _tmp8_ = FALSE;
			gint _tmp9_;
			gint _tmp12_;
			gint _tmp13_;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp6_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp6_;
			_tmp9_ = tile_get_tile_type (t);
			if (_tmp9_ < type) {
				_tmp8_ = TRUE;
			} else {
				gint _tmp10_;
				_tmp10_ = tile_get_tile_type (t);
				_tmp8_ = _tmp10_ >= (type + 9);
			}
			if (_tmp8_) {
				_tmp7_ = TRUE;
			} else {
				gint _tmp11_;
				_tmp11_ = tile_get_tile_type (t);
				_tmp7_ = _tmp11_ > 26;
			}
			if (_tmp7_) {
				_g_object_unref0 (t);
				continue;
			}
			_tmp12_ = tile_get_tile_type (t);
			_tmp13_ = tile_get_tile_type (discard_tile);
			switch (_tmp12_ - _tmp13_) {
				case -2:
				{
					Tile* _tmp14_;
					_tmp14_ = _g_object_ref0 (t);
					_g_object_unref0 (two_less);
					two_less = _tmp14_;
					break;
				}
				case -1:
				{
					Tile* _tmp15_;
					_tmp15_ = _g_object_ref0 (t);
					_g_object_unref0 (one_less);
					one_less = _tmp15_;
					break;
				}
				case 1:
				{
					Tile* _tmp16_;
					_tmp16_ = _g_object_ref0 (t);
					_g_object_unref0 (one_more);
					one_more = _tmp16_;
					break;
				}
				case 2:
				{
					Tile* _tmp17_;
					_tmp17_ = _g_object_ref0 (t);
					_g_object_unref0 (two_more);
					two_more = _tmp17_;
					break;
				}
				default:
				break;
			}
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	if (two_less != NULL) {
		_tmp19_ = one_less != NULL;
	} else {
		_tmp19_ = FALSE;
	}
	if (_tmp19_) {
		_tmp18_ = one_more == NULL;
	} else {
		_tmp18_ = FALSE;
	}
	if (_tmp18_) {
		Tile* _tmp20_;
		Tile* _tmp21_;
		Tile** _tmp22_ = NULL;
		Tile** _tmp23_;
		_tmp20_ = _g_object_ref0 (two_less);
		_tmp21_ = _g_object_ref0 (one_less);
		_tmp22_ = g_new0 (Tile*, 2 + 1);
		_tmp22_[0] = _tmp20_;
		_tmp22_[1] = _tmp21_;
		_tmp23_ = _tmp22_;
		*result_length1 = 2;
		result = _tmp23_;
		_g_object_unref0 (two_more);
		_g_object_unref0 (one_more);
		_g_object_unref0 (one_less);
		_g_object_unref0 (two_less);
		return result;
	} else {
		gboolean _tmp24_ = FALSE;
		gboolean _tmp25_ = FALSE;
		gboolean _tmp26_ = FALSE;
		if (two_less == NULL) {
			_tmp26_ = one_less != NULL;
		} else {
			_tmp26_ = FALSE;
		}
		if (_tmp26_) {
			_tmp25_ = one_more != NULL;
		} else {
			_tmp25_ = FALSE;
		}
		if (_tmp25_) {
			_tmp24_ = two_more == NULL;
		} else {
			_tmp24_ = FALSE;
		}
		if (_tmp24_) {
			Tile* _tmp27_;
			Tile* _tmp28_;
			Tile** _tmp29_ = NULL;
			Tile** _tmp30_;
			_tmp27_ = _g_object_ref0 (one_less);
			_tmp28_ = _g_object_ref0 (one_more);
			_tmp29_ = g_new0 (Tile*, 2 + 1);
			_tmp29_[0] = _tmp27_;
			_tmp29_[1] = _tmp28_;
			_tmp30_ = _tmp29_;
			*result_length1 = 2;
			result = _tmp30_;
			_g_object_unref0 (two_more);
			_g_object_unref0 (one_more);
			_g_object_unref0 (one_less);
			_g_object_unref0 (two_less);
			return result;
		} else {
			gboolean _tmp31_ = FALSE;
			gboolean _tmp32_ = FALSE;
			if (one_less == NULL) {
				_tmp32_ = one_more != NULL;
			} else {
				_tmp32_ = FALSE;
			}
			if (_tmp32_) {
				_tmp31_ = two_more != NULL;
			} else {
				_tmp31_ = FALSE;
			}
			if (_tmp31_) {
				Tile* _tmp33_;
				Tile* _tmp34_;
				Tile** _tmp35_ = NULL;
				Tile** _tmp36_;
				_tmp33_ = _g_object_ref0 (one_more);
				_tmp34_ = _g_object_ref0 (two_more);
				_tmp35_ = g_new0 (Tile*, 2 + 1);
				_tmp35_[0] = _tmp33_;
				_tmp35_[1] = _tmp34_;
				_tmp36_ = _tmp35_;
				*result_length1 = 2;
				result = _tmp36_;
				_g_object_unref0 (two_more);
				_g_object_unref0 (one_more);
				_g_object_unref0 (one_less);
				_g_object_unref0 (two_less);
				return result;
			} else {
				gpointer _tmp37_;
				_tmp37_ = NULL;
				*result_length1 = 0;
				result = _tmp37_;
				_g_object_unref0 (two_more);
				_g_object_unref0 (one_more);
				_g_object_unref0 (one_less);
				_g_object_unref0 (two_less);
				return result;
			}
		}
	}
	_g_object_unref0 (two_more);
	_g_object_unref0 (one_more);
	_g_object_unref0 (one_less);
	_g_object_unref0 (two_less);
}


Tile* logic_chi_combination (Tile* discard_tile, Tile* selected_tile, GeeArrayList* hand) {
	Tile* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gint _tmp3_;
	gint _tmp4_;
	gint discard_type;
	gint _tmp5_;
	gint _tmp6_;
	gint selected_type;
	Tile* two_less;
	Tile* one_less;
	Tile* one_more;
	Tile* two_more;
	gboolean _tmp21_ = FALSE;
	g_return_val_if_fail (discard_tile != NULL, NULL);
	g_return_val_if_fail (selected_tile != NULL, NULL);
	g_return_val_if_fail (hand != NULL, NULL);
	_tmp1_ = tile_get_tile_type (discard_tile);
	if (_tmp1_ > 26) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp2_;
		_tmp2_ = tile_get_tile_type (selected_tile);
		_tmp0_ = _tmp2_ > 26;
	}
	if (_tmp0_) {
		result = NULL;
		return result;
	}
	_tmp3_ = tile_get_tile_type (discard_tile);
	_tmp4_ = tile_get_tile_type (discard_tile);
	discard_type = _tmp3_ - (_tmp4_ % 9);
	_tmp5_ = tile_get_tile_type (selected_tile);
	_tmp6_ = tile_get_tile_type (selected_tile);
	selected_type = _tmp5_ - (_tmp6_ % 9);
	if (discard_type != selected_type) {
		result = NULL;
		return result;
	}
	two_less = NULL;
	one_less = NULL;
	one_more = NULL;
	two_more = NULL;
	{
		GeeArrayList* _tmp7_;
		GeeArrayList* _t_list;
		gint _tmp8_;
		gint _t_size;
		gint _t_index;
		_tmp7_ = _g_object_ref0 (hand);
		_t_list = _tmp7_;
		_tmp8_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp8_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp9_ = NULL;
			Tile* t;
			gboolean _tmp10_ = FALSE;
			gboolean _tmp11_ = FALSE;
			gint _tmp12_;
			gint _tmp15_;
			gint _tmp16_;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp9_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp9_;
			_tmp12_ = tile_get_tile_type (t);
			if (_tmp12_ < discard_type) {
				_tmp11_ = TRUE;
			} else {
				gint _tmp13_;
				_tmp13_ = tile_get_tile_type (t);
				_tmp11_ = _tmp13_ >= (discard_type + 9);
			}
			if (_tmp11_) {
				_tmp10_ = TRUE;
			} else {
				gint _tmp14_;
				_tmp14_ = tile_get_tile_type (t);
				_tmp10_ = _tmp14_ > 26;
			}
			if (_tmp10_) {
				_g_object_unref0 (t);
				continue;
			}
			_tmp15_ = tile_get_tile_type (t);
			_tmp16_ = tile_get_tile_type (discard_tile);
			switch (_tmp15_ - _tmp16_) {
				case -2:
				{
					Tile* _tmp17_;
					_tmp17_ = _g_object_ref0 (t);
					_g_object_unref0 (two_less);
					two_less = _tmp17_;
					break;
				}
				case -1:
				{
					Tile* _tmp18_;
					_tmp18_ = _g_object_ref0 (t);
					_g_object_unref0 (one_less);
					one_less = _tmp18_;
					break;
				}
				case 1:
				{
					Tile* _tmp19_;
					_tmp19_ = _g_object_ref0 (t);
					_g_object_unref0 (one_more);
					one_more = _tmp19_;
					break;
				}
				case 2:
				{
					Tile* _tmp20_;
					_tmp20_ = _g_object_ref0 (t);
					_g_object_unref0 (two_more);
					two_more = _tmp20_;
					break;
				}
				default:
				break;
			}
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	if (selected_tile == two_less) {
		_tmp21_ = one_less != NULL;
	} else {
		_tmp21_ = FALSE;
	}
	if (_tmp21_) {
		result = one_less;
		_g_object_unref0 (two_more);
		_g_object_unref0 (one_more);
		_g_object_unref0 (two_less);
		return result;
	} else {
		gboolean _tmp22_ = FALSE;
		if (selected_tile == two_more) {
			_tmp22_ = one_more != NULL;
		} else {
			_tmp22_ = FALSE;
		}
		if (_tmp22_) {
			result = one_more;
			_g_object_unref0 (two_more);
			_g_object_unref0 (one_less);
			_g_object_unref0 (two_less);
			return result;
		} else {
			if (selected_tile == one_less) {
				if (one_more != NULL) {
					result = one_more;
					_g_object_unref0 (two_more);
					_g_object_unref0 (one_less);
					_g_object_unref0 (two_less);
					return result;
				} else {
					if (two_less != NULL) {
						result = two_less;
						_g_object_unref0 (two_more);
						_g_object_unref0 (one_more);
						_g_object_unref0 (one_less);
						return result;
					}
				}
			} else {
				if (selected_tile == one_more) {
					if (one_less != NULL) {
						result = one_less;
						_g_object_unref0 (two_more);
						_g_object_unref0 (one_more);
						_g_object_unref0 (two_less);
						return result;
					} else {
						if (two_more != NULL) {
							result = two_more;
							_g_object_unref0 (one_more);
							_g_object_unref0 (one_less);
							_g_object_unref0 (two_less);
							return result;
						}
					}
				}
			}
		}
	}
	result = NULL;
	_g_object_unref0 (two_more);
	_g_object_unref0 (one_more);
	_g_object_unref0 (one_less);
	_g_object_unref0 (two_less);
	return result;
}


gboolean logic_in_tenpai (GeeArrayList* hand) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (hand != NULL, FALSE);
	_tmp0_ = logic_tenpai_or_winning_hand (hand, TRUE);
	result = _tmp0_;
	return result;
}


gboolean logic_winning_hand (GeeArrayList* hand) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (hand != NULL, FALSE);
	_tmp0_ = logic_tenpai_or_winning_hand (hand, FALSE);
	result = _tmp0_;
	return result;
}


static gboolean logic_tenpai_or_winning_hand (GeeArrayList* hand_in, gboolean tenpai_only) {
	gboolean result = FALSE;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* hand;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp19_ = FALSE;
	gboolean _tmp20_ = FALSE;
	g_return_val_if_fail (hand_in != NULL, FALSE);
	_tmp0_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	hand = _tmp0_;
	{
		GeeArrayList* _tmp1_;
		GeeArrayList* _t_list;
		gint _tmp2_;
		gint _t_size;
		gint _t_index;
		_tmp1_ = _g_object_ref0 (hand_in);
		_t_list = _tmp1_;
		_tmp2_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp2_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp3_ = NULL;
			Tile* t;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp3_;
			gee_abstract_collection_add ((GeeAbstractCollection*) hand, t);
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	tile_sort_tiles (hand);
	if (tenpai_only) {
		gint _tmp6_;
		_tmp6_ = gee_collection_get_size ((GeeCollection*) hand_in);
		_tmp5_ = _tmp6_ == 13;
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		_tmp4_ = TRUE;
	} else {
		gboolean _tmp7_ = FALSE;
		if (!tenpai_only) {
			gint _tmp8_;
			_tmp8_ = gee_collection_get_size ((GeeCollection*) hand_in);
			_tmp7_ = _tmp8_ == 14;
		} else {
			_tmp7_ = FALSE;
		}
		_tmp4_ = _tmp7_;
	}
	if (_tmp4_) {
		gboolean same;
		gboolean offset;
		same = TRUE;
		offset = FALSE;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp9_;
				_tmp9_ = TRUE;
				while (TRUE) {
					gint _tmp10_ = 0;
					gpointer _tmp11_ = NULL;
					Tile* _tmp12_;
					gint _tmp13_;
					gpointer _tmp14_ = NULL;
					Tile* _tmp15_;
					gint _tmp16_;
					gboolean _tmp17_;
					if (!_tmp9_) {
						i = i + 2;
					}
					_tmp9_ = FALSE;
					if (tenpai_only) {
						_tmp10_ = 12;
					} else {
						_tmp10_ = 13;
					}
					if (!(i < _tmp10_)) {
						break;
					}
					_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) hand, i);
					_tmp12_ = (Tile*) _tmp11_;
					_tmp13_ = tile_get_tile_type (_tmp12_);
					_tmp14_ = gee_abstract_list_get ((GeeAbstractList*) hand, i + 1);
					_tmp15_ = (Tile*) _tmp14_;
					_tmp16_ = tile_get_tile_type (_tmp15_);
					_tmp17_ = _tmp13_ != _tmp16_;
					_g_object_unref0 (_tmp15_);
					_g_object_unref0 (_tmp12_);
					if (_tmp17_) {
						gboolean _tmp18_ = FALSE;
						if (tenpai_only) {
							_tmp18_ = !offset;
						} else {
							_tmp18_ = FALSE;
						}
						if (_tmp18_) {
							offset = TRUE;
							i--;
						} else {
							same = FALSE;
							break;
						}
					}
				}
			}
		}
		if (same) {
			result = TRUE;
			_g_object_unref0 (hand);
			return result;
		}
	}
	if (hand == NULL) {
		_tmp20_ = TRUE;
	} else {
		gboolean _tmp21_ = FALSE;
		if (tenpai_only) {
			gboolean _tmp22_ = FALSE;
			gint _tmp23_;
			_tmp23_ = gee_collection_get_size ((GeeCollection*) hand);
			if ((_tmp23_ % 3) != 1) {
				_tmp22_ = TRUE;
			} else {
				gint _tmp24_;
				_tmp24_ = gee_collection_get_size ((GeeCollection*) hand);
				_tmp22_ = _tmp24_ > 13;
			}
			_tmp21_ = _tmp22_;
		} else {
			_tmp21_ = FALSE;
		}
		_tmp20_ = _tmp21_;
	}
	if (_tmp20_) {
		_tmp19_ = TRUE;
	} else {
		gboolean _tmp25_ = FALSE;
		if (!tenpai_only) {
			gboolean _tmp26_ = FALSE;
			gint _tmp27_;
			_tmp27_ = gee_collection_get_size ((GeeCollection*) hand);
			if ((_tmp27_ % 3) != 2) {
				_tmp26_ = TRUE;
			} else {
				gint _tmp28_;
				_tmp28_ = gee_collection_get_size ((GeeCollection*) hand);
				_tmp26_ = _tmp28_ > 14;
			}
			_tmp25_ = _tmp26_;
		} else {
			_tmp25_ = FALSE;
		}
		_tmp19_ = _tmp25_;
	}
	if (_tmp19_) {
		result = FALSE;
		_g_object_unref0 (hand);
		return result;
	} else {
		gint _tmp29_;
		_tmp29_ = gee_collection_get_size ((GeeCollection*) hand);
		if (_tmp29_ == 1) {
			result = TRUE;
			_g_object_unref0 (hand);
			return result;
		} else {
			gboolean _tmp30_ = FALSE;
			gint _tmp31_;
			_tmp31_ = gee_collection_get_size ((GeeCollection*) hand);
			if (_tmp31_ == 2) {
				gpointer _tmp32_ = NULL;
				Tile* _tmp33_;
				gint _tmp34_;
				gpointer _tmp35_ = NULL;
				Tile* _tmp36_;
				gint _tmp37_;
				_tmp32_ = gee_abstract_list_get ((GeeAbstractList*) hand, 0);
				_tmp33_ = (Tile*) _tmp32_;
				_tmp34_ = tile_get_tile_type (_tmp33_);
				_tmp35_ = gee_abstract_list_get ((GeeAbstractList*) hand, 1);
				_tmp36_ = (Tile*) _tmp35_;
				_tmp37_ = tile_get_tile_type (_tmp36_);
				_tmp30_ = _tmp34_ == _tmp37_;
				_g_object_unref0 (_tmp36_);
				_g_object_unref0 (_tmp33_);
			} else {
				_tmp30_ = FALSE;
			}
			if (_tmp30_) {
				result = TRUE;
				_g_object_unref0 (hand);
				return result;
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp38_;
			_tmp38_ = TRUE;
			while (TRUE) {
				gint _tmp39_;
				gboolean _tmp40_ = FALSE;
				gpointer _tmp47_ = NULL;
				Tile* tile;
				gint count;
				GeeArrayList* _tmp48_ = NULL;
				GeeArrayList* copy;
				gint _tmp56_;
				gint _tmp57_;
				gint type;
				gboolean _tmp58_ = FALSE;
				gint _tmp72_;
				if (!_tmp38_) {
					i++;
				}
				_tmp38_ = FALSE;
				_tmp39_ = gee_collection_get_size ((GeeCollection*) hand);
				if (!(i < _tmp39_)) {
					break;
				}
				if (i != 0) {
					gpointer _tmp41_ = NULL;
					Tile* _tmp42_;
					gint _tmp43_;
					gpointer _tmp44_ = NULL;
					Tile* _tmp45_;
					gint _tmp46_;
					_tmp41_ = gee_abstract_list_get ((GeeAbstractList*) hand, i);
					_tmp42_ = (Tile*) _tmp41_;
					_tmp43_ = tile_get_tile_type (_tmp42_);
					_tmp44_ = gee_abstract_list_get ((GeeAbstractList*) hand, i - 1);
					_tmp45_ = (Tile*) _tmp44_;
					_tmp46_ = tile_get_tile_type (_tmp45_);
					_tmp40_ = _tmp43_ == _tmp46_;
					_g_object_unref0 (_tmp45_);
					_g_object_unref0 (_tmp42_);
				} else {
					_tmp40_ = FALSE;
				}
				if (_tmp40_) {
					continue;
				}
				_tmp47_ = gee_abstract_list_get ((GeeAbstractList*) hand, i);
				tile = (Tile*) _tmp47_;
				count = 0;
				_tmp48_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
				copy = _tmp48_;
				{
					GeeArrayList* _tmp49_;
					GeeArrayList* _t_list;
					gint _tmp50_;
					gint _t_size;
					gint _t_index;
					_tmp49_ = _g_object_ref0 (hand);
					_t_list = _tmp49_;
					_tmp50_ = gee_collection_get_size ((GeeCollection*) _t_list);
					_t_size = _tmp50_;
					_t_index = -1;
					while (TRUE) {
						gpointer _tmp51_ = NULL;
						Tile* t;
						gboolean _tmp52_ = FALSE;
						_t_index = _t_index + 1;
						if (!(_t_index < _t_size)) {
							break;
						}
						_tmp51_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
						t = (Tile*) _tmp51_;
						if (count < 3) {
							gint _tmp53_;
							gint _tmp54_;
							_tmp53_ = tile_get_tile_type (tile);
							_tmp54_ = tile_get_tile_type (t);
							_tmp52_ = _tmp53_ == _tmp54_;
						} else {
							_tmp52_ = FALSE;
						}
						if (_tmp52_) {
							count++;
						} else {
							gee_abstract_collection_add ((GeeAbstractCollection*) copy, t);
						}
						_g_object_unref0 (t);
					}
					_g_object_unref0 (_t_list);
				}
				if (count == 3) {
					gboolean _tmp55_;
					_tmp55_ = logic_tenpai_or_winning_hand (copy, tenpai_only);
					if (_tmp55_) {
						result = TRUE;
						_g_object_unref0 (copy);
						_g_object_unref0 (tile);
						_g_object_unref0 (hand);
						return result;
					}
				}
				_tmp56_ = tile_get_tile_type (tile);
				_tmp57_ = tile_get_tile_type (tile);
				type = _tmp56_ - (_tmp57_ % 9);
				if (type <= 26) {
					gint _tmp59_;
					gint _tmp60_;
					_tmp59_ = tile_get_tile_type (tile);
					_tmp60_ = tile_get_tile_type (tile);
					_tmp58_ = ((_tmp59_ + 2) - ((_tmp60_ + 2) % 9)) == type;
				} else {
					_tmp58_ = FALSE;
				}
				if (_tmp58_) {
					gboolean one_more;
					gboolean two_more;
					gboolean _tmp70_ = FALSE;
					one_more = FALSE;
					two_more = FALSE;
					gee_abstract_collection_clear ((GeeAbstractCollection*) copy);
					{
						GeeArrayList* _tmp61_;
						GeeArrayList* _t_list;
						gint _tmp62_;
						gint _t_size;
						gint _t_index;
						_tmp61_ = _g_object_ref0 (hand);
						_t_list = _tmp61_;
						_tmp62_ = gee_collection_get_size ((GeeCollection*) _t_list);
						_t_size = _tmp62_;
						_t_index = -1;
						while (TRUE) {
							gpointer _tmp63_ = NULL;
							Tile* t;
							gboolean _tmp64_ = FALSE;
							gint _tmp65_;
							gint _tmp66_;
							_t_index = _t_index + 1;
							if (!(_t_index < _t_size)) {
								break;
							}
							_tmp63_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
							t = (Tile*) _tmp63_;
							if (t == tile) {
								_g_object_unref0 (t);
								continue;
							}
							_tmp65_ = tile_get_tile_type (t);
							_tmp66_ = tile_get_tile_type (tile);
							if ((_tmp65_ - _tmp66_) == 1) {
								_tmp64_ = !one_more;
							} else {
								_tmp64_ = FALSE;
							}
							if (_tmp64_) {
								one_more = TRUE;
							} else {
								gboolean _tmp67_ = FALSE;
								gint _tmp68_;
								gint _tmp69_;
								_tmp68_ = tile_get_tile_type (t);
								_tmp69_ = tile_get_tile_type (tile);
								if ((_tmp68_ - _tmp69_) == 2) {
									_tmp67_ = !two_more;
								} else {
									_tmp67_ = FALSE;
								}
								if (_tmp67_) {
									two_more = TRUE;
								} else {
									gee_abstract_collection_add ((GeeAbstractCollection*) copy, t);
								}
							}
							_g_object_unref0 (t);
						}
						_g_object_unref0 (_t_list);
					}
					if (one_more) {
						_tmp70_ = two_more;
					} else {
						_tmp70_ = FALSE;
					}
					if (_tmp70_) {
						gboolean _tmp71_;
						_tmp71_ = logic_tenpai_or_winning_hand (copy, tenpai_only);
						if (_tmp71_) {
							result = TRUE;
							_g_object_unref0 (copy);
							_g_object_unref0 (tile);
							_g_object_unref0 (hand);
							return result;
						}
					}
				}
				_tmp72_ = gee_collection_get_size ((GeeCollection*) hand);
				if (_tmp72_ == 4) {
					gpointer _tmp73_ = NULL;
					Tile* _tmp74_;
					Tile* t;
					gpointer _tmp75_ = NULL;
					Tile* _tmp76_;
					gint _tmp77_;
					gpointer _tmp78_ = NULL;
					Tile* _tmp79_;
					gint _tmp80_;
					gboolean _tmp81_;
					gboolean _tmp99_ = FALSE;
					gboolean _tmp100_ = FALSE;
					gboolean _tmp101_ = FALSE;
					_tmp73_ = gee_abstract_list_remove_at ((GeeAbstractList*) hand, i);
					_tmp74_ = (Tile*) _tmp73_;
					_g_object_unref0 (_tmp74_);
					t = NULL;
					_tmp75_ = gee_abstract_list_get ((GeeAbstractList*) hand, 0);
					_tmp76_ = (Tile*) _tmp75_;
					_tmp77_ = tile_get_tile_type (_tmp76_);
					_tmp78_ = gee_abstract_list_get ((GeeAbstractList*) hand, 1);
					_tmp79_ = (Tile*) _tmp78_;
					_tmp80_ = tile_get_tile_type (_tmp79_);
					_tmp81_ = _tmp77_ == _tmp80_;
					_g_object_unref0 (_tmp79_);
					_g_object_unref0 (_tmp76_);
					if (_tmp81_) {
						gpointer _tmp82_ = NULL;
						_tmp82_ = gee_abstract_list_get ((GeeAbstractList*) hand, 2);
						_g_object_unref0 (t);
						t = (Tile*) _tmp82_;
					} else {
						gpointer _tmp83_ = NULL;
						Tile* _tmp84_;
						gint _tmp85_;
						gpointer _tmp86_ = NULL;
						Tile* _tmp87_;
						gint _tmp88_;
						gboolean _tmp89_;
						_tmp83_ = gee_abstract_list_get ((GeeAbstractList*) hand, 0);
						_tmp84_ = (Tile*) _tmp83_;
						_tmp85_ = tile_get_tile_type (_tmp84_);
						_tmp86_ = gee_abstract_list_get ((GeeAbstractList*) hand, 2);
						_tmp87_ = (Tile*) _tmp86_;
						_tmp88_ = tile_get_tile_type (_tmp87_);
						_tmp89_ = _tmp85_ == _tmp88_;
						_g_object_unref0 (_tmp87_);
						_g_object_unref0 (_tmp84_);
						if (_tmp89_) {
							gpointer _tmp90_ = NULL;
							_tmp90_ = gee_abstract_list_get ((GeeAbstractList*) hand, 1);
							_g_object_unref0 (t);
							t = (Tile*) _tmp90_;
						} else {
							gpointer _tmp91_ = NULL;
							Tile* _tmp92_;
							gint _tmp93_;
							gpointer _tmp94_ = NULL;
							Tile* _tmp95_;
							gint _tmp96_;
							gboolean _tmp97_;
							_tmp91_ = gee_abstract_list_get ((GeeAbstractList*) hand, 1);
							_tmp92_ = (Tile*) _tmp91_;
							_tmp93_ = tile_get_tile_type (_tmp92_);
							_tmp94_ = gee_abstract_list_get ((GeeAbstractList*) hand, 2);
							_tmp95_ = (Tile*) _tmp94_;
							_tmp96_ = tile_get_tile_type (_tmp95_);
							_tmp97_ = _tmp93_ == _tmp96_;
							_g_object_unref0 (_tmp95_);
							_g_object_unref0 (_tmp92_);
							if (_tmp97_) {
								gpointer _tmp98_ = NULL;
								_tmp98_ = gee_abstract_list_get ((GeeAbstractList*) hand, 0);
								_g_object_unref0 (t);
								t = (Tile*) _tmp98_;
							}
						}
					}
					if (t != NULL) {
						gint _tmp102_;
						gint _tmp103_;
						_tmp102_ = tile_get_tile_type (t);
						_tmp103_ = tile_get_tile_type (t);
						_tmp101_ = type == (_tmp102_ - (_tmp103_ % 9));
					} else {
						_tmp101_ = FALSE;
					}
					if (_tmp101_) {
						_tmp100_ = type <= 26;
					} else {
						_tmp100_ = FALSE;
					}
					if (_tmp100_) {
						gint _tmp104_;
						gint _tmp105_;
						gint _tmp106_;
						_tmp104_ = tile_get_tile_type (tile);
						_tmp105_ = tile_get_tile_type (t);
						_tmp106_ = abs (_tmp104_ - _tmp105_);
						_tmp99_ = _tmp106_ <= 2;
					} else {
						_tmp99_ = FALSE;
					}
					if (_tmp99_) {
						result = TRUE;
						_g_object_unref0 (t);
						_g_object_unref0 (copy);
						_g_object_unref0 (tile);
						_g_object_unref0 (hand);
						return result;
					}
					gee_abstract_list_insert ((GeeAbstractList*) hand, i, tile);
					_g_object_unref0 (t);
				}
				_g_object_unref0 (copy);
				_g_object_unref0 (tile);
			}
		}
	}
	result = FALSE;
	_g_object_unref0 (hand);
	return result;
}


GeeArrayList* logic_can_tenpai (GeeArrayList* hand) {
	GeeArrayList* result = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* tenpai_tiles;
	g_return_val_if_fail (hand != NULL, NULL);
	_tmp0_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	tenpai_tiles = _tmp0_;
	{
		GeeArrayList* _tmp1_;
		GeeArrayList* _tile_list;
		gint _tmp2_;
		gint _tile_size;
		gint _tile_index;
		_tmp1_ = _g_object_ref0 (hand);
		_tile_list = _tmp1_;
		_tmp2_ = gee_collection_get_size ((GeeCollection*) _tile_list);
		_tile_size = _tmp2_;
		_tile_index = -1;
		while (TRUE) {
			gpointer _tmp3_ = NULL;
			Tile* tile;
			gboolean cont;
			GeeArrayList* _tmp9_ = NULL;
			GeeArrayList* tiles;
			gboolean _tmp13_;
			_tile_index = _tile_index + 1;
			if (!(_tile_index < _tile_size)) {
				break;
			}
			_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _tile_list, _tile_index);
			tile = (Tile*) _tmp3_;
			cont = FALSE;
			{
				GeeArrayList* _tmp4_;
				GeeArrayList* _t_list;
				gint _tmp5_;
				gint _t_size;
				gint _t_index;
				_tmp4_ = _g_object_ref0 (tenpai_tiles);
				_t_list = _tmp4_;
				_tmp5_ = gee_collection_get_size ((GeeCollection*) _t_list);
				_t_size = _tmp5_;
				_t_index = -1;
				while (TRUE) {
					gpointer _tmp6_ = NULL;
					Tile* t;
					gint _tmp7_;
					gint _tmp8_;
					_t_index = _t_index + 1;
					if (!(_t_index < _t_size)) {
						break;
					}
					_tmp6_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
					t = (Tile*) _tmp6_;
					_tmp7_ = tile_get_tile_type (t);
					_tmp8_ = tile_get_tile_type (tile);
					if (_tmp7_ == _tmp8_) {
						cont = TRUE;
						_g_object_unref0 (t);
						break;
					}
					_g_object_unref0 (t);
				}
				_g_object_unref0 (_t_list);
			}
			if (cont) {
				_g_object_unref0 (tile);
				continue;
			}
			_tmp9_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
			tiles = _tmp9_;
			{
				GeeArrayList* _tmp10_;
				GeeArrayList* _t_list;
				gint _tmp11_;
				gint _t_size;
				gint _t_index;
				_tmp10_ = _g_object_ref0 (hand);
				_t_list = _tmp10_;
				_tmp11_ = gee_collection_get_size ((GeeCollection*) _t_list);
				_t_size = _tmp11_;
				_t_index = -1;
				while (TRUE) {
					gpointer _tmp12_ = NULL;
					Tile* t;
					_t_index = _t_index + 1;
					if (!(_t_index < _t_size)) {
						break;
					}
					_tmp12_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
					t = (Tile*) _tmp12_;
					if (tile != t) {
						gee_abstract_collection_add ((GeeAbstractCollection*) tiles, t);
					}
					_g_object_unref0 (t);
				}
				_g_object_unref0 (_t_list);
			}
			_tmp13_ = logic_in_tenpai (tiles);
			if (_tmp13_) {
				gee_abstract_collection_add ((GeeAbstractCollection*) tenpai_tiles, tile);
			}
			_g_object_unref0 (tiles);
			_g_object_unref0 (tile);
		}
		_g_object_unref0 (_tile_list);
	}
	result = tenpai_tiles;
	return result;
}


gboolean logic_can_win_with (GeeArrayList* hand, Tile* tile) {
	gboolean result = FALSE;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* tiles;
	gboolean _tmp4_;
	g_return_val_if_fail (hand != NULL, FALSE);
	g_return_val_if_fail (tile != NULL, FALSE);
	_tmp0_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	tiles = _tmp0_;
	{
		GeeArrayList* _tmp1_;
		GeeArrayList* _t_list;
		gint _tmp2_;
		gint _t_size;
		gint _t_index;
		_tmp1_ = _g_object_ref0 (hand);
		_t_list = _tmp1_;
		_tmp2_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp2_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp3_ = NULL;
			Tile* t;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp3_;
			gee_abstract_collection_add ((GeeAbstractCollection*) tiles, t);
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	gee_abstract_collection_add ((GeeAbstractCollection*) tiles, tile);
	_tmp4_ = logic_winning_hand (tiles);
	result = _tmp4_;
	_g_object_unref0 (tiles);
	return result;
}


gboolean logic_has_yaku (Player* player, Tile* ron_tile, gboolean last_piece, gboolean kan_piece) {
	gboolean result = FALSE;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* tiles;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	gint _tmp7_;
	Yaku* _tmp8_ = NULL;
	Yaku* _tmp9_;
	gboolean _tmp10_;
	g_return_val_if_fail (player != NULL, FALSE);
	_tmp0_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	tiles = _tmp0_;
	{
		GeeArrayList* _tmp1_ = NULL;
		GeeArrayList* _tmp2_;
		GeeArrayList* _t_list;
		gint _tmp3_;
		gint _t_size;
		gint _t_index;
		_tmp1_ = player_get_hand (player);
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_t_list = _tmp2_;
		_tmp3_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp3_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp4_ = NULL;
			Tile* t;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp4_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp4_;
			gee_abstract_collection_add ((GeeAbstractCollection*) tiles, t);
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	if (ron_tile != NULL) {
		gee_abstract_collection_add ((GeeAbstractCollection*) tiles, ron_tile);
	}
	_tmp7_ = player_get_riichi_turn (player);
	_tmp8_ = yaku_riichi (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = _tmp9_ != NULL;
	_yaku_unref0 (_tmp9_);
	if (_tmp10_) {
		_tmp6_ = TRUE;
	} else {
		gboolean _tmp11_;
		Yaku* _tmp12_ = NULL;
		Yaku* _tmp13_;
		_tmp11_ = player_get_open_hand (player);
		_tmp12_ = yaku_tsumo (_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp6_ = _tmp13_ != NULL;
		_yaku_unref0 (_tmp13_);
	}
	if (_tmp6_) {
		_tmp5_ = TRUE;
	} else {
		GeeArrayList* _tmp14_ = NULL;
		Yaku* _tmp15_ = NULL;
		Yaku* _tmp16_;
		_tmp14_ = player_get_calls (player);
		_tmp15_ = yaku_tan_yao (tiles, _tmp14_);
		_tmp16_ = _tmp15_;
		_tmp5_ = _tmp16_ != NULL;
		_yaku_unref0 (_tmp16_);
	}
	if (_tmp5_) {
		result = TRUE;
		_g_object_unref0 (tiles);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (tiles);
	return result;
}


Logic* logic_construct (GType object_type) {
	Logic* self = NULL;
	self = (Logic*) g_type_create_instance (object_type);
	return self;
}


Logic* logic_new (void) {
	return logic_construct (TYPE_LOGIC);
}


static void value_logic_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_logic_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		logic_unref (value->data[0].v_pointer);
	}
}


static void value_logic_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = logic_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_logic_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_logic_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Logic* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = logic_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_logic_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Logic** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = logic_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_logic (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecLogic* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_LOGIC), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_logic (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_LOGIC), NULL);
	return value->data[0].v_pointer;
}


void value_set_logic (GValue* value, gpointer v_object) {
	Logic* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_LOGIC));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_LOGIC));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		logic_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		logic_unref (old);
	}
}


void value_take_logic (GValue* value, gpointer v_object) {
	Logic* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_LOGIC));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_LOGIC));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		logic_unref (old);
	}
}


static void logic_class_init (LogicClass * klass) {
	logic_parent_class = g_type_class_peek_parent (klass);
	LOGIC_CLASS (klass)->finalize = logic_finalize;
}


static void logic_instance_init (Logic * self) {
	self->ref_count = 1;
}


static void logic_finalize (Logic* obj) {
	Logic * self;
	self = LOGIC (obj);
}


GType logic_get_type (void) {
	static volatile gsize logic_type_id__volatile = 0;
	if (g_once_init_enter (&logic_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_logic_init, value_logic_free_value, value_logic_copy_value, value_logic_peek_pointer, "p", value_logic_collect_value, "p", value_logic_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (LogicClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) logic_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Logic), 0, (GInstanceInitFunc) logic_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType logic_type_id;
		logic_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Logic", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&logic_type_id__volatile, logic_type_id);
	}
	return logic_type_id__volatile;
}


gpointer logic_ref (gpointer instance) {
	Logic* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void logic_unref (gpointer instance) {
	Logic* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		LOGIC_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



