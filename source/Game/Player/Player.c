/* Player.c generated by valac 0.12.0, the Vala compiler
 * generated from Player.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <GL/glew.h>


#define TYPE_PLAYER (player_get_type ())
#define PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER, Player))
#define PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER, PlayerClass))
#define IS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER))
#define IS_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER))
#define PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER, PlayerClass))

typedef struct _Player Player;
typedef struct _PlayerClass PlayerClass;
typedef struct _PlayerPrivate PlayerPrivate;

#define TYPE_TILE (tile_get_type ())
#define TILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TILE, Tile))
#define TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TILE, TileClass))
#define IS_TILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TILE))
#define IS_TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TILE))
#define TILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TILE, TileClass))

typedef struct _Tile Tile;
typedef struct _TileClass TileClass;

#define TYPE_CALL_ACTION (call_action_get_type ())
#define CALL_ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CALL_ACTION, CallAction))
#define CALL_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CALL_ACTION, CallActionClass))
#define IS_CALL_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CALL_ACTION))
#define IS_CALL_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CALL_ACTION))
#define CALL_ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CALL_ACTION, CallActionClass))

typedef struct _CallAction CallAction;
typedef struct _CallActionClass CallActionClass;

#define TYPE_TURN_ACTION (turn_action_get_type ())
#define TURN_ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TURN_ACTION, TurnAction))
#define TURN_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TURN_ACTION, TurnActionClass))
#define IS_TURN_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TURN_ACTION))
#define IS_TURN_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TURN_ACTION))
#define TURN_ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TURN_ACTION, TurnActionClass))

typedef struct _TurnAction TurnAction;
typedef struct _TurnActionClass TurnActionClass;

#define TYPE_CALL (call_get_type ())
#define CALL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CALL, Call))
#define CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CALL, CallClass))
#define IS_CALL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CALL))
#define IS_CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CALL))
#define CALL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CALL, CallClass))

typedef struct _Call Call;
typedef struct _CallClass CallClass;

#define TYPE_CHI (chi_get_type ())
#define CHI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CHI, Chi))
#define CHI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CHI, ChiClass))
#define IS_CHI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CHI))
#define IS_CHI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CHI))
#define CHI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CHI, ChiClass))

typedef struct _Chi Chi;
typedef struct _ChiClass ChiClass;

#define TYPE_KAN (kan_get_type ())
#define KAN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KAN, Kan))
#define KAN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KAN, KanClass))
#define IS_KAN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KAN))
#define IS_KAN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KAN))
#define KAN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KAN, KanClass))

typedef struct _Kan Kan;
typedef struct _KanClass KanClass;

#define TYPE_STICK (stick_get_type ())
#define STICK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_STICK, Stick))
#define STICK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_STICK, StickClass))
#define IS_STICK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_STICK))
#define IS_STICK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_STICK))
#define STICK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_STICK, StickClass))

typedef struct _Stick Stick;
typedef struct _StickClass StickClass;

#define TYPE_PON (pon_get_type ())
#define PON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PON, Pon))
#define PON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PON, PonClass))
#define IS_PON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PON))
#define IS_PON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PON))
#define PON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PON, PonClass))

typedef struct _Pon Pon;
typedef struct _PonClass PonClass;

#define PLAYER_TYPE_PLAYER_STATE (player_player_state_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _stick_unref0(var) ((var == NULL) ? NULL : (var = (stick_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _call_action_unref0(var) ((var == NULL) ? NULL : (var = (call_action_unref (var), NULL)))
#define _turn_action_unref0(var) ((var == NULL) ? NULL : (var = (turn_action_unref (var), NULL)))

#define TYPE_VECTOR (vector_get_type ())
#define VECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VECTOR, Vector))
#define VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VECTOR, VectorClass))
#define IS_VECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VECTOR))
#define IS_VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VECTOR))
#define VECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VECTOR, VectorClass))

typedef struct _Vector Vector;
typedef struct _VectorClass VectorClass;
#define _vector_unref0(var) ((var == NULL) ? NULL : (var = (vector_unref (var), NULL)))
#define _call_unref0(var) ((var == NULL) ? NULL : (var = (call_unref (var), NULL)))

#define TYPE_DIRECTION (direction_get_type ())

struct _Player {
	GObject parent_instance;
	PlayerPrivate * priv;
	gfloat hand_height;
};

struct _PlayerClass {
	GObjectClass parent_class;
	void (*draw_tile) (Player* self, Tile* t);
	gboolean (*call_decision) (Player* self, Tile* discard_tile, gboolean can_chi);
	gboolean (*turn_decision) (Player* self);
	void (*arrange_hand) (Player* self);
	CallAction* (*get_call_action) (Player* self);
	void (*set_call_action) (Player* self, CallAction* value);
	TurnAction* (*get_turn_action) (Player* self);
	void (*set_turn_action) (Player* self, TurnAction* value);
};

typedef enum  {
	PLAYER_PLAYER_STATE_READY,
	PLAYER_PLAYER_STATE_DECIDING,
	PLAYER_PLAYER_STATE_WAITING_PON,
	PLAYER_PLAYER_STATE_WAITING_KAN,
	PLAYER_PLAYER_STATE_WAITING_CHI
} PlayerPlayerState;

struct _PlayerPrivate {
	GeeArrayList* pond;
	GeeArrayList* stolen_tiles;
	GeeArrayList* chis;
	GeeArrayList* kans;
	gfloat call_height;
	gfloat pond_height;
	Stick* riichi_stick;
	gchar* _name;
	gint _position;
	GeeArrayList* _hand;
	GeeArrayList* _pons;
	GeeArrayList* _calls;
	PlayerPlayerState _state;
	CallAction* _call_action;
	TurnAction* _turn_action;
	gint _riichi_turn;
};

typedef enum  {
	DIRECTION_LEFT = -1,
	DIRECTION_FRONT = 0,
	DIRECTION_RIGHT = 1
} Direction;


static gpointer player_parent_class = NULL;

GType player_get_type (void) G_GNUC_CONST;
GType tile_get_type (void) G_GNUC_CONST;
gpointer call_action_ref (gpointer instance);
void call_action_unref (gpointer instance);
GParamSpec* param_spec_call_action (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_call_action (GValue* value, gpointer v_object);
void value_take_call_action (GValue* value, gpointer v_object);
gpointer value_get_call_action (const GValue* value);
GType call_action_get_type (void) G_GNUC_CONST;
gpointer turn_action_ref (gpointer instance);
void turn_action_unref (gpointer instance);
GParamSpec* param_spec_turn_action (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_turn_action (GValue* value, gpointer v_object);
void value_take_turn_action (GValue* value, gpointer v_object);
gpointer value_get_turn_action (const GValue* value);
GType turn_action_get_type (void) G_GNUC_CONST;
gpointer call_ref (gpointer instance);
void call_unref (gpointer instance);
GParamSpec* param_spec_call (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_call (GValue* value, gpointer v_object);
void value_take_call (GValue* value, gpointer v_object);
gpointer value_get_call (const GValue* value);
GType call_get_type (void) G_GNUC_CONST;
GType chi_get_type (void) G_GNUC_CONST;
GType kan_get_type (void) G_GNUC_CONST;
gpointer stick_ref (gpointer instance);
void stick_unref (gpointer instance);
GParamSpec* param_spec_stick (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_stick (GValue* value, gpointer v_object);
void value_take_stick (GValue* value, gpointer v_object);
gpointer value_get_stick (const GValue* value);
GType stick_get_type (void) G_GNUC_CONST;
GType pon_get_type (void) G_GNUC_CONST;
GType player_player_state_get_type (void) G_GNUC_CONST;
#define PLAYER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PLAYER, PlayerPrivate))
enum  {
	PLAYER_DUMMY_PROPERTY,
	PLAYER_NAME,
	PLAYER_POSITION,
	PLAYER_HAND,
	PLAYER_PONS,
	PLAYER_CALLS,
	PLAYER_STATE,
	PLAYER_CALL_ACTION,
	PLAYER_TURN_ACTION,
	PLAYER_RIICHI_TURN,
	PLAYER_IN_RIICHI,
	PLAYER_OPEN_HAND
};
Stick* stick_new (const gchar* name, gint points);
Stick* stick_construct (GType object_type, const gchar* name, gint points);
Player* player_new (gint position, const gchar* name);
Player* player_construct (GType object_type, gint position, const gchar* name);
static void player_set_name (Player* self, const gchar* value);
static void player_set_position (Player* self, gint value);
static void player_set_riichi_turn (Player* self, gint value);
static void player_set_hand (Player* self, GeeArrayList* value);
static void player_set_pons (Player* self, GeeArrayList* value);
static void player_set_calls (Player* self, GeeArrayList* value);
void player_set_state (Player* self, PlayerPlayerState value);
Vector* vector_new (gfloat x, gfloat y, gfloat z);
Vector* vector_construct (GType object_type, gfloat x, gfloat y, gfloat z);
gpointer vector_ref (gpointer instance);
void vector_unref (gpointer instance);
GParamSpec* param_spec_vector (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_vector (GValue* value, gpointer v_object);
void value_take_vector (GValue* value, gpointer v_object);
gpointer value_get_vector (const GValue* value);
GType vector_get_type (void) G_GNUC_CONST;
void stick_set_position (Stick* self, Vector* value);
void player_add_tile (Player* self, Tile* t);
GeeArrayList* player_get_hand (Player* self);
void player_draw_tile (Player* self, Tile* t);
static void player_real_draw_tile (Player* self, Tile* t);
#define TILE_tile_size 0.1f
#define TILE_TILE_HEIGHT (2.6f * TILE_tile_size)
#define TILE_TILE_WIDTH (1.94f * TILE_tile_size)
#define TILE_TILE_SPACING 0.005f
void tile_set_position (Tile* self, Vector* value);
void tile_set_rotation (Tile* self, Vector* value);
void player_discard_tile (Player* self, Tile* t);
static void player_do_discard_tile (Player* self, Tile* t, gboolean riichi);
void sound_play_sound (const gchar* name);
Vector* vector_new_empty (void);
Vector* vector_construct_empty (GType object_type);
void player_arrange_hand (Player* self);
gboolean player_call_decision (Player* self, Tile* discard_tile, gboolean can_chi);
static gboolean player_real_call_decision (Player* self, Tile* discard_tile, gboolean can_chi);
gboolean logic_can_win_with (GeeArrayList* hand, Tile* tile);
gboolean player_get_in_riichi (Player* self);
gboolean logic_can_pon (Tile* played_tile, GeeArrayList* hand);
gboolean logic_can_open_kan (Tile* played_tile, GeeArrayList* hand);
gboolean logic_can_chi (Tile* played_tile, GeeArrayList* hand);
void player_set_call_action (Player* self, CallAction* value);
gboolean player_turn_decision (Player* self);
static gboolean player_real_turn_decision (Player* self);
gboolean logic_winning_hand (GeeArrayList* hand);
gboolean logic_can_riichi_closed_kan (GeeArrayList* hand);
guint8 tile_get_id (Tile* self);
TurnAction* turn_action_new_discard (guint8 discard_tile);
TurnAction* turn_action_construct_discard (GType object_type, guint8 discard_tile);
void player_set_turn_action (Player* self, TurnAction* value);
gboolean logic_can_closed_kan (GeeArrayList* hand);
gboolean logic_can_late_kan (GeeArrayList* hand, GeeArrayList* pons);
GeeArrayList* player_get_pons (Player* self);
gboolean player_get_open_hand (Player* self);
GeeArrayList* logic_can_tenpai (GeeArrayList* hand);
static void player_real_arrange_hand (Player* self);
void tile_sort_tiles (GeeArrayList* tiles);
void player_do_chi (Player* self, Tile** tiles, int tiles_length1, Tile* discard_tile);
gint tile_get_tile_type (Tile* self);
Chi* chi_new (Tile** tiles, int tiles_length1);
Chi* chi_construct (GType object_type, Tile** tiles, int tiles_length1);
GeeArrayList* player_get_calls (Player* self);
void player_do_pon (Player* self, Tile** tiles, int tiles_length1, Tile* discard_tile, gint discard_player);
gint player_get_position (Player* self);
GType direction_get_type (void) G_GNUC_CONST;
Pon* pon_new (Tile** tiles, int tiles_length1, gint direction);
Pon* pon_construct (GType object_type, Tile** tiles, int tiles_length1, gint direction);
void player_do_open_kan (Player* self, Tile** tiles, int tiles_length1, Tile* discard_tile, gint discard_player);
Kan* kan_new (Tile** tiles, int tiles_length1, gint direction, gboolean open);
Kan* kan_construct (GType object_type, Tile** tiles, int tiles_length1, gint direction, gboolean open);
void player_do_closed_kan (Player* self, Tile** tiles, int tiles_length1);
#define TILE_TILE_LENGTH (1.59f * TILE_tile_size)
void player_do_late_kan (Player* self, Tile* tile, Pon* pon);
Tile** call_get_tiles (Call* self, int* result_length1);
Vector* tile_get_position (Tile* self);
gfloat vector_get_y (Vector* self);
void vector_set_y (Vector* self, gfloat value);
gint pon_get_direction (Pon* self);
gfloat vector_get_x (Vector* self);
void player_do_riichi (Player* self, gboolean open, gint turn, Tile* tile);
void stick_set_visible (Stick* self, gboolean value);
void player_do_tsumo (Player* self);
static void player_show_hand (Player* self);
void player_do_ron (Player* self, Tile* tile);
void player_steal_tile (Player* self, Tile* t);
void player_render (Player* self);
void tile_render (Tile* self);
void stick_render (Stick* self);
void player_render_selection (Player* self);
void tile_render_selection (Tile* self);
Tile* player_tile_press (Player* self, guint color_ID);
guint tile_get_color_ID (Tile* self);
void tile_set_hovering (Tile* self, gboolean value);
gboolean player_hover (Player* self, guint tile_ID);
void player_clear_hover (Player* self);
const gchar* player_get_name (Player* self);
PlayerPlayerState player_get_state (Player* self);
CallAction* player_get_call_action (Player* self);
TurnAction* player_get_turn_action (Player* self);
gint player_get_riichi_turn (Player* self);
gboolean kan_get_open (Kan* self);
static void player_finalize (GObject* obj);
static void _vala_player_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_player_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


GType player_player_state_get_type (void) {
	static volatile gsize player_player_state_type_id__volatile = 0;
	if (g_once_init_enter (&player_player_state_type_id__volatile)) {
		static const GEnumValue values[] = {{PLAYER_PLAYER_STATE_READY, "PLAYER_PLAYER_STATE_READY", "ready"}, {PLAYER_PLAYER_STATE_DECIDING, "PLAYER_PLAYER_STATE_DECIDING", "deciding"}, {PLAYER_PLAYER_STATE_WAITING_PON, "PLAYER_PLAYER_STATE_WAITING_PON", "waiting-pon"}, {PLAYER_PLAYER_STATE_WAITING_KAN, "PLAYER_PLAYER_STATE_WAITING_KAN", "waiting-kan"}, {PLAYER_PLAYER_STATE_WAITING_CHI, "PLAYER_PLAYER_STATE_WAITING_CHI", "waiting-chi"}, {0, NULL, NULL}};
		GType player_player_state_type_id;
		player_player_state_type_id = g_enum_register_static ("PlayerPlayerState", values);
		g_once_init_leave (&player_player_state_type_id__volatile, player_player_state_type_id);
	}
	return player_player_state_type_id__volatile;
}


Player* player_construct (GType object_type, gint position, const gchar* name) {
	Player * self = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_ = NULL;
	GeeArrayList* _tmp3_;
	GeeArrayList* _tmp4_ = NULL;
	GeeArrayList* _tmp5_;
	Vector* _tmp6_ = NULL;
	Vector* _tmp7_;
	g_return_val_if_fail (name != NULL, NULL);
	self = (Player*) g_object_new (object_type, NULL);
	player_set_name (self, name);
	player_set_position (self, position);
	player_set_riichi_turn (self, -1);
	_tmp0_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_tmp1_ = _tmp0_;
	player_set_hand (self, _tmp1_);
	_g_object_unref0 (_tmp1_);
	_tmp2_ = gee_array_list_new (TYPE_PON, (GBoxedCopyFunc) call_ref, call_unref, NULL);
	_tmp3_ = _tmp2_;
	player_set_pons (self, _tmp3_);
	_g_object_unref0 (_tmp3_);
	_tmp4_ = gee_array_list_new (TYPE_CALL, (GBoxedCopyFunc) call_ref, call_unref, NULL);
	_tmp5_ = _tmp4_;
	player_set_calls (self, _tmp5_);
	_g_object_unref0 (_tmp5_);
	player_set_state (self, PLAYER_PLAYER_STATE_READY);
	_tmp6_ = vector_new ((gfloat) 0, -0.6f, (gfloat) 0);
	_tmp7_ = _tmp6_;
	stick_set_position (self->priv->riichi_stick, _tmp7_);
	_vector_unref0 (_tmp7_);
	return self;
}


Player* player_new (gint position, const gchar* name) {
	return player_construct (TYPE_PLAYER, position, name);
}


void player_add_tile (Player* self, Tile* t) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (t != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_hand, t);
}


static void player_real_draw_tile (Player* self, Tile* t) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (t != NULL);
	_tmp0_ = gee_collection_get_size ((GeeCollection*) self->priv->_hand);
	if (_tmp0_ <= 1) {
		Vector* _tmp1_ = NULL;
		Vector* _tmp2_;
		Vector* _tmp3_ = NULL;
		Vector* _tmp4_;
		_tmp1_ = vector_new ((TILE_TILE_HEIGHT + (TILE_TILE_WIDTH / 2)) + TILE_TILE_SPACING, -2.7f, TILE_TILE_WIDTH / 2);
		_tmp2_ = _tmp1_;
		tile_set_position (t, _tmp2_);
		_vector_unref0 (_tmp2_);
		_tmp3_ = vector_new ((gfloat) 90, (gfloat) 0, (gfloat) 90);
		_tmp4_ = _tmp3_;
		tile_set_rotation (t, _tmp4_);
		_vector_unref0 (_tmp4_);
	} else {
		gint _tmp5_;
		_tmp5_ = gee_collection_get_size ((GeeCollection*) self->priv->_hand);
		if (_tmp5_ <= 4) {
			Vector* _tmp6_ = NULL;
			Vector* _tmp7_;
			Vector* _tmp8_ = NULL;
			Vector* _tmp9_;
			_tmp6_ = vector_new (TILE_TILE_HEIGHT / 2, -2.7f, TILE_TILE_HEIGHT + (TILE_TILE_WIDTH / 2));
			_tmp7_ = _tmp6_;
			tile_set_position (t, _tmp7_);
			_vector_unref0 (_tmp7_);
			_tmp8_ = vector_new ((gfloat) 90, (gfloat) 0, (gfloat) 90);
			_tmp9_ = _tmp8_;
			tile_set_rotation (t, _tmp9_);
			_vector_unref0 (_tmp9_);
		} else {
			gint _tmp10_;
			Vector* _tmp11_ = NULL;
			Vector* _tmp12_;
			Vector* _tmp13_ = NULL;
			Vector* _tmp14_;
			_tmp10_ = gee_collection_get_size ((GeeCollection*) self->priv->_hand);
			_tmp11_ = vector_new (((TILE_TILE_WIDTH + TILE_TILE_SPACING) * ((_tmp10_ - 2) / 2.0f)) + (TILE_TILE_HEIGHT / 2), -2.7f, TILE_TILE_HEIGHT + (TILE_TILE_WIDTH / 2));
			_tmp12_ = _tmp11_;
			tile_set_position (t, _tmp12_);
			_vector_unref0 (_tmp12_);
			_tmp13_ = vector_new ((gfloat) 90, (gfloat) 0, (gfloat) 90);
			_tmp14_ = _tmp13_;
			tile_set_rotation (t, _tmp14_);
			_vector_unref0 (_tmp14_);
		}
	}
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_hand, t);
}


void player_draw_tile (Player* self, Tile* t) {
	PLAYER_GET_CLASS (self)->draw_tile (self, t);
}


void player_discard_tile (Player* self, Tile* t) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (t != NULL);
	player_do_discard_tile (self, t, FALSE);
}


static void player_do_discard_tile (Player* self, Tile* t, gboolean riichi) {
	Vector* _tmp0_ = NULL;
	Vector* _tmp1_;
	Vector* _tmp2_ = NULL;
	Vector* _tmp3_;
	gfloat x = 0.0F;
	gfloat y = 0.0F;
	gint _tmp4_;
	Vector* _tmp8_ = NULL;
	Vector* _tmp9_;
	Vector* _tmp10_ = NULL;
	Vector* _tmp11_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (t != NULL);
	sound_play_sound ("tile");
	_tmp0_ = vector_new_empty ();
	_tmp1_ = _tmp0_;
	tile_set_position (t, _tmp1_);
	_vector_unref0 (_tmp1_);
	_tmp2_ = vector_new_empty ();
	_tmp3_ = _tmp2_;
	tile_set_rotation (t, _tmp3_);
	_vector_unref0 (_tmp3_);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, t);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->pond, t);
	_tmp4_ = gee_collection_get_size ((GeeCollection*) self->priv->pond);
	if (_tmp4_ < 18) {
		gint _tmp5_;
		gint _tmp6_;
		_tmp5_ = gee_collection_get_size ((GeeCollection*) self->priv->pond);
		x = (((_tmp5_ - 1) % 6) - 2.5f) * TILE_TILE_WIDTH;
		_tmp6_ = gee_collection_get_size ((GeeCollection*) self->priv->pond);
		y = self->priv->pond_height - (((_tmp6_ - 1) / 6) * TILE_TILE_HEIGHT);
	} else {
		gint _tmp7_;
		_tmp7_ = gee_collection_get_size ((GeeCollection*) self->priv->pond);
		x = ((_tmp7_ - 13) - 2.5f) * TILE_TILE_WIDTH;
		y = self->priv->pond_height - (2 * TILE_TILE_HEIGHT);
	}
	_tmp8_ = vector_new (x, y, (gfloat) 0);
	_tmp9_ = _tmp8_;
	tile_set_position (t, _tmp9_);
	_vector_unref0 (_tmp9_);
	_tmp10_ = vector_new_empty ();
	_tmp11_ = _tmp10_;
	tile_set_rotation (t, _tmp11_);
	_vector_unref0 (_tmp11_);
	player_arrange_hand (self);
}


static gboolean player_real_call_decision (Player* self, Tile* discard_tile, gboolean can_chi) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (discard_tile != NULL, FALSE);
	_tmp1_ = logic_can_win_with (self->priv->_hand, discard_tile);
	if (!_tmp1_) {
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_;
		_tmp3_ = player_get_in_riichi (self);
		if (_tmp3_) {
			_tmp2_ = TRUE;
		} else {
			gboolean _tmp4_ = FALSE;
			gboolean _tmp5_ = FALSE;
			gboolean _tmp6_;
			_tmp6_ = logic_can_pon (discard_tile, self->priv->_hand);
			if (!_tmp6_) {
				gboolean _tmp7_;
				_tmp7_ = logic_can_open_kan (discard_tile, self->priv->_hand);
				_tmp5_ = !_tmp7_;
			} else {
				_tmp5_ = FALSE;
			}
			if (_tmp5_) {
				gboolean _tmp8_ = FALSE;
				if (!can_chi) {
					_tmp8_ = TRUE;
				} else {
					gboolean _tmp9_;
					_tmp9_ = logic_can_chi (discard_tile, self->priv->_hand);
					_tmp8_ = !_tmp9_;
				}
				_tmp4_ = _tmp8_;
			} else {
				_tmp4_ = FALSE;
			}
			_tmp2_ = _tmp4_;
		}
		_tmp0_ = _tmp2_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		player_set_call_action (self, NULL);
		player_set_state (self, PLAYER_PLAYER_STATE_READY);
		result = FALSE;
		return result;
	}
	player_set_state (self, PLAYER_PLAYER_STATE_DECIDING);
	result = TRUE;
	return result;
}


gboolean player_call_decision (Player* self, Tile* discard_tile, gboolean can_chi) {
	return PLAYER_GET_CLASS (self)->call_decision (self, discard_tile, can_chi);
}


static gboolean player_real_turn_decision (Player* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_;
	gboolean _tmp11_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp2_ = player_get_in_riichi (self);
	if (_tmp2_) {
		gboolean _tmp3_;
		_tmp3_ = logic_winning_hand (self->priv->_hand);
		_tmp1_ = !_tmp3_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gboolean _tmp4_;
		_tmp4_ = logic_can_riichi_closed_kan (self->priv->_hand);
		_tmp0_ = !_tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint _tmp5_;
		gpointer _tmp6_ = NULL;
		Tile* _tmp7_;
		guint8 _tmp8_;
		TurnAction* _tmp9_ = NULL;
		TurnAction* _tmp10_;
		_tmp5_ = gee_collection_get_size ((GeeCollection*) self->priv->_hand);
		_tmp6_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_hand, _tmp5_ - 1);
		_tmp7_ = (Tile*) _tmp6_;
		_tmp8_ = tile_get_id (_tmp7_);
		_tmp9_ = turn_action_new_discard (_tmp8_);
		_tmp10_ = _tmp9_;
		player_set_turn_action (self, _tmp10_);
		_turn_action_unref0 (_tmp10_);
		_g_object_unref0 (_tmp7_);
		player_set_state (self, PLAYER_PLAYER_STATE_READY);
		result = FALSE;
		return result;
	}
	player_set_state (self, PLAYER_PLAYER_STATE_DECIDING);
	_tmp11_ = player_get_in_riichi (self);
	if (_tmp11_) {
		gboolean _tmp12_ = FALSE;
		gboolean _tmp13_;
		_tmp13_ = logic_can_riichi_closed_kan (self->priv->_hand);
		if (_tmp13_) {
			_tmp12_ = TRUE;
		} else {
			gboolean _tmp14_;
			_tmp14_ = logic_winning_hand (self->priv->_hand);
			_tmp12_ = _tmp14_;
		}
		result = _tmp12_;
		return result;
	} else {
		gboolean _tmp15_ = FALSE;
		gboolean _tmp16_ = FALSE;
		gboolean _tmp17_ = FALSE;
		gboolean _tmp18_;
		_tmp18_ = logic_can_closed_kan (self->priv->_hand);
		if (_tmp18_) {
			_tmp17_ = TRUE;
		} else {
			gboolean _tmp19_;
			_tmp19_ = logic_can_late_kan (self->priv->_hand, self->priv->_pons);
			_tmp17_ = _tmp19_;
		}
		if (_tmp17_) {
			_tmp16_ = TRUE;
		} else {
			gboolean _tmp20_ = FALSE;
			gboolean _tmp21_;
			_tmp21_ = player_get_open_hand (self);
			if (!_tmp21_) {
				GeeArrayList* _tmp22_ = NULL;
				GeeArrayList* _tmp23_;
				gint _tmp24_;
				_tmp22_ = logic_can_tenpai (self->priv->_hand);
				_tmp23_ = _tmp22_;
				_tmp24_ = gee_collection_get_size ((GeeCollection*) _tmp23_);
				_tmp20_ = _tmp24_ != 0;
				_g_object_unref0 (_tmp23_);
			} else {
				_tmp20_ = FALSE;
			}
			_tmp16_ = _tmp20_;
		}
		if (_tmp16_) {
			_tmp15_ = TRUE;
		} else {
			gboolean _tmp25_;
			_tmp25_ = logic_winning_hand (self->priv->_hand);
			_tmp15_ = _tmp25_;
		}
		result = _tmp15_;
		return result;
	}
}


gboolean player_turn_decision (Player* self) {
	return PLAYER_GET_CLASS (self)->turn_decision (self);
}


static void player_real_arrange_hand (Player* self) {
	g_return_if_fail (self != NULL);
	tile_sort_tiles (self->priv->_hand);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp1_;
				gpointer _tmp2_ = NULL;
				Tile* _tmp3_;
				gint _tmp4_;
				Vector* _tmp5_ = NULL;
				Vector* _tmp6_;
				gpointer _tmp7_ = NULL;
				Tile* _tmp8_;
				Vector* _tmp9_ = NULL;
				Vector* _tmp10_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				_tmp1_ = gee_collection_get_size ((GeeCollection*) self->priv->_hand);
				if (!(i < _tmp1_)) {
					break;
				}
				_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_hand, i);
				_tmp3_ = (Tile*) _tmp2_;
				_tmp4_ = gee_collection_get_size ((GeeCollection*) self->priv->_hand);
				_tmp5_ = vector_new ((i - ((_tmp4_ - 1) / 2.0f)) * (TILE_TILE_WIDTH + TILE_TILE_SPACING), -2.7f, (gfloat) 0);
				_tmp6_ = _tmp5_;
				tile_set_position (_tmp3_, _tmp6_);
				_vector_unref0 (_tmp6_);
				_g_object_unref0 (_tmp3_);
				_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_hand, i);
				_tmp8_ = (Tile*) _tmp7_;
				_tmp9_ = vector_new ((gfloat) 90, (gfloat) 0, (gfloat) 0);
				_tmp10_ = _tmp9_;
				tile_set_rotation (_tmp8_, _tmp10_);
				_vector_unref0 (_tmp10_);
				_g_object_unref0 (_tmp8_);
			}
		}
	}
}


void player_arrange_hand (Player* self) {
	PLAYER_GET_CLASS (self)->arrange_hand (self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void player_do_chi (Player* self, Tile** tiles, int tiles_length1, Tile* discard_tile) {
	gint _tmp0_;
	gint _tmp1_;
	Tile* _tmp7_;
	Tile* _tmp8_;
	Tile* _tmp9_;
	Tile** _tmp10_ = NULL;
	Tile** chi;
	gint chi_length1;
	gint _chi_size_;
	Chi* _tmp11_ = NULL;
	Chi* call;
	gfloat x;
	gfloat y;
	gfloat _tmp12_ = 0.0F;
	gint _tmp13_;
	gint _tmp14_;
	gfloat _tmp15_ = 0.0F;
	gint _tmp16_;
	gint _tmp17_;
	gfloat extra;
	Vector* _tmp18_ = NULL;
	Vector* _tmp19_;
	gfloat _tmp20_ = 0.0F;
	gint _tmp21_;
	gint _tmp22_;
	Vector* _tmp23_ = NULL;
	Vector* _tmp24_;
	gfloat _tmp25_ = 0.0F;
	gint _tmp26_;
	gint _tmp27_;
	Vector* _tmp28_ = NULL;
	Vector* _tmp29_;
	Vector* _tmp30_ = NULL;
	Vector* _tmp31_;
	Vector* _tmp32_ = NULL;
	Vector* _tmp33_;
	Vector* _tmp34_ = NULL;
	Vector* _tmp35_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (discard_tile != NULL);
	sound_play_sound ("chi");
	_tmp0_ = tile_get_tile_type (tiles[0]);
	_tmp1_ = tile_get_tile_type (tiles[1]);
	if (_tmp0_ > _tmp1_) {
		Tile* _tmp2_;
		Tile* t;
		Tile* _tmp3_;
		Tile* _tmp4_;
		Tile* _tmp5_;
		Tile* _tmp6_;
		_tmp2_ = _g_object_ref0 (tiles[0]);
		t = _tmp2_;
		_tmp3_ = _g_object_ref0 (tiles[1]);
		_tmp4_ = _tmp3_;
		_g_object_unref0 (tiles[0]);
		tiles[0] = _tmp4_;
		_tmp5_ = _g_object_ref0 (t);
		_tmp6_ = _tmp5_;
		_g_object_unref0 (tiles[1]);
		tiles[1] = _tmp6_;
		_g_object_unref0 (t);
	}
	_tmp7_ = _g_object_ref0 (discard_tile);
	_tmp8_ = _g_object_ref0 (tiles[0]);
	_tmp9_ = _g_object_ref0 (tiles[1]);
	_tmp10_ = g_new0 (Tile*, 3 + 1);
	_tmp10_[0] = _tmp7_;
	_tmp10_[1] = _tmp8_;
	_tmp10_[2] = _tmp9_;
	chi = _tmp10_;
	chi_length1 = 3;
	_chi_size_ = 3;
	_tmp11_ = chi_new (chi, chi_length1);
	call = _tmp11_;
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->chis, call);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_calls, (Call*) call);
	x = 2.5f;
	y = self->priv->call_height;
	self->priv->call_height = self->priv->call_height + TILE_TILE_HEIGHT;
	_tmp13_ = tile_get_tile_type (discard_tile);
	_tmp14_ = tile_get_tile_type (tiles[0]);
	if (_tmp13_ > _tmp14_) {
		_tmp12_ = TILE_TILE_WIDTH;
	} else {
		_tmp12_ = (gfloat) 0;
	}
	_tmp16_ = tile_get_tile_type (discard_tile);
	_tmp17_ = tile_get_tile_type (tiles[1]);
	if (_tmp16_ > _tmp17_) {
		_tmp15_ = TILE_TILE_WIDTH;
	} else {
		_tmp15_ = (gfloat) 0;
	}
	extra = _tmp12_ + _tmp15_;
	_tmp18_ = vector_new (x + extra, y + (TILE_TILE_WIDTH / 2), (gfloat) 0);
	_tmp19_ = _tmp18_;
	tile_set_position (discard_tile, _tmp19_);
	_vector_unref0 (_tmp19_);
	_tmp21_ = tile_get_tile_type (tiles[0]);
	_tmp22_ = tile_get_tile_type (discard_tile);
	if (_tmp21_ < _tmp22_) {
		_tmp20_ = TILE_TILE_HEIGHT;
	} else {
		_tmp20_ = (gfloat) 0;
	}
	_tmp23_ = vector_new ((x + (TILE_TILE_WIDTH / 2)) - _tmp20_, y, (gfloat) 0);
	_tmp24_ = _tmp23_;
	tile_set_position (tiles[0], _tmp24_);
	_vector_unref0 (_tmp24_);
	_tmp26_ = tile_get_tile_type (tiles[1]);
	_tmp27_ = tile_get_tile_type (discard_tile);
	if (_tmp26_ < _tmp27_) {
		_tmp25_ = TILE_TILE_HEIGHT;
	} else {
		_tmp25_ = (gfloat) 0;
	}
	_tmp28_ = vector_new ((x + ((TILE_TILE_WIDTH / 2) * 3)) - _tmp25_, y, (gfloat) 0);
	_tmp29_ = _tmp28_;
	tile_set_position (tiles[1], _tmp29_);
	_vector_unref0 (_tmp29_);
	_tmp30_ = vector_new ((gfloat) 0, (gfloat) 0, (gfloat) 90);
	_tmp31_ = _tmp30_;
	tile_set_rotation (discard_tile, _tmp31_);
	_vector_unref0 (_tmp31_);
	_tmp32_ = vector_new_empty ();
	_tmp33_ = _tmp32_;
	tile_set_rotation (tiles[0], _tmp33_);
	_vector_unref0 (_tmp33_);
	_tmp34_ = vector_new_empty ();
	_tmp35_ = _tmp34_;
	tile_set_rotation (tiles[1], _tmp35_);
	_vector_unref0 (_tmp35_);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[0]);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[1]);
	player_arrange_hand (self);
	_call_unref0 (call);
	chi = (_vala_array_free (chi, chi_length1, (GDestroyNotify) g_object_unref), NULL);
}


void player_do_pon (Player* self, Tile** tiles, int tiles_length1, Tile* discard_tile, gint discard_player) {
	gint direction = 0;
	Tile** pon = NULL;
	gint pon_length1 = 0;
	gint _pon_size_ = 0;
	Pon* _tmp12_ = NULL;
	Pon* call;
	gfloat x;
	gfloat y;
	Vector* _tmp13_ = NULL;
	Vector* _tmp14_;
	gfloat _tmp15_ = 0.0F;
	Vector* _tmp16_ = NULL;
	Vector* _tmp17_;
	gfloat _tmp18_ = 0.0F;
	Vector* _tmp19_ = NULL;
	Vector* _tmp20_;
	Vector* _tmp21_ = NULL;
	Vector* _tmp22_;
	Vector* _tmp23_ = NULL;
	Vector* _tmp24_;
	Vector* _tmp25_ = NULL;
	Vector* _tmp26_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (discard_tile != NULL);
	sound_play_sound ("pon");
	if (((self->priv->_position + 1) % 4) == discard_player) {
		direction = (gint) DIRECTION_RIGHT;
	} else {
		if (((self->priv->_position + 2) % 4) == discard_player) {
			direction = (gint) DIRECTION_FRONT;
		} else {
			direction = (gint) DIRECTION_LEFT;
		}
	}
	if (direction == DIRECTION_LEFT) {
		Tile* _tmp0_;
		Tile* _tmp1_;
		Tile* _tmp2_;
		Tile** _tmp3_ = NULL;
		_tmp0_ = _g_object_ref0 (discard_tile);
		_tmp1_ = _g_object_ref0 (tiles[0]);
		_tmp2_ = _g_object_ref0 (tiles[1]);
		_tmp3_ = g_new0 (Tile*, 3 + 1);
		_tmp3_[0] = _tmp0_;
		_tmp3_[1] = _tmp1_;
		_tmp3_[2] = _tmp2_;
		pon = (_vala_array_free (pon, pon_length1, (GDestroyNotify) g_object_unref), NULL);
		pon = _tmp3_;
		pon_length1 = 3;
		_pon_size_ = 3;
	} else {
		if (direction == DIRECTION_FRONT) {
			Tile* _tmp4_;
			Tile* _tmp5_;
			Tile* _tmp6_;
			Tile** _tmp7_ = NULL;
			_tmp4_ = _g_object_ref0 (tiles[0]);
			_tmp5_ = _g_object_ref0 (discard_tile);
			_tmp6_ = _g_object_ref0 (tiles[1]);
			_tmp7_ = g_new0 (Tile*, 3 + 1);
			_tmp7_[0] = _tmp4_;
			_tmp7_[1] = _tmp5_;
			_tmp7_[2] = _tmp6_;
			pon = (_vala_array_free (pon, pon_length1, (GDestroyNotify) g_object_unref), NULL);
			pon = _tmp7_;
			pon_length1 = 3;
			_pon_size_ = 3;
		} else {
			Tile* _tmp8_;
			Tile* _tmp9_;
			Tile* _tmp10_;
			Tile** _tmp11_ = NULL;
			_tmp8_ = _g_object_ref0 (tiles[0]);
			_tmp9_ = _g_object_ref0 (tiles[1]);
			_tmp10_ = _g_object_ref0 (discard_tile);
			_tmp11_ = g_new0 (Tile*, 3 + 1);
			_tmp11_[0] = _tmp8_;
			_tmp11_[1] = _tmp9_;
			_tmp11_[2] = _tmp10_;
			pon = (_vala_array_free (pon, pon_length1, (GDestroyNotify) g_object_unref), NULL);
			pon = _tmp11_;
			pon_length1 = 3;
			_pon_size_ = 3;
		}
	}
	_tmp12_ = pon_new (pon, pon_length1, direction);
	call = _tmp12_;
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_pons, call);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_calls, (Call*) call);
	x = 2.5f;
	y = self->priv->call_height;
	self->priv->call_height = self->priv->call_height + TILE_TILE_HEIGHT;
	_tmp13_ = vector_new (x + ((direction + 1) * TILE_TILE_WIDTH), y + (TILE_TILE_WIDTH / 2), (gfloat) 0);
	_tmp14_ = _tmp13_;
	tile_set_position (discard_tile, _tmp14_);
	_vector_unref0 (_tmp14_);
	if (direction != DIRECTION_LEFT) {
		_tmp15_ = TILE_TILE_HEIGHT;
	} else {
		_tmp15_ = (gfloat) 0;
	}
	_tmp16_ = vector_new ((x + (TILE_TILE_WIDTH / 2)) - _tmp15_, y, (gfloat) 0);
	_tmp17_ = _tmp16_;
	tile_set_position (tiles[0], _tmp17_);
	_vector_unref0 (_tmp17_);
	if (direction == DIRECTION_RIGHT) {
		_tmp18_ = TILE_TILE_HEIGHT;
	} else {
		_tmp18_ = (gfloat) 0;
	}
	_tmp19_ = vector_new ((x + ((TILE_TILE_WIDTH / 2) * 3)) - _tmp18_, y, (gfloat) 0);
	_tmp20_ = _tmp19_;
	tile_set_position (tiles[1], _tmp20_);
	_vector_unref0 (_tmp20_);
	_tmp21_ = vector_new ((gfloat) 0, (gfloat) 0, (gfloat) 90);
	_tmp22_ = _tmp21_;
	tile_set_rotation (discard_tile, _tmp22_);
	_vector_unref0 (_tmp22_);
	_tmp23_ = vector_new_empty ();
	_tmp24_ = _tmp23_;
	tile_set_rotation (tiles[0], _tmp24_);
	_vector_unref0 (_tmp24_);
	_tmp25_ = vector_new_empty ();
	_tmp26_ = _tmp25_;
	tile_set_rotation (tiles[1], _tmp26_);
	_vector_unref0 (_tmp26_);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[0]);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[1]);
	player_arrange_hand (self);
	_call_unref0 (call);
	pon = (_vala_array_free (pon, pon_length1, (GDestroyNotify) g_object_unref), NULL);
}


void player_do_open_kan (Player* self, Tile** tiles, int tiles_length1, Tile* discard_tile, gint discard_player) {
	gint direction = 0;
	Tile* _tmp0_;
	Tile* _tmp1_;
	Tile* _tmp2_;
	Tile* _tmp3_;
	Tile** _tmp4_ = NULL;
	Tile** kan;
	gint kan_length1;
	gint _kan_size_;
	Kan* _tmp5_ = NULL;
	Kan* call;
	gfloat x;
	gfloat y;
	gfloat extra;
	Vector* _tmp6_ = NULL;
	Vector* _tmp7_;
	gfloat _tmp8_ = 0.0F;
	Vector* _tmp9_ = NULL;
	Vector* _tmp10_;
	gfloat _tmp11_ = 0.0F;
	Vector* _tmp12_ = NULL;
	Vector* _tmp13_;
	gfloat _tmp14_ = 0.0F;
	Vector* _tmp15_ = NULL;
	Vector* _tmp16_;
	Vector* _tmp17_ = NULL;
	Vector* _tmp18_;
	Vector* _tmp19_ = NULL;
	Vector* _tmp20_;
	Vector* _tmp21_ = NULL;
	Vector* _tmp22_;
	Vector* _tmp23_ = NULL;
	Vector* _tmp24_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (discard_tile != NULL);
	sound_play_sound ("kan");
	if (((self->priv->_position + 1) % 4) == discard_player) {
		direction = (gint) DIRECTION_RIGHT;
	} else {
		if (((self->priv->_position + 2) % 4) == discard_player) {
			direction = (gint) DIRECTION_FRONT;
		} else {
			direction = (gint) DIRECTION_LEFT;
		}
	}
	_tmp0_ = _g_object_ref0 (discard_tile);
	_tmp1_ = _g_object_ref0 (tiles[0]);
	_tmp2_ = _g_object_ref0 (tiles[1]);
	_tmp3_ = _g_object_ref0 (tiles[2]);
	_tmp4_ = g_new0 (Tile*, 4 + 1);
	_tmp4_[0] = _tmp0_;
	_tmp4_[1] = _tmp1_;
	_tmp4_[2] = _tmp2_;
	_tmp4_[3] = _tmp3_;
	kan = _tmp4_;
	kan_length1 = 4;
	_kan_size_ = 4;
	_tmp5_ = kan_new (kan, kan_length1, 0, TRUE);
	call = _tmp5_;
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->kans, call);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_calls, (Call*) call);
	x = 2.5f - TILE_TILE_WIDTH;
	y = self->priv->call_height;
	self->priv->call_height = self->priv->call_height + TILE_TILE_HEIGHT;
	extra = (gfloat) 0;
	if (direction == DIRECTION_FRONT) {
		extra = TILE_TILE_WIDTH;
	} else {
		if (direction == DIRECTION_RIGHT) {
			extra = TILE_TILE_WIDTH * 3;
		}
	}
	_tmp6_ = vector_new (x + extra, y + (TILE_TILE_WIDTH / 2), (gfloat) 0);
	_tmp7_ = _tmp6_;
	tile_set_position (discard_tile, _tmp7_);
	_vector_unref0 (_tmp7_);
	if (direction != DIRECTION_LEFT) {
		_tmp8_ = TILE_TILE_HEIGHT;
	} else {
		_tmp8_ = (gfloat) 0;
	}
	_tmp9_ = vector_new ((x + (TILE_TILE_WIDTH / 2)) - _tmp8_, y, (gfloat) 0);
	_tmp10_ = _tmp9_;
	tile_set_position (tiles[0], _tmp10_);
	_vector_unref0 (_tmp10_);
	if (direction == DIRECTION_RIGHT) {
		_tmp11_ = TILE_TILE_HEIGHT;
	} else {
		_tmp11_ = (gfloat) 0;
	}
	_tmp12_ = vector_new ((x + ((TILE_TILE_WIDTH / 2) * 3)) - _tmp11_, y, (gfloat) 0);
	_tmp13_ = _tmp12_;
	tile_set_position (tiles[1], _tmp13_);
	_vector_unref0 (_tmp13_);
	if (direction == DIRECTION_RIGHT) {
		_tmp14_ = TILE_TILE_HEIGHT;
	} else {
		_tmp14_ = (gfloat) 0;
	}
	_tmp15_ = vector_new ((x + ((TILE_TILE_WIDTH / 2) * 5)) - _tmp14_, y, (gfloat) 0);
	_tmp16_ = _tmp15_;
	tile_set_position (tiles[2], _tmp16_);
	_vector_unref0 (_tmp16_);
	_tmp17_ = vector_new ((gfloat) 0, (gfloat) 0, (gfloat) 90);
	_tmp18_ = _tmp17_;
	tile_set_rotation (discard_tile, _tmp18_);
	_vector_unref0 (_tmp18_);
	_tmp19_ = vector_new_empty ();
	_tmp20_ = _tmp19_;
	tile_set_rotation (tiles[0], _tmp20_);
	_vector_unref0 (_tmp20_);
	_tmp21_ = vector_new_empty ();
	_tmp22_ = _tmp21_;
	tile_set_rotation (tiles[1], _tmp22_);
	_vector_unref0 (_tmp22_);
	_tmp23_ = vector_new_empty ();
	_tmp24_ = _tmp23_;
	tile_set_rotation (tiles[2], _tmp24_);
	_vector_unref0 (_tmp24_);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[0]);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[1]);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[2]);
	player_arrange_hand (self);
	_call_unref0 (call);
	kan = (_vala_array_free (kan, kan_length1, (GDestroyNotify) g_object_unref), NULL);
}


void player_do_closed_kan (Player* self, Tile** tiles, int tiles_length1) {
	Tile* _tmp0_;
	Tile* _tmp1_;
	Tile* _tmp2_;
	Tile* _tmp3_;
	Tile** _tmp4_ = NULL;
	Tile** kan;
	gint kan_length1;
	gint _kan_size_;
	Kan* _tmp5_ = NULL;
	Kan* call;
	gfloat x;
	gfloat y;
	Vector* _tmp6_ = NULL;
	Vector* _tmp7_;
	Vector* _tmp8_ = NULL;
	Vector* _tmp9_;
	Vector* _tmp10_ = NULL;
	Vector* _tmp11_;
	Vector* _tmp12_ = NULL;
	Vector* _tmp13_;
	Vector* _tmp14_ = NULL;
	Vector* _tmp15_;
	Vector* _tmp16_ = NULL;
	Vector* _tmp17_;
	Vector* _tmp18_ = NULL;
	Vector* _tmp19_;
	Vector* _tmp20_ = NULL;
	Vector* _tmp21_;
	g_return_if_fail (self != NULL);
	sound_play_sound ("kan");
	_tmp0_ = _g_object_ref0 (tiles[0]);
	_tmp1_ = _g_object_ref0 (tiles[1]);
	_tmp2_ = _g_object_ref0 (tiles[2]);
	_tmp3_ = _g_object_ref0 (tiles[3]);
	_tmp4_ = g_new0 (Tile*, 4 + 1);
	_tmp4_[0] = _tmp0_;
	_tmp4_[1] = _tmp1_;
	_tmp4_[2] = _tmp2_;
	_tmp4_[3] = _tmp3_;
	kan = _tmp4_;
	kan_length1 = 4;
	_kan_size_ = 4;
	_tmp5_ = kan_new (kan, kan_length1, 0, FALSE);
	call = _tmp5_;
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->kans, call);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_calls, (Call*) call);
	x = 2.5f - TILE_TILE_WIDTH;
	y = self->priv->call_height;
	self->priv->call_height = self->priv->call_height + TILE_TILE_HEIGHT;
	_tmp6_ = vector_new (x - (TILE_TILE_WIDTH / 2), y, (gfloat) 0);
	_tmp7_ = _tmp6_;
	tile_set_position (tiles[0], _tmp7_);
	_vector_unref0 (_tmp7_);
	_tmp8_ = vector_new (x + (TILE_TILE_WIDTH / 2), y, TILE_TILE_LENGTH);
	_tmp9_ = _tmp8_;
	tile_set_position (tiles[1], _tmp9_);
	_vector_unref0 (_tmp9_);
	_tmp10_ = vector_new (x + ((TILE_TILE_WIDTH / 2) * 3), y, TILE_TILE_LENGTH);
	_tmp11_ = _tmp10_;
	tile_set_position (tiles[2], _tmp11_);
	_vector_unref0 (_tmp11_);
	_tmp12_ = vector_new (x + ((TILE_TILE_WIDTH / 2) * 5), y, (gfloat) 0);
	_tmp13_ = _tmp12_;
	tile_set_position (tiles[3], _tmp13_);
	_vector_unref0 (_tmp13_);
	_tmp14_ = vector_new ((gfloat) 0, (gfloat) 0, (gfloat) 0);
	_tmp15_ = _tmp14_;
	tile_set_rotation (tiles[0], _tmp15_);
	_vector_unref0 (_tmp15_);
	_tmp16_ = vector_new ((gfloat) 0, (gfloat) 180, (gfloat) 0);
	_tmp17_ = _tmp16_;
	tile_set_rotation (tiles[1], _tmp17_);
	_vector_unref0 (_tmp17_);
	_tmp18_ = vector_new ((gfloat) 0, (gfloat) 180, (gfloat) 0);
	_tmp19_ = _tmp18_;
	tile_set_rotation (tiles[2], _tmp19_);
	_vector_unref0 (_tmp19_);
	_tmp20_ = vector_new ((gfloat) 0, (gfloat) 0, (gfloat) 0);
	_tmp21_ = _tmp20_;
	tile_set_rotation (tiles[3], _tmp21_);
	_vector_unref0 (_tmp21_);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[0]);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[1]);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[2]);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tiles[3]);
	player_arrange_hand (self);
	_call_unref0 (call);
	kan = (_vala_array_free (kan, kan_length1, (GDestroyNotify) g_object_unref), NULL);
}


void player_do_late_kan (Player* self, Tile* tile, Pon* pon) {
	Tile* _tmp0_;
	Tile** _tmp1_ = NULL;
	gint _tmp2_;
	Tile* _tmp3_;
	Tile** _tmp4_ = NULL;
	gint _tmp5_;
	Tile* _tmp6_;
	Tile** _tmp7_ = NULL;
	gint _tmp8_;
	Tile* _tmp9_;
	Tile** _tmp10_ = NULL;
	Tile** kan;
	gint kan_length1;
	gint _kan_size_;
	Kan* _tmp11_ = NULL;
	Kan* call;
	gfloat _tmp12_;
	gfloat add;
	gint _tmp25_;
	Tile** _tmp26_ = NULL;
	gint _tmp27_;
	gint _tmp28_;
	Vector* _tmp29_ = NULL;
	gfloat _tmp30_;
	Tile** _tmp31_ = NULL;
	gint _tmp32_;
	gint _tmp33_;
	Vector* _tmp34_ = NULL;
	gfloat _tmp35_;
	Vector* _tmp36_ = NULL;
	Vector* _tmp37_;
	Vector* _tmp38_ = NULL;
	Vector* _tmp39_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (tile != NULL);
	g_return_if_fail (pon != NULL);
	sound_play_sound ("kan");
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_pons, pon);
	_tmp0_ = _g_object_ref0 (tile);
	_tmp1_ = call_get_tiles ((Call*) pon, &_tmp2_);
	_tmp3_ = _g_object_ref0 (_tmp1_[0]);
	_tmp4_ = call_get_tiles ((Call*) pon, &_tmp5_);
	_tmp6_ = _g_object_ref0 (_tmp4_[1]);
	_tmp7_ = call_get_tiles ((Call*) pon, &_tmp8_);
	_tmp9_ = _g_object_ref0 (_tmp7_[2]);
	_tmp10_ = g_new0 (Tile*, 4 + 1);
	_tmp10_[0] = _tmp0_;
	_tmp10_[1] = _tmp3_;
	_tmp10_[2] = _tmp6_;
	_tmp10_[3] = _tmp9_;
	kan = _tmp10_;
	kan_length1 = 4;
	_kan_size_ = 4;
	_tmp11_ = kan_new (kan, kan_length1, 0, TRUE);
	call = _tmp11_;
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->kans, call);
	_tmp12_ = MAX ((gfloat) 0, (TILE_TILE_WIDTH * 2) - TILE_TILE_HEIGHT);
	add = _tmp12_;
	if (add > 0) {
		{
			gint _tmp13_;
			gint i;
			_tmp13_ = gee_abstract_list_index_of ((GeeAbstractList*) self->priv->_calls, (Call*) pon);
			i = _tmp13_ + 1;
			{
				gboolean _tmp14_;
				_tmp14_ = TRUE;
				while (TRUE) {
					gint _tmp15_;
					gpointer _tmp16_ = NULL;
					Call* _tmp17_;
					Tile** _tmp18_ = NULL;
					gint _tmp19_;
					Tile** _tmp20_;
					if (!_tmp14_) {
						i++;
					}
					_tmp14_ = FALSE;
					_tmp15_ = gee_collection_get_size ((GeeCollection*) self->priv->_calls);
					if (!(i < _tmp15_)) {
						break;
					}
					_tmp16_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_calls, i);
					_tmp17_ = (Call*) _tmp16_;
					_tmp18_ = call_get_tiles (_tmp17_, &_tmp19_);
					_tmp20_ = _tmp18_;
					_call_unref0 (_tmp17_);
					{
						Tile** t_collection;
						int t_collection_length1;
						int t_it;
						t_collection = _tmp20_;
						t_collection_length1 = _tmp19_;
						for (t_it = 0; t_it < _tmp19_; t_it = t_it + 1) {
							Tile* _tmp21_;
							Tile* t;
							_tmp21_ = _g_object_ref0 (t_collection[t_it]);
							t = _tmp21_;
							{
								Vector* _tmp22_ = NULL;
								Vector* _tmp23_ = NULL;
								gfloat _tmp24_;
								_tmp22_ = tile_get_position (t);
								_tmp23_ = tile_get_position (t);
								_tmp24_ = vector_get_y (_tmp23_);
								vector_set_y (_tmp23_, _tmp24_ + add);
								_g_object_unref0 (t);
							}
						}
					}
				}
			}
		}
		self->priv->call_height = self->priv->call_height + add;
	}
	_tmp25_ = gee_abstract_list_index_of ((GeeAbstractList*) self->priv->_calls, (Call*) pon);
	gee_abstract_list_insert ((GeeAbstractList*) self->priv->_calls, _tmp25_, (Call*) call);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_calls, (Call*) pon);
	_tmp26_ = call_get_tiles ((Call*) pon, &_tmp27_);
	_tmp28_ = pon_get_direction (pon);
	_tmp29_ = tile_get_position (_tmp26_[_tmp28_ + 1]);
	_tmp30_ = vector_get_x (_tmp29_);
	_tmp31_ = call_get_tiles ((Call*) pon, &_tmp32_);
	_tmp33_ = pon_get_direction (pon);
	_tmp34_ = tile_get_position (_tmp31_[_tmp33_ + 1]);
	_tmp35_ = vector_get_y (_tmp34_);
	_tmp36_ = vector_new (_tmp30_, _tmp35_ + TILE_TILE_WIDTH, (gfloat) 0);
	_tmp37_ = _tmp36_;
	tile_set_position (tile, _tmp37_);
	_vector_unref0 (_tmp37_);
	_tmp38_ = vector_new ((gfloat) 0, (gfloat) 0, (gfloat) 90);
	_tmp39_ = _tmp38_;
	tile_set_rotation (tile, _tmp39_);
	_vector_unref0 (_tmp39_);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->_hand, tile);
	player_arrange_hand (self);
	_call_unref0 (call);
	kan = (_vala_array_free (kan, kan_length1, (GDestroyNotify) g_object_unref), NULL);
}


void player_do_riichi (Player* self, gboolean open, gint turn, Tile* tile) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (tile != NULL);
	sound_play_sound ("riichi");
	player_set_riichi_turn (self, turn);
	stick_set_visible (self->priv->riichi_stick, TRUE);
	player_do_discard_tile (self, tile, TRUE);
}


void player_do_tsumo (Player* self) {
	g_return_if_fail (self != NULL);
	sound_play_sound ("tsumo");
	player_show_hand (self);
}


void player_do_ron (Player* self, Tile* tile) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (tile != NULL);
	sound_play_sound ("ron");
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->_hand, tile);
	player_show_hand (self);
}


static void player_show_hand (Player* self) {
	g_return_if_fail (self != NULL);
	sound_play_sound ("tile");
	player_arrange_hand (self);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _t_list;
		gint _tmp1_;
		gint _t_size;
		gint _t_index;
		_tmp0_ = _g_object_ref0 (self->priv->_hand);
		_t_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp1_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Tile* t;
			Vector* _tmp3_ = NULL;
			Vector* _tmp4_;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp2_;
			_tmp3_ = vector_new_empty ();
			_tmp4_ = _tmp3_;
			tile_set_rotation (t, _tmp4_);
			_vector_unref0 (_tmp4_);
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
}


void player_steal_tile (Player* self, Tile* t) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (t != NULL);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->pond, t);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->stolen_tiles, t);
}


void player_render (Player* self) {
	g_return_if_fail (self != NULL);
	glPushMatrix ();
	glRotatef ((GLfloat) (90 * self->priv->_position), (GLfloat) 0, (GLfloat) 0, (GLfloat) 1);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _t_list;
		gint _tmp1_;
		gint _t_size;
		gint _t_index;
		_tmp0_ = _g_object_ref0 (self->priv->_hand);
		_t_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp1_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Tile* t;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp2_;
			tile_render (t);
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	{
		GeeArrayList* _tmp3_;
		GeeArrayList* _t_list;
		gint _tmp4_;
		gint _t_size;
		gint _t_index;
		_tmp3_ = _g_object_ref0 (self->priv->pond);
		_t_list = _tmp3_;
		_tmp4_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp4_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp5_ = NULL;
			Tile* t;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp5_;
			tile_render (t);
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	{
		GeeArrayList* _tmp6_;
		GeeArrayList* _c_list;
		gint _tmp7_;
		gint _c_size;
		gint _c_index;
		_tmp6_ = _g_object_ref0 (self->priv->_calls);
		_c_list = _tmp6_;
		_tmp7_ = gee_collection_get_size ((GeeCollection*) _c_list);
		_c_size = _tmp7_;
		_c_index = -1;
		while (TRUE) {
			gpointer _tmp8_ = NULL;
			Call* c;
			Tile** _tmp9_ = NULL;
			gint _tmp10_;
			_c_index = _c_index + 1;
			if (!(_c_index < _c_size)) {
				break;
			}
			_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) _c_list, _c_index);
			c = (Call*) _tmp8_;
			_tmp9_ = call_get_tiles (c, &_tmp10_);
			{
				Tile** t_collection;
				int t_collection_length1;
				int t_it;
				t_collection = _tmp9_;
				t_collection_length1 = _tmp10_;
				for (t_it = 0; t_it < _tmp10_; t_it = t_it + 1) {
					Tile* _tmp11_;
					Tile* t;
					_tmp11_ = _g_object_ref0 (t_collection[t_it]);
					t = _tmp11_;
					{
						tile_render (t);
						_g_object_unref0 (t);
					}
				}
			}
			_call_unref0 (c);
		}
		_g_object_unref0 (_c_list);
	}
	stick_render (self->priv->riichi_stick);
	glPopMatrix ();
}


void player_render_selection (Player* self) {
	g_return_if_fail (self != NULL);
	glPushMatrix ();
	glRotatef ((GLfloat) (90 * self->priv->_position), (GLfloat) 0, (GLfloat) 0, (GLfloat) 1);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _t_list;
		gint _tmp1_;
		gint _t_size;
		gint _t_index;
		_tmp0_ = _g_object_ref0 (self->priv->_hand);
		_t_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp1_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Tile* t;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp2_;
			tile_render_selection (t);
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	glPopMatrix ();
}


Tile* player_tile_press (Player* self, guint color_ID) {
	Tile* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _t_list;
		gint _tmp1_;
		gint _t_size;
		gint _t_index;
		_tmp0_ = _g_object_ref0 (self->priv->_hand);
		_t_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp1_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Tile* t;
			guint _tmp3_;
			gboolean _tmp4_;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp2_;
			_tmp3_ = tile_get_color_ID (t);
			_tmp4_ = _tmp3_ == color_ID;
			tile_set_hovering (t, _tmp4_);
			if (_tmp4_) {
				result = t;
				_g_object_unref0 (_t_list);
				return result;
			}
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	result = NULL;
	return result;
}


gboolean player_hover (Player* self, guint tile_ID) {
	gboolean result = FALSE;
	gboolean hovering;
	g_return_val_if_fail (self != NULL, FALSE);
	hovering = FALSE;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _t_list;
		gint _tmp1_;
		gint _t_size;
		gint _t_index;
		_tmp0_ = _g_object_ref0 (self->priv->_hand);
		_t_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp1_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Tile* t;
			guint _tmp3_;
			gboolean _tmp4_;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp2_;
			_tmp3_ = tile_get_color_ID (t);
			_tmp4_ = _tmp3_ == tile_ID;
			tile_set_hovering (t, _tmp4_);
			if (_tmp4_) {
				hovering = TRUE;
			}
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
	result = hovering;
	return result;
}


void player_clear_hover (Player* self) {
	g_return_if_fail (self != NULL);
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _t_list;
		gint _tmp1_;
		gint _t_size;
		gint _t_index;
		_tmp0_ = _g_object_ref0 (self->priv->_hand);
		_t_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _t_list);
		_t_size = _tmp1_;
		_t_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Tile* t;
			_t_index = _t_index + 1;
			if (!(_t_index < _t_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _t_list, _t_index);
			t = (Tile*) _tmp2_;
			tile_set_hovering (t, FALSE);
			_g_object_unref0 (t);
		}
		_g_object_unref0 (_t_list);
	}
}


const gchar* player_get_name (Player* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_name;
	return result;
}


static void player_set_name (Player* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp0_;
	g_object_notify ((GObject *) self, "name");
}


gint player_get_position (Player* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_position;
	return result;
}


static void player_set_position (Player* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_position = value;
	g_object_notify ((GObject *) self, "position");
}


GeeArrayList* player_get_hand (Player* self) {
	GeeArrayList* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_hand;
	return result;
}


static void player_set_hand (Player* self, GeeArrayList* value) {
	GeeArrayList* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_g_object_unref0 (self->priv->_hand);
	self->priv->_hand = _tmp0_;
	g_object_notify ((GObject *) self, "hand");
}


GeeArrayList* player_get_pons (Player* self) {
	GeeArrayList* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_pons;
	return result;
}


static void player_set_pons (Player* self, GeeArrayList* value) {
	GeeArrayList* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_g_object_unref0 (self->priv->_pons);
	self->priv->_pons = _tmp0_;
	g_object_notify ((GObject *) self, "pons");
}


GeeArrayList* player_get_calls (Player* self) {
	GeeArrayList* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_calls;
	return result;
}


static void player_set_calls (Player* self, GeeArrayList* value) {
	GeeArrayList* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_g_object_unref0 (self->priv->_calls);
	self->priv->_calls = _tmp0_;
	g_object_notify ((GObject *) self, "calls");
}


PlayerPlayerState player_get_state (Player* self) {
	PlayerPlayerState result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_state;
	return result;
}


void player_set_state (Player* self, PlayerPlayerState value) {
	g_return_if_fail (self != NULL);
	self->priv->_state = value;
	g_object_notify ((GObject *) self, "state");
}


CallAction* player_get_call_action (Player* self) {
	return PLAYER_GET_CLASS (self)->get_call_action (self);
}


static CallAction* player_real_get_call_action (Player* base) {
	CallAction* result;
	Player* self;
	self = base;
	result = self->priv->_call_action;
	return result;
}


void player_set_call_action (Player* self, CallAction* value) {
	PLAYER_GET_CLASS (self)->set_call_action (self, value);
}


static gpointer _call_action_ref0 (gpointer self) {
	return self ? call_action_ref (self) : NULL;
}


static void player_real_set_call_action (Player* base, CallAction* value) {
	Player* self;
	CallAction* _tmp0_;
	self = base;
	_tmp0_ = _call_action_ref0 (value);
	_call_action_unref0 (self->priv->_call_action);
	self->priv->_call_action = _tmp0_;
	g_object_notify ((GObject *) self, "call-action");
}


TurnAction* player_get_turn_action (Player* self) {
	return PLAYER_GET_CLASS (self)->get_turn_action (self);
}


static TurnAction* player_real_get_turn_action (Player* base) {
	TurnAction* result;
	Player* self;
	self = base;
	result = self->priv->_turn_action;
	return result;
}


void player_set_turn_action (Player* self, TurnAction* value) {
	PLAYER_GET_CLASS (self)->set_turn_action (self, value);
}


static gpointer _turn_action_ref0 (gpointer self) {
	return self ? turn_action_ref (self) : NULL;
}


static void player_real_set_turn_action (Player* base, TurnAction* value) {
	Player* self;
	TurnAction* _tmp0_;
	self = base;
	_tmp0_ = _turn_action_ref0 (value);
	_turn_action_unref0 (self->priv->_turn_action);
	self->priv->_turn_action = _tmp0_;
	g_object_notify ((GObject *) self, "turn-action");
}


gint player_get_riichi_turn (Player* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_riichi_turn;
	return result;
}


static void player_set_riichi_turn (Player* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_riichi_turn = value;
	g_object_notify ((GObject *) self, "riichi-turn");
}


gboolean player_get_in_riichi (Player* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_riichi_turn != (-1);
	return result;
}


gboolean player_get_open_hand (Player* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = gee_collection_get_size ((GeeCollection*) self->priv->chis);
	if (_tmp1_ != 0) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp2_;
		_tmp2_ = gee_collection_get_size ((GeeCollection*) self->priv->_pons);
		_tmp0_ = _tmp2_ != 0;
	}
	if (_tmp0_) {
		result = TRUE;
		return result;
	}
	{
		GeeArrayList* _tmp3_;
		GeeArrayList* _kan_list;
		gint _tmp4_;
		gint _kan_size;
		gint _kan_index;
		_tmp3_ = _g_object_ref0 (self->priv->kans);
		_kan_list = _tmp3_;
		_tmp4_ = gee_collection_get_size ((GeeCollection*) _kan_list);
		_kan_size = _tmp4_;
		_kan_index = -1;
		while (TRUE) {
			gpointer _tmp5_ = NULL;
			Kan* kan;
			gboolean _tmp6_;
			_kan_index = _kan_index + 1;
			if (!(_kan_index < _kan_size)) {
				break;
			}
			_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) _kan_list, _kan_index);
			kan = (Kan*) _tmp5_;
			_tmp6_ = kan_get_open (kan);
			if (_tmp6_) {
				result = TRUE;
				_call_unref0 (kan);
				_g_object_unref0 (_kan_list);
				return result;
			}
			_call_unref0 (kan);
		}
		_g_object_unref0 (_kan_list);
	}
	result = FALSE;
	return result;
}


static void player_class_init (PlayerClass * klass) {
	player_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PlayerPrivate));
	PLAYER_CLASS (klass)->draw_tile = player_real_draw_tile;
	PLAYER_CLASS (klass)->call_decision = player_real_call_decision;
	PLAYER_CLASS (klass)->turn_decision = player_real_turn_decision;
	PLAYER_CLASS (klass)->arrange_hand = player_real_arrange_hand;
	PLAYER_CLASS (klass)->get_call_action = player_real_get_call_action;
	PLAYER_CLASS (klass)->set_call_action = player_real_set_call_action;
	PLAYER_CLASS (klass)->get_turn_action = player_real_get_turn_action;
	PLAYER_CLASS (klass)->set_turn_action = player_real_set_turn_action;
	G_OBJECT_CLASS (klass)->get_property = _vala_player_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_player_set_property;
	G_OBJECT_CLASS (klass)->finalize = player_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_POSITION, g_param_spec_int ("position", "position", "position", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_HAND, g_param_spec_object ("hand", "hand", "hand", GEE_TYPE_ARRAY_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_PONS, g_param_spec_object ("pons", "pons", "pons", GEE_TYPE_ARRAY_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_CALLS, g_param_spec_object ("calls", "calls", "calls", GEE_TYPE_ARRAY_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_STATE, g_param_spec_enum ("state", "state", "state", PLAYER_TYPE_PLAYER_STATE, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_CALL_ACTION, param_spec_call_action ("call-action", "call-action", "call-action", TYPE_CALL_ACTION, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_TURN_ACTION, param_spec_turn_action ("turn-action", "turn-action", "turn-action", TYPE_TURN_ACTION, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_RIICHI_TURN, g_param_spec_int ("riichi-turn", "riichi-turn", "riichi-turn", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_IN_RIICHI, g_param_spec_boolean ("in-riichi", "in-riichi", "in-riichi", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_OPEN_HAND, g_param_spec_boolean ("open-hand", "open-hand", "open-hand", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void player_instance_init (Player * self) {
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	GeeArrayList* _tmp3_ = NULL;
	Stick* _tmp4_ = NULL;
	self->priv = PLAYER_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->pond = _tmp0_;
	_tmp1_ = gee_array_list_new (TYPE_TILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->stolen_tiles = _tmp1_;
	_tmp2_ = gee_array_list_new (TYPE_CHI, (GBoxedCopyFunc) call_ref, call_unref, NULL);
	self->priv->chis = _tmp2_;
	_tmp3_ = gee_array_list_new (TYPE_KAN, (GBoxedCopyFunc) call_ref, call_unref, NULL);
	self->priv->kans = _tmp3_;
	self->priv->call_height = -2.9f;
	self->priv->pond_height = -1.1f;
	self->hand_height = -2.43f;
	_tmp4_ = stick_new ("Ten1000", 1000);
	self->priv->riichi_stick = _tmp4_;
}


static void player_finalize (GObject* obj) {
	Player * self;
	self = PLAYER (obj);
	_g_object_unref0 (self->priv->pond);
	_g_object_unref0 (self->priv->stolen_tiles);
	_g_object_unref0 (self->priv->chis);
	_g_object_unref0 (self->priv->kans);
	_stick_unref0 (self->priv->riichi_stick);
	_g_free0 (self->priv->_name);
	_g_object_unref0 (self->priv->_hand);
	_g_object_unref0 (self->priv->_pons);
	_g_object_unref0 (self->priv->_calls);
	_call_action_unref0 (self->priv->_call_action);
	_turn_action_unref0 (self->priv->_turn_action);
	G_OBJECT_CLASS (player_parent_class)->finalize (obj);
}


GType player_get_type (void) {
	static volatile gsize player_type_id__volatile = 0;
	if (g_once_init_enter (&player_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PlayerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) player_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Player), 0, (GInstanceInitFunc) player_instance_init, NULL };
		GType player_type_id;
		player_type_id = g_type_register_static (G_TYPE_OBJECT, "Player", &g_define_type_info, 0);
		g_once_init_leave (&player_type_id__volatile, player_type_id);
	}
	return player_type_id__volatile;
}


static void _vala_player_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Player * self;
	self = PLAYER (object);
	switch (property_id) {
		case PLAYER_NAME:
		g_value_set_string (value, player_get_name (self));
		break;
		case PLAYER_POSITION:
		g_value_set_int (value, player_get_position (self));
		break;
		case PLAYER_HAND:
		g_value_set_object (value, player_get_hand (self));
		break;
		case PLAYER_PONS:
		g_value_set_object (value, player_get_pons (self));
		break;
		case PLAYER_CALLS:
		g_value_set_object (value, player_get_calls (self));
		break;
		case PLAYER_STATE:
		g_value_set_enum (value, player_get_state (self));
		break;
		case PLAYER_CALL_ACTION:
		value_set_call_action (value, player_get_call_action (self));
		break;
		case PLAYER_TURN_ACTION:
		value_set_turn_action (value, player_get_turn_action (self));
		break;
		case PLAYER_RIICHI_TURN:
		g_value_set_int (value, player_get_riichi_turn (self));
		break;
		case PLAYER_IN_RIICHI:
		g_value_set_boolean (value, player_get_in_riichi (self));
		break;
		case PLAYER_OPEN_HAND:
		g_value_set_boolean (value, player_get_open_hand (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_player_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Player * self;
	self = PLAYER (object);
	switch (property_id) {
		case PLAYER_NAME:
		player_set_name (self, g_value_get_string (value));
		break;
		case PLAYER_POSITION:
		player_set_position (self, g_value_get_int (value));
		break;
		case PLAYER_HAND:
		player_set_hand (self, g_value_get_object (value));
		break;
		case PLAYER_PONS:
		player_set_pons (self, g_value_get_object (value));
		break;
		case PLAYER_CALLS:
		player_set_calls (self, g_value_get_object (value));
		break;
		case PLAYER_STATE:
		player_set_state (self, g_value_get_enum (value));
		break;
		case PLAYER_CALL_ACTION:
		player_set_call_action (self, value_get_call_action (value));
		break;
		case PLAYER_TURN_ACTION:
		player_set_turn_action (self, value_get_turn_action (value));
		break;
		case PLAYER_RIICHI_TURN:
		player_set_riichi_turn (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



