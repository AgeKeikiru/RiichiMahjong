/* ComputerPlayer.c generated by valac 0.12.0, the Vala compiler
 * generated from ComputerPlayer.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define TYPE_PLAYER (player_get_type ())
#define PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER, Player))
#define PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER, PlayerClass))
#define IS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER))
#define IS_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER))
#define PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER, PlayerClass))

typedef struct _Player Player;
typedef struct _PlayerClass PlayerClass;
typedef struct _PlayerPrivate PlayerPrivate;

#define TYPE_TILE (tile_get_type ())
#define TILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TILE, Tile))
#define TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TILE, TileClass))
#define IS_TILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TILE))
#define IS_TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TILE))
#define TILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TILE, TileClass))

typedef struct _Tile Tile;
typedef struct _TileClass TileClass;

#define TYPE_CALL_ACTION (call_action_get_type ())
#define CALL_ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CALL_ACTION, CallAction))
#define CALL_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CALL_ACTION, CallActionClass))
#define IS_CALL_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CALL_ACTION))
#define IS_CALL_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CALL_ACTION))
#define CALL_ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CALL_ACTION, CallActionClass))

typedef struct _CallAction CallAction;
typedef struct _CallActionClass CallActionClass;

#define TYPE_TURN_ACTION (turn_action_get_type ())
#define TURN_ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TURN_ACTION, TurnAction))
#define TURN_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TURN_ACTION, TurnActionClass))
#define IS_TURN_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TURN_ACTION))
#define IS_TURN_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TURN_ACTION))
#define TURN_ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TURN_ACTION, TurnActionClass))

typedef struct _TurnAction TurnAction;
typedef struct _TurnActionClass TurnActionClass;

#define TYPE_COMPUTER_PLAYER (computer_player_get_type ())
#define COMPUTER_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPUTER_PLAYER, ComputerPlayer))
#define COMPUTER_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPUTER_PLAYER, ComputerPlayerClass))
#define IS_COMPUTER_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPUTER_PLAYER))
#define IS_COMPUTER_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPUTER_PLAYER))
#define COMPUTER_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPUTER_PLAYER, ComputerPlayerClass))

typedef struct _ComputerPlayer ComputerPlayer;
typedef struct _ComputerPlayerClass ComputerPlayerClass;
typedef struct _ComputerPlayerPrivate ComputerPlayerPrivate;

#define TYPE_OBJ (obj_get_type ())
#define OBJ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OBJ, Obj))
#define OBJ_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OBJ, ObjClass))
#define IS_OBJ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OBJ))
#define IS_OBJ_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OBJ))
#define OBJ_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OBJ, ObjClass))

typedef struct _Obj Obj;
typedef struct _ObjClass ObjClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _turn_action_unref0(var) ((var == NULL) ? NULL : (var = (turn_action_unref (var), NULL)))

#define PLAYER_TYPE_PLAYER_STATE (player_player_state_get_type ())

#define TYPE_CALL (call_get_type ())
#define CALL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CALL, Call))
#define CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CALL, CallClass))
#define IS_CALL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CALL))
#define IS_CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CALL))
#define CALL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CALL, CallClass))

typedef struct _Call Call;
typedef struct _CallClass CallClass;

#define TYPE_PON (pon_get_type ())
#define PON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PON, Pon))
#define PON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PON, PonClass))
#define IS_PON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PON))
#define IS_PON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PON))
#define PON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PON, PonClass))

typedef struct _Pon Pon;
typedef struct _PonClass PonClass;
#define _call_action_unref0(var) ((var == NULL) ? NULL : (var = (call_action_unref (var), NULL)))

struct _Player {
	GObject parent_instance;
	PlayerPrivate * priv;
	gfloat hand_height;
};

struct _PlayerClass {
	GObjectClass parent_class;
	void (*draw_tile) (Player* self, Tile* t);
	gboolean (*call_decision) (Player* self, Tile* discard_tile, gboolean can_chi);
	gboolean (*turn_decision) (Player* self);
	void (*arrange_hand) (Player* self);
	CallAction* (*get_call_action) (Player* self);
	void (*set_call_action) (Player* self, CallAction* value);
	TurnAction* (*get_turn_action) (Player* self);
	void (*set_turn_action) (Player* self, TurnAction* value);
};

struct _ComputerPlayer {
	Player parent_instance;
	ComputerPlayerPrivate * priv;
};

struct _ComputerPlayerClass {
	PlayerClass parent_class;
};

typedef void (*ThreadingDel3Arg) (GObject* arg1, GObject* arg2, GObject* arg3, void* user_data);
typedef enum  {
	PLAYER_PLAYER_STATE_READY,
	PLAYER_PLAYER_STATE_DECIDING,
	PLAYER_PLAYER_STATE_WAITING_PON,
	PLAYER_PLAYER_STATE_WAITING_KAN,
	PLAYER_PLAYER_STATE_WAITING_CHI
} PlayerPlayerState;

typedef void (*ThreadingDel1Arg) (GObject* arg1, void* user_data);

static gpointer computer_player_parent_class = NULL;

GType player_get_type (void) G_GNUC_CONST;
GType tile_get_type (void) G_GNUC_CONST;
gpointer call_action_ref (gpointer instance);
void call_action_unref (gpointer instance);
GParamSpec* param_spec_call_action (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_call_action (GValue* value, gpointer v_object);
void value_take_call_action (GValue* value, gpointer v_object);
gpointer value_get_call_action (const GValue* value);
GType call_action_get_type (void) G_GNUC_CONST;
gpointer turn_action_ref (gpointer instance);
void turn_action_unref (gpointer instance);
GParamSpec* param_spec_turn_action (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_turn_action (GValue* value, gpointer v_object);
void value_take_turn_action (GValue* value, gpointer v_object);
gpointer value_get_turn_action (const GValue* value);
GType turn_action_get_type (void) G_GNUC_CONST;
GType computer_player_get_type (void) G_GNUC_CONST;
enum  {
	COMPUTER_PLAYER_DUMMY_PROPERTY
};
ComputerPlayer* computer_player_new (gint position, const gchar* name);
ComputerPlayer* computer_player_construct (GType object_type, gint position, const gchar* name);
Player* player_new (gint position, const gchar* name);
Player* player_construct (GType object_type, gint position, const gchar* name);
static gboolean computer_player_real_call_decision (Player* base, Tile* discard_tile, gboolean can_chi);
gboolean player_call_decision (Player* self, Tile* discard_tile, gboolean can_chi);
void threading_start3 (ThreadingDel3Arg function, void* function_target, GObject* arg1, GObject* arg2, GObject* arg3);
static void computer_player_call_decision_thread (GObject* player_obj, GObject* tile_obj, GObject* can_chi_obj);
static void _computer_player_call_decision_thread_threading_del3_arg (GObject* arg1, GObject* arg2, GObject* arg3, gpointer self);
Obj* obj_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer t);
Obj* obj_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer t);
GType obj_get_type (void) G_GNUC_CONST;
static gboolean computer_player_real_turn_decision (Player* base);
gboolean player_get_in_riichi (Player* self);
gboolean logic_winning_hand (GeeArrayList* hand);
GeeArrayList* player_get_hand (Player* self);
gboolean logic_can_riichi_closed_kan (GeeArrayList* hand);
guint8 tile_get_id (Tile* self);
TurnAction* turn_action_new_discard (guint8 discard_tile);
TurnAction* turn_action_construct_discard (GType object_type, guint8 discard_tile);
void player_set_turn_action (Player* self, TurnAction* value);
GType player_player_state_get_type (void) G_GNUC_CONST;
void player_set_state (Player* self, PlayerPlayerState value);
void threading_start1 (ThreadingDel1Arg function, void* function_target, GObject* arg1);
static void computer_player_turn_decision_thread (GObject* player_obj);
static void _computer_player_turn_decision_thread_threading_del1_arg (GObject* arg1, gpointer self);
gboolean logic_can_closed_kan (GeeArrayList* hand);
gpointer call_ref (gpointer instance);
void call_unref (gpointer instance);
GParamSpec* param_spec_call (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_call (GValue* value, gpointer v_object);
void value_take_call (GValue* value, gpointer v_object);
gpointer value_get_call (const GValue* value);
GType call_get_type (void) G_GNUC_CONST;
GType pon_get_type (void) G_GNUC_CONST;
gboolean logic_can_late_kan (GeeArrayList* hand, GeeArrayList* pons);
GeeArrayList* player_get_pons (Player* self);
gboolean player_get_open_hand (Player* self);
GeeArrayList* logic_can_tenpai (GeeArrayList* hand);
gconstpointer obj_get_obj (Obj* self);
CallAction* bot_make_call (gint bot_level, ComputerPlayer* player, Tile* discard_tile, gboolean can_chi);
void player_set_call_action (Player* self, CallAction* value);
TurnAction* bot_make_move (gint bot_level, ComputerPlayer* player);
TurnAction* player_get_turn_action (Player* self);


ComputerPlayer* computer_player_construct (GType object_type, gint position, const gchar* name) {
	ComputerPlayer * self = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	self = (ComputerPlayer*) player_construct (object_type, position, name);
	return self;
}


ComputerPlayer* computer_player_new (gint position, const gchar* name) {
	return computer_player_construct (TYPE_COMPUTER_PLAYER, position, name);
}


static void _computer_player_call_decision_thread_threading_del3_arg (GObject* arg1, GObject* arg2, GObject* arg3, gpointer self) {
	computer_player_call_decision_thread (arg1, arg2, arg3);
}


static gboolean computer_player_real_call_decision (Player* base, Tile* discard_tile, gboolean can_chi) {
	ComputerPlayer * self;
	gboolean result = FALSE;
	Obj* _tmp0_ = NULL;
	Obj* _tmp1_;
	self = (ComputerPlayer*) base;
	g_return_val_if_fail (discard_tile != NULL, FALSE);
	PLAYER_CLASS (computer_player_parent_class)->call_decision (PLAYER (self), discard_tile, can_chi);
	_tmp0_ = obj_new (G_TYPE_BOOLEAN, NULL, NULL, GINT_TO_POINTER (can_chi));
	_tmp1_ = _tmp0_;
	threading_start3 (_computer_player_call_decision_thread_threading_del3_arg, NULL, (GObject*) self, (GObject*) discard_tile, (GObject*) _tmp1_);
	_g_object_unref0 (_tmp1_);
	result = TRUE;
	return result;
}


static void _computer_player_turn_decision_thread_threading_del1_arg (GObject* arg1, gpointer self) {
	computer_player_turn_decision_thread (arg1);
}


static gboolean computer_player_real_turn_decision (Player* base) {
	ComputerPlayer * self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_;
	gboolean _tmp15_;
	self = (ComputerPlayer*) base;
	g_print ("Bot starting decision\n");
	_tmp2_ = player_get_in_riichi ((Player*) self);
	if (_tmp2_) {
		GeeArrayList* _tmp3_ = NULL;
		gboolean _tmp4_;
		_tmp3_ = player_get_hand ((Player*) self);
		_tmp4_ = logic_winning_hand (_tmp3_);
		_tmp1_ = !_tmp4_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		GeeArrayList* _tmp5_ = NULL;
		gboolean _tmp6_;
		_tmp5_ = player_get_hand ((Player*) self);
		_tmp6_ = logic_can_riichi_closed_kan (_tmp5_);
		_tmp0_ = !_tmp6_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GeeArrayList* _tmp7_ = NULL;
		GeeArrayList* _tmp8_ = NULL;
		gint _tmp9_;
		gpointer _tmp10_ = NULL;
		Tile* _tmp11_;
		guint8 _tmp12_;
		TurnAction* _tmp13_ = NULL;
		TurnAction* _tmp14_;
		_tmp7_ = player_get_hand ((Player*) self);
		_tmp8_ = player_get_hand ((Player*) self);
		_tmp9_ = gee_collection_get_size ((GeeCollection*) _tmp8_);
		_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, _tmp9_ - 1);
		_tmp11_ = (Tile*) _tmp10_;
		_tmp12_ = tile_get_id (_tmp11_);
		_tmp13_ = turn_action_new_discard (_tmp12_);
		_tmp14_ = _tmp13_;
		player_set_turn_action ((Player*) self, _tmp14_);
		_turn_action_unref0 (_tmp14_);
		_g_object_unref0 (_tmp11_);
		player_set_state ((Player*) self, PLAYER_PLAYER_STATE_READY);
		result = FALSE;
		return result;
	}
	player_set_state ((Player*) self, PLAYER_PLAYER_STATE_DECIDING);
	threading_start1 (_computer_player_turn_decision_thread_threading_del1_arg, NULL, (GObject*) self);
	_tmp15_ = player_get_in_riichi ((Player*) self);
	if (_tmp15_) {
		gboolean _tmp16_ = FALSE;
		GeeArrayList* _tmp17_ = NULL;
		gboolean _tmp18_;
		_tmp17_ = player_get_hand ((Player*) self);
		_tmp18_ = logic_can_riichi_closed_kan (_tmp17_);
		if (_tmp18_) {
			_tmp16_ = TRUE;
		} else {
			GeeArrayList* _tmp19_ = NULL;
			gboolean _tmp20_;
			_tmp19_ = player_get_hand ((Player*) self);
			_tmp20_ = logic_winning_hand (_tmp19_);
			_tmp16_ = _tmp20_;
		}
		result = _tmp16_;
		return result;
	} else {
		gboolean _tmp21_ = FALSE;
		gboolean _tmp22_ = FALSE;
		gboolean _tmp23_ = FALSE;
		GeeArrayList* _tmp24_ = NULL;
		gboolean _tmp25_;
		_tmp24_ = player_get_hand ((Player*) self);
		_tmp25_ = logic_can_closed_kan (_tmp24_);
		if (_tmp25_) {
			_tmp23_ = TRUE;
		} else {
			GeeArrayList* _tmp26_ = NULL;
			GeeArrayList* _tmp27_ = NULL;
			gboolean _tmp28_;
			_tmp26_ = player_get_hand ((Player*) self);
			_tmp27_ = player_get_pons ((Player*) self);
			_tmp28_ = logic_can_late_kan (_tmp26_, _tmp27_);
			_tmp23_ = _tmp28_;
		}
		if (_tmp23_) {
			_tmp22_ = TRUE;
		} else {
			gboolean _tmp29_ = FALSE;
			gboolean _tmp30_;
			_tmp30_ = player_get_open_hand ((Player*) self);
			if (!_tmp30_) {
				GeeArrayList* _tmp31_ = NULL;
				GeeArrayList* _tmp32_ = NULL;
				GeeArrayList* _tmp33_;
				gint _tmp34_;
				_tmp31_ = player_get_hand ((Player*) self);
				_tmp32_ = logic_can_tenpai (_tmp31_);
				_tmp33_ = _tmp32_;
				_tmp34_ = gee_collection_get_size ((GeeCollection*) _tmp33_);
				_tmp29_ = _tmp34_ != 0;
				_g_object_unref0 (_tmp33_);
			} else {
				_tmp29_ = FALSE;
			}
			_tmp22_ = _tmp29_;
		}
		if (_tmp22_) {
			_tmp21_ = TRUE;
		} else {
			GeeArrayList* _tmp35_ = NULL;
			gboolean _tmp36_;
			_tmp35_ = player_get_hand ((Player*) self);
			_tmp36_ = logic_winning_hand (_tmp35_);
			_tmp21_ = _tmp36_;
		}
		result = _tmp21_;
		return result;
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void computer_player_call_decision_thread (GObject* player_obj, GObject* tile_obj, GObject* can_chi_obj) {
	ComputerPlayer* _tmp0_;
	ComputerPlayer* p;
	Tile* _tmp1_;
	Tile* discard_tile;
	gconstpointer _tmp2_ = NULL;
	gboolean can_chi;
	CallAction* _tmp3_ = NULL;
	CallAction* _tmp4_;
	g_return_if_fail (player_obj != NULL);
	g_return_if_fail (tile_obj != NULL);
	g_return_if_fail (can_chi_obj != NULL);
	g_print ("Bot starting call decision\n");
	_tmp0_ = _g_object_ref0 (COMPUTER_PLAYER (player_obj));
	p = _tmp0_;
	_tmp1_ = _g_object_ref0 (TILE (tile_obj));
	discard_tile = _tmp1_;
	_tmp2_ = obj_get_obj (OBJ (can_chi_obj));
	can_chi = GPOINTER_TO_INT (_tmp2_);
	_tmp3_ = bot_make_call (0, p, discard_tile, can_chi);
	_tmp4_ = _tmp3_;
	player_set_call_action ((Player*) p, _tmp4_);
	_call_action_unref0 (_tmp4_);
	player_set_state ((Player*) p, PLAYER_PLAYER_STATE_READY);
	_g_object_unref0 (discard_tile);
	_g_object_unref0 (p);
}


static void computer_player_turn_decision_thread (GObject* player_obj) {
	ComputerPlayer* _tmp0_;
	ComputerPlayer* p;
	TurnAction* _tmp1_ = NULL;
	TurnAction* _tmp2_;
	TurnAction* _tmp3_ = NULL;
	g_return_if_fail (player_obj != NULL);
	g_print ("Bot starting decision thread\n");
	_tmp0_ = _g_object_ref0 (COMPUTER_PLAYER (player_obj));
	p = _tmp0_;
	g_print ("in between\n");
	_tmp1_ = bot_make_move (0, p);
	_tmp2_ = _tmp1_;
	player_set_turn_action ((Player*) p, _tmp2_);
	_turn_action_unref0 (_tmp2_);
	g_print ("Bot finished decision\n");
	_tmp3_ = player_get_turn_action ((Player*) p);
	if (_tmp3_ != NULL) {
		player_set_state ((Player*) p, PLAYER_PLAYER_STATE_READY);
	}
	g_print ("Bot decision thread over\n");
	_g_object_unref0 (p);
}


static void computer_player_class_init (ComputerPlayerClass * klass) {
	computer_player_parent_class = g_type_class_peek_parent (klass);
	PLAYER_CLASS (klass)->call_decision = computer_player_real_call_decision;
	PLAYER_CLASS (klass)->turn_decision = computer_player_real_turn_decision;
}


static void computer_player_instance_init (ComputerPlayer * self) {
}


GType computer_player_get_type (void) {
	static volatile gsize computer_player_type_id__volatile = 0;
	if (g_once_init_enter (&computer_player_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ComputerPlayerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) computer_player_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ComputerPlayer), 0, (GInstanceInitFunc) computer_player_instance_init, NULL };
		GType computer_player_type_id;
		computer_player_type_id = g_type_register_static (TYPE_PLAYER, "ComputerPlayer", &g_define_type_info, 0);
		g_once_init_leave (&computer_player_type_id__volatile, computer_player_type_id);
	}
	return computer_player_type_id__volatile;
}



