/* MainMenu.c generated by valac 0.12.0, the Vala compiler
 * generated from MainMenu.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <SDL2/SDL_video.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <GL/glew.h>


#define TYPE_VIEW (view_get_type ())
#define VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VIEW, View))
#define VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VIEW, ViewClass))
#define IS_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VIEW))
#define IS_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VIEW))
#define VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VIEW, ViewClass))

typedef struct _View View;
typedef struct _ViewClass ViewClass;
typedef struct _ViewPrivate ViewPrivate;

#define TYPE_MAIN_MENU (main_menu_get_type ())
#define MAIN_MENU(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_MENU, MainMenu))
#define MAIN_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_MENU, MainMenuClass))
#define IS_MAIN_MENU(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_MENU))
#define IS_MAIN_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_MENU))
#define MAIN_MENU_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_MENU, MainMenuClass))

typedef struct _MainMenu MainMenu;
typedef struct _MainMenuClass MainMenuClass;
typedef struct _MainMenuPrivate MainMenuPrivate;

#define TYPE_MAIN_MENU_BACKGROUND (main_menu_background_get_type ())
#define MAIN_MENU_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_MENU_BACKGROUND, MainMenuBackground))
#define MAIN_MENU_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_MENU_BACKGROUND, MainMenuBackgroundClass))
#define IS_MAIN_MENU_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_MENU_BACKGROUND))
#define IS_MAIN_MENU_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_MENU_BACKGROUND))
#define MAIN_MENU_BACKGROUND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_MENU_BACKGROUND, MainMenuBackgroundClass))

typedef struct _MainMenuBackground MainMenuBackground;
typedef struct _MainMenuBackgroundClass MainMenuBackgroundClass;

#define TYPE_BUTTON (button_get_type ())
#define BUTTON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BUTTON, Button))
#define BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BUTTON, ButtonClass))
#define IS_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BUTTON))
#define IS_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BUTTON))
#define BUTTON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BUTTON, ButtonClass))

typedef struct _Button Button;
typedef struct _ButtonClass ButtonClass;

#define MAIN_MENU_TYPE_MENU_ACTION (main_menu_menu_action_get_type ())
#define _main_menu_background_unref0(var) ((var == NULL) ? NULL : (var = (main_menu_background_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _button_unref0(var) ((var == NULL) ? NULL : (var = (button_unref (var), NULL)))

#define TYPE_VECTOR (vector_get_type ())
#define VECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VECTOR, Vector))
#define VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VECTOR, VectorClass))
#define IS_VECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VECTOR))
#define IS_VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VECTOR))
#define VECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VECTOR, VectorClass))

typedef struct _Vector Vector;
typedef struct _VectorClass VectorClass;
#define _vector_unref0(var) ((var == NULL) ? NULL : (var = (vector_unref (var), NULL)))

#define ENVIRONMENT_TYPE_CURSOR_TYPE (environment_cursor_type_get_type ())

struct _View {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ViewPrivate * priv;
};

struct _ViewClass {
	GTypeClass parent_class;
	void (*finalize) (View *self);
	void (*process) (View* self, gdouble dt);
	void (*render) (View* self);
	void (*render_selection) (View* self);
	void (*render_interface) (View* self);
	void (*render_interface_selection) (View* self);
	void (*mouse_move) (View* self, gint x, gint y, guint color_id);
	void (*mouse_click) (View* self, gint x, gint y, gint button, gboolean state, guint color_id);
	void (*mouse_wheel) (View* self, gint amount);
};

struct _MainMenu {
	View parent_instance;
	MainMenuPrivate * priv;
};

struct _MainMenuClass {
	ViewClass parent_class;
};

typedef enum  {
	MAIN_MENU_MENU_ACTION_ACTIVE,
	MAIN_MENU_MENU_ACTION_SINGLE_PLAYER,
	MAIN_MENU_MENU_ACTION_HOST_MULTI_PLAYER,
	MAIN_MENU_MENU_ACTION_JOIN_MULTI_PLAYER,
	MAIN_MENU_MENU_ACTION_OPTIONS,
	MAIN_MENU_MENU_ACTION_EXIT
} MainMenuMenuAction;

struct _MainMenuPrivate {
	MainMenuBackground* background;
	SDL_Window* window;
	GeeArrayList* buttons;
	Button* ai_button;
	Button* host_button;
	Button* join_button;
	Button* exit_button;
	MainMenuMenuAction _action;
};

typedef enum  {
	ENVIRONMENT_CURSOR_TYPE_DEFAULT,
	ENVIRONMENT_CURSOR_TYPE_HOVER
} EnvironmentCursorType;


static gpointer main_menu_parent_class = NULL;

gpointer view_ref (gpointer instance);
void view_unref (gpointer instance);
GParamSpec* param_spec_view (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_view (GValue* value, gpointer v_object);
void value_take_view (GValue* value, gpointer v_object);
gpointer value_get_view (const GValue* value);
GType view_get_type (void) G_GNUC_CONST;
GType main_menu_get_type (void) G_GNUC_CONST;
gpointer main_menu_background_ref (gpointer instance);
void main_menu_background_unref (gpointer instance);
GParamSpec* param_spec_main_menu_background (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_main_menu_background (GValue* value, gpointer v_object);
void value_take_main_menu_background (GValue* value, gpointer v_object);
gpointer value_get_main_menu_background (const GValue* value);
GType main_menu_background_get_type (void) G_GNUC_CONST;
gpointer button_ref (gpointer instance);
void button_unref (gpointer instance);
GParamSpec* param_spec_button (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_button (GValue* value, gpointer v_object);
void value_take_button (GValue* value, gpointer v_object);
gpointer value_get_button (const GValue* value);
GType button_get_type (void) G_GNUC_CONST;
GType main_menu_menu_action_get_type (void) G_GNUC_CONST;
#define MAIN_MENU_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MAIN_MENU, MainMenuPrivate))
enum  {
	MAIN_MENU_DUMMY_PROPERTY
};
MainMenuBackground* main_menu_background_new (void);
MainMenuBackground* main_menu_background_construct (GType object_type);
Button* button_new (const gchar* name, guint color_id);
Button* button_construct (GType object_type, const gchar* name, guint color_id);
MainMenu* main_menu_new (SDL_Window* window);
MainMenu* main_menu_construct (GType object_type, SDL_Window* window);
View* view_construct (GType object_type);
static void main_menu_set_action (MainMenu* self, MainMenuMenuAction value);
Vector* vector_new (gfloat x, gfloat y, gfloat z);
Vector* vector_construct (GType object_type, gfloat x, gfloat y, gfloat z);
gpointer vector_ref (gpointer instance);
void vector_unref (gpointer instance);
GParamSpec* param_spec_vector (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_vector (GValue* value, gpointer v_object);
void value_take_vector (GValue* value, gpointer v_object);
gpointer value_get_vector (const GValue* value);
GType vector_get_type (void) G_GNUC_CONST;
void button_set_position (Button* self, Vector* value);
void button_set_visible (Button* self, gboolean value);
static void main_menu_ai_button_press (MainMenu* self, Button* b);
static void _main_menu_ai_button_press_button_press (Button* _sender, gpointer self);
void button_set_size (Button* self, gfloat value);
static void main_menu_host_button_press (MainMenu* self, Button* b);
static void _main_menu_host_button_press_button_press (Button* _sender, gpointer self);
static void main_menu_join_button_press (MainMenu* self, Button* b);
static void _main_menu_join_button_press_button_press (Button* _sender, gpointer self);
static void main_menu_exit_button_press (MainMenu* self, Button* b);
static void _main_menu_exit_button_press_button_press (Button* _sender, gpointer self);
static void main_menu_real_render (View* base);
void main_menu_background_render (MainMenuBackground* self);
static void main_menu_real_render_selection (View* base);
static void main_menu_real_render_interface (View* base);
void button_render (Button* self);
static void main_menu_real_render_interface_selection (View* base);
void button_render_selection (Button* self);
static void main_menu_real_process (View* base, gdouble dt);
void main_menu_background_process (MainMenuBackground* self, gdouble dt);
static void main_menu_real_mouse_move (View* base, gint x, gint y, guint color_id);
gboolean button_hover (Button* self, guint color_id);
GType environment_cursor_type_get_type (void) G_GNUC_CONST;
void environment_set_cursor (EnvironmentCursorType type);
static void main_menu_real_mouse_click (View* base, gint x, gint y, gint mouse_button, gboolean state, guint color_id);
gboolean button_click (Button* self, guint color_id, gboolean up);
static void main_menu_real_mouse_wheel (View* base, gint amount);
MainMenuMenuAction main_menu_get_action (MainMenu* self);
static void main_menu_finalize (View* obj);


GType main_menu_menu_action_get_type (void) {
	static volatile gsize main_menu_menu_action_type_id__volatile = 0;
	if (g_once_init_enter (&main_menu_menu_action_type_id__volatile)) {
		static const GEnumValue values[] = {{MAIN_MENU_MENU_ACTION_ACTIVE, "MAIN_MENU_MENU_ACTION_ACTIVE", "active"}, {MAIN_MENU_MENU_ACTION_SINGLE_PLAYER, "MAIN_MENU_MENU_ACTION_SINGLE_PLAYER", "single-player"}, {MAIN_MENU_MENU_ACTION_HOST_MULTI_PLAYER, "MAIN_MENU_MENU_ACTION_HOST_MULTI_PLAYER", "host-multi-player"}, {MAIN_MENU_MENU_ACTION_JOIN_MULTI_PLAYER, "MAIN_MENU_MENU_ACTION_JOIN_MULTI_PLAYER", "join-multi-player"}, {MAIN_MENU_MENU_ACTION_OPTIONS, "MAIN_MENU_MENU_ACTION_OPTIONS", "options"}, {MAIN_MENU_MENU_ACTION_EXIT, "MAIN_MENU_MENU_ACTION_EXIT", "exit"}, {0, NULL, NULL}};
		GType main_menu_menu_action_type_id;
		main_menu_menu_action_type_id = g_enum_register_static ("MainMenuMenuAction", values);
		g_once_init_leave (&main_menu_menu_action_type_id__volatile, main_menu_menu_action_type_id);
	}
	return main_menu_menu_action_type_id__volatile;
}


static void _main_menu_ai_button_press_button_press (Button* _sender, gpointer self) {
	main_menu_ai_button_press (self, _sender);
}


static void _main_menu_host_button_press_button_press (Button* _sender, gpointer self) {
	main_menu_host_button_press (self, _sender);
}


static void _main_menu_join_button_press_button_press (Button* _sender, gpointer self) {
	main_menu_join_button_press (self, _sender);
}


static void _main_menu_exit_button_press_button_press (Button* _sender, gpointer self) {
	main_menu_exit_button_press (self, _sender);
}


MainMenu* main_menu_construct (GType object_type, SDL_Window* window) {
	MainMenu* self = NULL;
	Vector* _tmp0_ = NULL;
	Vector* _tmp1_;
	Vector* _tmp2_ = NULL;
	Vector* _tmp3_;
	Vector* _tmp4_ = NULL;
	Vector* _tmp5_;
	Vector* _tmp6_ = NULL;
	Vector* _tmp7_;
	g_return_val_if_fail (window != NULL, NULL);
	self = (MainMenu*) view_construct (object_type);
	self->priv->window = window;
	main_menu_set_action (self, MAIN_MENU_MENU_ACTION_ACTIVE);
	_tmp0_ = vector_new (0.5f, 0.75f, (gfloat) 0);
	_tmp1_ = _tmp0_;
	button_set_position (self->priv->ai_button, _tmp1_);
	_vector_unref0 (_tmp1_);
	button_set_visible (self->priv->ai_button, TRUE);
	g_signal_connect (self->priv->ai_button, "press", (GCallback) _main_menu_ai_button_press_button_press, self);
	button_set_size (self->priv->ai_button, 0.4f);
	_tmp2_ = vector_new (0.5f, 0.25f, (gfloat) 0);
	_tmp3_ = _tmp2_;
	button_set_position (self->priv->host_button, _tmp3_);
	_vector_unref0 (_tmp3_);
	button_set_visible (self->priv->host_button, TRUE);
	g_signal_connect (self->priv->host_button, "press", (GCallback) _main_menu_host_button_press_button_press, self);
	button_set_size (self->priv->host_button, 0.4f);
	_tmp4_ = vector_new (0.5f, -0.25f, (gfloat) 0);
	_tmp5_ = _tmp4_;
	button_set_position (self->priv->join_button, _tmp5_);
	_vector_unref0 (_tmp5_);
	button_set_visible (self->priv->join_button, TRUE);
	g_signal_connect (self->priv->join_button, "press", (GCallback) _main_menu_join_button_press_button_press, self);
	button_set_size (self->priv->join_button, 0.4f);
	_tmp6_ = vector_new (0.5f, -0.75f, (gfloat) 0);
	_tmp7_ = _tmp6_;
	button_set_position (self->priv->exit_button, _tmp7_);
	_vector_unref0 (_tmp7_);
	button_set_visible (self->priv->exit_button, TRUE);
	g_signal_connect (self->priv->exit_button, "press", (GCallback) _main_menu_exit_button_press_button_press, self);
	button_set_size (self->priv->exit_button, 0.4f);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->buttons, self->priv->ai_button);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->buttons, self->priv->host_button);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->buttons, self->priv->join_button);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->buttons, self->priv->exit_button);
	return self;
}


MainMenu* main_menu_new (SDL_Window* window) {
	return main_menu_construct (TYPE_MAIN_MENU, window);
}


static void main_menu_ai_button_press (MainMenu* self, Button* b) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (b != NULL);
	main_menu_set_action (self, MAIN_MENU_MENU_ACTION_SINGLE_PLAYER);
	g_signal_emit_by_name (self, "menu-action");
}


static void main_menu_host_button_press (MainMenu* self, Button* b) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (b != NULL);
	main_menu_set_action (self, MAIN_MENU_MENU_ACTION_HOST_MULTI_PLAYER);
	g_signal_emit_by_name (self, "menu-action");
}


static void main_menu_join_button_press (MainMenu* self, Button* b) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (b != NULL);
	main_menu_set_action (self, MAIN_MENU_MENU_ACTION_JOIN_MULTI_PLAYER);
	g_signal_emit_by_name (self, "menu-action");
}


static void main_menu_exit_button_press (MainMenu* self, Button* b) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (b != NULL);
	main_menu_set_action (self, MAIN_MENU_MENU_ACTION_EXIT);
	g_signal_emit_by_name (self, "menu-action");
}


static void main_menu_real_render (View* base) {
	MainMenu * self;
	gfloat distance;
	self = (MainMenu*) base;
	glClearColor ((GLfloat) 0, (GLfloat) 0, (GLfloat) 0, (GLfloat) 0);
	glClear (GL_COLOR_BUFFER_BIT);
	distance = (gfloat) 3;
	glTranslatef ((GLfloat) 0, (GLfloat) 0, -((GLfloat) distance));
	glRotatef ((GLfloat) (-60), (GLfloat) 1, (GLfloat) 0, (GLfloat) 0);
	glScalef ((GLfloat) 0.5f, (GLfloat) 0.5f, (GLfloat) 0.5f);
	glTranslatef ((GLfloat) (-2), (GLfloat) 0, (GLfloat) 0);
	main_menu_background_render (self->priv->background);
}


static void main_menu_real_render_selection (View* base) {
	MainMenu * self;
	self = (MainMenu*) base;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void main_menu_real_render_interface (View* base) {
	MainMenu * self;
	self = (MainMenu*) base;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _b_list;
		gint _tmp1_;
		gint _b_size;
		gint _b_index;
		_tmp0_ = _g_object_ref0 (self->priv->buttons);
		_b_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _b_list);
		_b_size = _tmp1_;
		_b_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Button* b;
			_b_index = _b_index + 1;
			if (!(_b_index < _b_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _b_list, _b_index);
			b = (Button*) _tmp2_;
			button_render (b);
			_button_unref0 (b);
		}
		_g_object_unref0 (_b_list);
	}
}


static void main_menu_real_render_interface_selection (View* base) {
	MainMenu * self;
	self = (MainMenu*) base;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _b_list;
		gint _tmp1_;
		gint _b_size;
		gint _b_index;
		_tmp0_ = _g_object_ref0 (self->priv->buttons);
		_b_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _b_list);
		_b_size = _tmp1_;
		_b_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Button* b;
			_b_index = _b_index + 1;
			if (!(_b_index < _b_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _b_list, _b_index);
			b = (Button*) _tmp2_;
			button_render_selection (b);
			_button_unref0 (b);
		}
		_g_object_unref0 (_b_list);
	}
}


static void main_menu_real_process (View* base, gdouble dt) {
	MainMenu * self;
	self = (MainMenu*) base;
	main_menu_background_process (self->priv->background, dt);
}


static gpointer _button_ref0 (gpointer self) {
	return self ? button_ref (self) : NULL;
}


static void main_menu_real_mouse_move (View* base, gint x, gint y, guint color_id) {
	MainMenu * self;
	Button* button;
	EnvironmentCursorType _tmp5_ = 0;
	self = (MainMenu*) base;
	button = NULL;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _b_list;
		gint _tmp1_;
		gint _b_size;
		gint _b_index;
		_tmp0_ = _g_object_ref0 (self->priv->buttons);
		_b_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _b_list);
		_b_size = _tmp1_;
		_b_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Button* b;
			gboolean _tmp3_;
			_b_index = _b_index + 1;
			if (!(_b_index < _b_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _b_list, _b_index);
			b = (Button*) _tmp2_;
			_tmp3_ = button_hover (b, color_id);
			if (_tmp3_) {
				Button* _tmp4_;
				_tmp4_ = _button_ref0 (b);
				_button_unref0 (button);
				button = _tmp4_;
			}
			_button_unref0 (b);
		}
		_g_object_unref0 (_b_list);
	}
	if (button == NULL) {
		_tmp5_ = ENVIRONMENT_CURSOR_TYPE_DEFAULT;
	} else {
		_tmp5_ = ENVIRONMENT_CURSOR_TYPE_HOVER;
	}
	environment_set_cursor (_tmp5_);
	_button_unref0 (button);
}


static void main_menu_real_mouse_click (View* base, gint x, gint y, gint mouse_button, gboolean state, guint color_id) {
	MainMenu * self;
	self = (MainMenu*) base;
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _b_list;
		gint _tmp1_;
		gint _b_size;
		gint _b_index;
		_tmp0_ = _g_object_ref0 (self->priv->buttons);
		_b_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _b_list);
		_b_size = _tmp1_;
		_b_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			Button* b;
			_b_index = _b_index + 1;
			if (!(_b_index < _b_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _b_list, _b_index);
			b = (Button*) _tmp2_;
			button_click (b, color_id, state);
			_button_unref0 (b);
		}
		_g_object_unref0 (_b_list);
	}
}


static void main_menu_real_mouse_wheel (View* base, gint amount) {
	MainMenu * self;
	self = (MainMenu*) base;
}


MainMenuMenuAction main_menu_get_action (MainMenu* self) {
	MainMenuMenuAction result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_action;
	return result;
}


static void main_menu_set_action (MainMenu* self, MainMenuMenuAction value) {
	g_return_if_fail (self != NULL);
	self->priv->_action = value;
}


static void main_menu_class_init (MainMenuClass * klass) {
	main_menu_parent_class = g_type_class_peek_parent (klass);
	VIEW_CLASS (klass)->finalize = main_menu_finalize;
	g_type_class_add_private (klass, sizeof (MainMenuPrivate));
	VIEW_CLASS (klass)->render = main_menu_real_render;
	VIEW_CLASS (klass)->render_selection = main_menu_real_render_selection;
	VIEW_CLASS (klass)->render_interface = main_menu_real_render_interface;
	VIEW_CLASS (klass)->render_interface_selection = main_menu_real_render_interface_selection;
	VIEW_CLASS (klass)->process = main_menu_real_process;
	VIEW_CLASS (klass)->mouse_move = main_menu_real_mouse_move;
	VIEW_CLASS (klass)->mouse_click = main_menu_real_mouse_click;
	VIEW_CLASS (klass)->mouse_wheel = main_menu_real_mouse_wheel;
	g_signal_new ("menu_action", TYPE_MAIN_MENU, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void main_menu_instance_init (MainMenu * self) {
	MainMenuBackground* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	Button* _tmp2_ = NULL;
	Button* _tmp3_ = NULL;
	Button* _tmp4_ = NULL;
	Button* _tmp5_ = NULL;
	self->priv = MAIN_MENU_GET_PRIVATE (self);
	_tmp0_ = main_menu_background_new ();
	self->priv->background = _tmp0_;
	_tmp1_ = gee_array_list_new (TYPE_BUTTON, (GBoxedCopyFunc) button_ref, button_unref, NULL);
	self->priv->buttons = _tmp1_;
	_tmp2_ = button_new ("AI", (guint) 1);
	self->priv->ai_button = _tmp2_;
	_tmp3_ = button_new ("Host", (guint) 2);
	self->priv->host_button = _tmp3_;
	_tmp4_ = button_new ("Join", (guint) 3);
	self->priv->join_button = _tmp4_;
	_tmp5_ = button_new ("Exit", (guint) 4);
	self->priv->exit_button = _tmp5_;
}


static void main_menu_finalize (View* obj) {
	MainMenu * self;
	self = MAIN_MENU (obj);
	_main_menu_background_unref0 (self->priv->background);
	_g_object_unref0 (self->priv->buttons);
	_button_unref0 (self->priv->ai_button);
	_button_unref0 (self->priv->host_button);
	_button_unref0 (self->priv->join_button);
	_button_unref0 (self->priv->exit_button);
	VIEW_CLASS (main_menu_parent_class)->finalize (obj);
}


GType main_menu_get_type (void) {
	static volatile gsize main_menu_type_id__volatile = 0;
	if (g_once_init_enter (&main_menu_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MainMenuClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) main_menu_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MainMenu), 0, (GInstanceInitFunc) main_menu_instance_init, NULL };
		GType main_menu_type_id;
		main_menu_type_id = g_type_register_static (TYPE_VIEW, "MainMenu", &g_define_type_info, 0);
		g_once_init_leave (&main_menu_type_id__volatile, main_menu_type_id);
	}
	return main_menu_type_id__volatile;
}



