/* OpenGLRenderer.c generated by valac 0.12.0, the Vala compiler
 * generated from OpenGLRenderer.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <GL/glew.h>
#include <SDL2/SDL_video.h>
#include <SDL2/SDL_image.h>
#include <float.h>
#include <math.h>
#include <gee.h>


#define TYPE_IRENDER_TARGET (irender_target_get_type ())
#define IRENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IRENDER_TARGET, IRenderTarget))
#define IS_IRENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IRENDER_TARGET))
#define IRENDER_TARGET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IRENDER_TARGET, IRenderTargetIface))

typedef struct _IRenderTarget IRenderTarget;
typedef struct _IRenderTargetIface IRenderTargetIface;

#define TYPE_RENDER_STATE (render_state_get_type ())
#define RENDER_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER_STATE, RenderState))
#define RENDER_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER_STATE, RenderStateClass))
#define IS_RENDER_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER_STATE))
#define IS_RENDER_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER_STATE))
#define RENDER_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER_STATE, RenderStateClass))

typedef struct _RenderState RenderState;
typedef struct _RenderStateClass RenderStateClass;

#define TYPE_RESOURCE3_DOBJECT (resource3_dobject_get_type ())
#define RESOURCE3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE3_DOBJECT, Resource3DObject))
#define RESOURCE3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE3_DOBJECT, Resource3DObjectClass))
#define IS_RESOURCE3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE3_DOBJECT))
#define IS_RESOURCE3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE3_DOBJECT))
#define RESOURCE3_DOBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE3_DOBJECT, Resource3DObjectClass))

typedef struct _Resource3DObject Resource3DObject;
typedef struct _Resource3DObjectClass Resource3DObjectClass;

#define TYPE_RESOURCE_TEXTURE (resource_texture_get_type ())
#define RESOURCE_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE_TEXTURE, ResourceTexture))
#define RESOURCE_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE_TEXTURE, ResourceTextureClass))
#define IS_RESOURCE_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE_TEXTURE))
#define IS_RESOURCE_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE_TEXTURE))
#define RESOURCE_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE_TEXTURE, ResourceTextureClass))

typedef struct _ResourceTexture ResourceTexture;
typedef struct _ResourceTextureClass ResourceTextureClass;

#define TYPE_IRESOURCE_STORE (iresource_store_get_type ())
#define IRESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IRESOURCE_STORE, IResourceStore))
#define IS_IRESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IRESOURCE_STORE))
#define IRESOURCE_STORE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IRESOURCE_STORE, IResourceStoreIface))

typedef struct _IResourceStore IResourceStore;
typedef struct _IResourceStoreIface IResourceStoreIface;

#define TYPE_RENDER3_DOBJECT (render3_dobject_get_type ())
#define RENDER3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER3_DOBJECT, Render3DObject))
#define RENDER3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER3_DOBJECT, Render3DObjectClass))
#define IS_RENDER3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER3_DOBJECT))
#define IS_RENDER3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER3_DOBJECT))
#define RENDER3_DOBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER3_DOBJECT, Render3DObjectClass))

typedef struct _Render3DObject Render3DObject;
typedef struct _Render3DObjectClass Render3DObjectClass;

#define TYPE_RENDER_TARGET (render_target_get_type ())
#define RENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER_TARGET, RenderTarget))
#define RENDER_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER_TARGET, RenderTargetClass))
#define IS_RENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER_TARGET))
#define IS_RENDER_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER_TARGET))
#define RENDER_TARGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER_TARGET, RenderTargetClass))

typedef struct _RenderTarget RenderTarget;
typedef struct _RenderTargetClass RenderTargetClass;
typedef struct _RenderTargetPrivate RenderTargetPrivate;

#define TYPE_IOBJECT3_DRESOURCE_HANDLE (iobject3_dresource_handle_get_type ())
#define IOBJECT3_DRESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IOBJECT3_DRESOURCE_HANDLE, IObject3DResourceHandle))
#define IS_IOBJECT3_DRESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IOBJECT3_DRESOURCE_HANDLE))
#define IOBJECT3_DRESOURCE_HANDLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IOBJECT3_DRESOURCE_HANDLE, IObject3DResourceHandleIface))

typedef struct _IObject3DResourceHandle IObject3DResourceHandle;
typedef struct _IObject3DResourceHandleIface IObject3DResourceHandleIface;

#define TYPE_ITEXTURE_RESOURCE_HANDLE (itexture_resource_handle_get_type ())
#define ITEXTURE_RESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ITEXTURE_RESOURCE_HANDLE, ITextureResourceHandle))
#define IS_ITEXTURE_RESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ITEXTURE_RESOURCE_HANDLE))
#define ITEXTURE_RESOURCE_HANDLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_ITEXTURE_RESOURCE_HANDLE, ITextureResourceHandleIface))

typedef struct _ITextureResourceHandle ITextureResourceHandle;
typedef struct _ITextureResourceHandleIface ITextureResourceHandleIface;

#define TYPE_IWINDOW_TARGET (iwindow_target_get_type ())
#define IWINDOW_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IWINDOW_TARGET, IWindowTarget))
#define IS_IWINDOW_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IWINDOW_TARGET))
#define IWINDOW_TARGET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IWINDOW_TARGET, IWindowTargetIface))

typedef struct _IWindowTarget IWindowTarget;
typedef struct _IWindowTargetIface IWindowTargetIface;

#define TYPE_RESOURCE_STORE (resource_store_get_type ())
#define RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE_STORE, ResourceStore))
#define RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE_STORE, ResourceStoreClass))
#define IS_RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE_STORE))
#define IS_RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE_STORE))
#define RESOURCE_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE_STORE, ResourceStoreClass))

typedef struct _ResourceStore ResourceStore;
typedef struct _ResourceStoreClass ResourceStoreClass;

#define TYPE_OPEN_GL_RESOURCE_STORE (open_gl_resource_store_get_type ())
#define OPEN_GL_RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OPEN_GL_RESOURCE_STORE, OpenGLResourceStore))
#define OPEN_GL_RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OPEN_GL_RESOURCE_STORE, OpenGLResourceStoreClass))
#define IS_OPEN_GL_RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OPEN_GL_RESOURCE_STORE))
#define IS_OPEN_GL_RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OPEN_GL_RESOURCE_STORE))
#define OPEN_GL_RESOURCE_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OPEN_GL_RESOURCE_STORE, OpenGLResourceStoreClass))

typedef struct _OpenGLResourceStore OpenGLResourceStore;
typedef struct _OpenGLResourceStoreClass OpenGLResourceStoreClass;

#define TYPE_OPEN_GL_RENDERER (open_gl_renderer_get_type ())
#define OPEN_GL_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OPEN_GL_RENDERER, OpenGLRenderer))
#define OPEN_GL_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OPEN_GL_RENDERER, OpenGLRendererClass))
#define IS_OPEN_GL_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OPEN_GL_RENDERER))
#define IS_OPEN_GL_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OPEN_GL_RENDERER))
#define OPEN_GL_RENDERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OPEN_GL_RENDERER, OpenGLRendererClass))

typedef struct _OpenGLRenderer OpenGLRenderer;
typedef struct _OpenGLRendererClass OpenGLRendererClass;
typedef struct _OpenGLRendererPrivate OpenGLRendererPrivate;

#define TYPE_SDL_WINDOW_TARGET (sdl_window_target_get_type ())
#define SDL_WINDOW_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SDL_WINDOW_TARGET, SDLWindowTarget))
#define SDL_WINDOW_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SDL_WINDOW_TARGET, SDLWindowTargetClass))
#define IS_SDL_WINDOW_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SDL_WINDOW_TARGET))
#define IS_SDL_WINDOW_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SDL_WINDOW_TARGET))
#define SDL_WINDOW_TARGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SDL_WINDOW_TARGET, SDLWindowTargetClass))

typedef struct _SDLWindowTarget SDLWindowTarget;
typedef struct _SDLWindowTargetClass SDLWindowTargetClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_MODEL_POINT (model_point_get_type ())

#define TYPE_MODEL_VERTEX (model_vertex_get_type ())
typedef struct _ModelVertex ModelVertex;

#define TYPE_MODEL_UV (model_uv_get_type ())
typedef struct _ModelUV ModelUV;

#define TYPE_MODEL_NORMAL (model_normal_get_type ())
typedef struct _ModelNormal ModelNormal;
typedef struct _ModelPoint ModelPoint;

#define TYPE_OPEN_GL_OBJECT3_DRESOURCE_HANDLE (open_gl_object3_dresource_handle_get_type ())
#define OPEN_GL_OBJECT3_DRESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OPEN_GL_OBJECT3_DRESOURCE_HANDLE, OpenGLObject3DResourceHandle))
#define OPEN_GL_OBJECT3_DRESOURCE_HANDLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OPEN_GL_OBJECT3_DRESOURCE_HANDLE, OpenGLObject3DResourceHandleClass))
#define IS_OPEN_GL_OBJECT3_DRESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OPEN_GL_OBJECT3_DRESOURCE_HANDLE))
#define IS_OPEN_GL_OBJECT3_DRESOURCE_HANDLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OPEN_GL_OBJECT3_DRESOURCE_HANDLE))
#define OPEN_GL_OBJECT3_DRESOURCE_HANDLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OPEN_GL_OBJECT3_DRESOURCE_HANDLE, OpenGLObject3DResourceHandleClass))

typedef struct _OpenGLObject3DResourceHandle OpenGLObject3DResourceHandle;
typedef struct _OpenGLObject3DResourceHandleClass OpenGLObject3DResourceHandleClass;

#define TYPE_OPEN_GL_TEXTURE_RESOURCE_HANDLE (open_gl_texture_resource_handle_get_type ())
#define OPEN_GL_TEXTURE_RESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OPEN_GL_TEXTURE_RESOURCE_HANDLE, OpenGLTextureResourceHandle))
#define OPEN_GL_TEXTURE_RESOURCE_HANDLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OPEN_GL_TEXTURE_RESOURCE_HANDLE, OpenGLTextureResourceHandleClass))
#define IS_OPEN_GL_TEXTURE_RESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OPEN_GL_TEXTURE_RESOURCE_HANDLE))
#define IS_OPEN_GL_TEXTURE_RESOURCE_HANDLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OPEN_GL_TEXTURE_RESOURCE_HANDLE))
#define OPEN_GL_TEXTURE_RESOURCE_HANDLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OPEN_GL_TEXTURE_RESOURCE_HANDLE, OpenGLTextureResourceHandleClass))

typedef struct _OpenGLTextureResourceHandle OpenGLTextureResourceHandle;
typedef struct _OpenGLTextureResourceHandleClass OpenGLTextureResourceHandleClass;

#define TYPE_COLOR (color_get_type ())
typedef struct _Color Color;

#define TYPE_VEC3 (vec3_get_type ())
typedef struct _Vec3 Vec3;
#define _render3_dobject_unref0(var) ((var == NULL) ? NULL : (var = (render3_dobject_unref (var), NULL)))

#define TYPE_RENDER_TEXTURE (render_texture_get_type ())
#define RENDER_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER_TEXTURE, RenderTexture))
#define RENDER_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER_TEXTURE, RenderTextureClass))
#define IS_RENDER_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER_TEXTURE))
#define IS_RENDER_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER_TEXTURE))
#define RENDER_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER_TEXTURE, RenderTextureClass))

typedef struct _RenderTexture RenderTexture;
typedef struct _RenderTextureClass RenderTextureClass;

struct _IResourceStoreIface {
	GTypeInterface parent_iface;
	Render3DObject* (*load_3D_object) (IResourceStore* self, const gchar* name);
};

struct _IRenderTargetIface {
	GTypeInterface parent_iface;
	void (*set_state) (IRenderTarget* self, RenderState* state);
	gboolean (*start) (IRenderTarget* self);
	void (*stop) (IRenderTarget* self);
	guint (*load_3D_object) (IRenderTarget* self, Resource3DObject* object);
	guint (*load_texture) (IRenderTarget* self, ResourceTexture* texture);
	IResourceStore* (*get_resource_store) (IRenderTarget* self);
};

struct _IObject3DResourceHandleIface {
	GTypeInterface parent_iface;
};

struct _ITextureResourceHandleIface {
	GTypeInterface parent_iface;
};

struct _IWindowTargetIface {
	GTypeInterface parent_iface;
	void (*swap) (IWindowTarget* self);
	void (*pump_events) (IWindowTarget* self);
	gboolean (*get_fullscreen) (IWindowTarget* self);
	void (*set_fullscreen) (IWindowTarget* self, gboolean value);
	gint (*get_width) (IWindowTarget* self);
	gint (*get_height) (IWindowTarget* self);
};

struct _RenderTarget {
	GObject parent_instance;
	RenderTargetPrivate * priv;
	IWindowTarget* window;
	OpenGLResourceStore* store;
};

struct _RenderTargetClass {
	GObjectClass parent_class;
	void (*render) (RenderTarget* self, RenderState* state);
	gboolean (*init) (RenderTarget* self);
	IObject3DResourceHandle* (*do_load_3D_object) (RenderTarget* self, Resource3DObject* obj);
	ITextureResourceHandle* (*do_load_texture) (RenderTarget* self, ResourceTexture* texture);
};

struct _OpenGLRenderer {
	RenderTarget parent_instance;
	OpenGLRendererPrivate * priv;
};

struct _OpenGLRendererClass {
	RenderTargetClass parent_class;
};

struct _OpenGLRendererPrivate {
	gchar** vertex_source;
	gint vertex_source_length1;
	gint _vertex_source_size_;
	gchar** fragment_source;
	gint fragment_source_length1;
	gint _fragment_source_size_;
	GLuint shader_program;
	GLuint vertex_shader;
	GLuint fragment_shader;
	GLuint pos_attrib;
	GLuint tex_attrib;
	GLuint nor_attrib;
	GLuint texture_location;
	GLuint rotation_attrib;
	GLuint position_attrib;
	GLuint scale_attrib;
	GLuint camera_rotation_attrib;
	GLuint camera_position_attrib;
	GLuint aspect_ratio_attrib;
	SDL_GLContext* context;
	SDL_Window* sdl_window;
	gint view_width;
	gint view_height;
};

struct _ModelVertex {
	gfloat x;
	gfloat y;
	gfloat z;
	gfloat w;
};

struct _ModelUV {
	gfloat u;
	gfloat v;
	gfloat w;
};

struct _ModelNormal {
	gfloat i;
	gfloat j;
	gfloat k;
};

struct _ModelPoint {
	ModelVertex vertex;
	ModelUV uv;
	ModelNormal normal;
};

struct _Color {
	gfloat r;
	gfloat g;
	gfloat b;
	gfloat a;
};

struct _Vec3 {
	gfloat x;
	gfloat y;
	gfloat z;
};


static gpointer open_gl_renderer_parent_class = NULL;

gpointer render_state_ref (gpointer instance);
void render_state_unref (gpointer instance);
GParamSpec* param_spec_render_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render_state (GValue* value, gpointer v_object);
void value_take_render_state (GValue* value, gpointer v_object);
gpointer value_get_render_state (const GValue* value);
GType render_state_get_type (void) G_GNUC_CONST;
gpointer resource3_dobject_ref (gpointer instance);
void resource3_dobject_unref (gpointer instance);
GParamSpec* param_spec_resource3_dobject (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_resource3_dobject (GValue* value, gpointer v_object);
void value_take_resource3_dobject (GValue* value, gpointer v_object);
gpointer value_get_resource3_dobject (const GValue* value);
GType resource3_dobject_get_type (void) G_GNUC_CONST;
gpointer resource_texture_ref (gpointer instance);
void resource_texture_unref (gpointer instance);
GParamSpec* param_spec_resource_texture (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_resource_texture (GValue* value, gpointer v_object);
void value_take_resource_texture (GValue* value, gpointer v_object);
gpointer value_get_resource_texture (const GValue* value);
GType resource_texture_get_type (void) G_GNUC_CONST;
gpointer render3_dobject_ref (gpointer instance);
void render3_dobject_unref (gpointer instance);
GParamSpec* param_spec_render3_dobject (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render3_dobject (GValue* value, gpointer v_object);
void value_take_render3_dobject (GValue* value, gpointer v_object);
gpointer value_get_render3_dobject (const GValue* value);
GType render3_dobject_get_type (void) G_GNUC_CONST;
GType iresource_store_get_type (void) G_GNUC_CONST;
GType irender_target_get_type (void) G_GNUC_CONST;
GType render_target_get_type (void) G_GNUC_CONST;
GType iobject3_dresource_handle_get_type (void) G_GNUC_CONST;
GType itexture_resource_handle_get_type (void) G_GNUC_CONST;
GType iwindow_target_get_type (void) G_GNUC_CONST;
GType resource_store_get_type (void) G_GNUC_CONST;
GType open_gl_resource_store_get_type (void) G_GNUC_CONST;
GType open_gl_renderer_get_type (void) G_GNUC_CONST;
#define OPEN_GL_RENDERER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_OPEN_GL_RENDERER, OpenGLRendererPrivate))
enum  {
	OPEN_GL_RENDERER_DUMMY_PROPERTY
};
GType sdl_window_target_get_type (void) G_GNUC_CONST;
OpenGLRenderer* open_gl_renderer_new (SDLWindowTarget* window);
OpenGLRenderer* open_gl_renderer_construct (GType object_type, SDLWindowTarget* window);
RenderTarget* render_target_construct (GType object_type, IWindowTarget* window);
SDL_Window* sdl_window_target_get_sdl_window (SDLWindowTarget* self);
OpenGLResourceStore* open_gl_resource_store_new (OpenGLRenderer* renderer);
OpenGLResourceStore* open_gl_resource_store_construct (GType object_type, OpenGLRenderer* renderer);
static gboolean open_gl_renderer_real_init (RenderTarget* base);
static void open_gl_renderer_init_shader (OpenGLRenderer* self);
gchar** file_loader_load (const gchar* name, int* result_length1);
static void open_gl_renderer_real_render (RenderTarget* base, RenderState* state);
static void open_gl_renderer_render_scene (OpenGLRenderer* self, RenderState* state);
static IObject3DResourceHandle* open_gl_renderer_real_do_load_3D_object (RenderTarget* base, Resource3DObject* obj);
GType model_point_get_type (void) G_GNUC_CONST;
GType model_vertex_get_type (void) G_GNUC_CONST;
ModelVertex* model_vertex_dup (const ModelVertex* self);
void model_vertex_free (ModelVertex* self);
GType model_uv_get_type (void) G_GNUC_CONST;
ModelUV* model_uv_dup (const ModelUV* self);
void model_uv_free (ModelUV* self);
GType model_normal_get_type (void) G_GNUC_CONST;
ModelNormal* model_normal_dup (const ModelNormal* self);
void model_normal_free (ModelNormal* self);
ModelPoint* model_point_dup (const ModelPoint* self);
void model_point_free (ModelPoint* self);
ModelPoint* resource3_dobject_get_points (Resource3DObject* self, int* result_length1);
OpenGLObject3DResourceHandle* open_gl_object3_dresource_handle_new (GLuint handle, gint triangle_count);
OpenGLObject3DResourceHandle* open_gl_object3_dresource_handle_construct (GType object_type, GLuint handle, gint triangle_count);
GType open_gl_object3_dresource_handle_get_type (void) G_GNUC_CONST;
static ITextureResourceHandle* open_gl_renderer_real_do_load_texture (RenderTarget* base, ResourceTexture* texture);
gint resource_texture_get_width (ResourceTexture* self);
gint resource_texture_get_height (ResourceTexture* self);
gchar* resource_texture_get_data (ResourceTexture* self);
OpenGLTextureResourceHandle* open_gl_texture_resource_handle_new (GLuint handle);
OpenGLTextureResourceHandle* open_gl_texture_resource_handle_construct (GType object_type, GLuint handle);
GType open_gl_texture_resource_handle_get_type (void) G_GNUC_CONST;
static void open_gl_renderer_setup_projection (OpenGLRenderer* self, RenderState* state, gboolean ortho);
GType color_get_type (void) G_GNUC_CONST;
Color* color_dup (const Color* self);
void color_free (Color* self);
void render_state_get_back_color (RenderState* self, Color* result);
GType vec3_get_type (void) G_GNUC_CONST;
Vec3* vec3_dup (const Vec3* self);
void vec3_free (Vec3* self);
void render_state_get_camera_position (RenderState* self, Vec3* result);
void render_state_get_camera_rotation (RenderState* self, Vec3* result);
gint render_state_get_screen_width (RenderState* self);
gint render_state_get_screen_height (RenderState* self);
GeeArrayList* render_state_get_objects (RenderState* self);
static void open_gl_renderer_render_3D_object (OpenGLRenderer* self, Render3DObject* obj);
void iwindow_target_swap (IWindowTarget* self);
ITextureResourceHandle* render_target_get_texture (RenderTarget* self, guint handle);
gpointer render_texture_ref (gpointer instance);
void render_texture_unref (gpointer instance);
GParamSpec* param_spec_render_texture (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render_texture (GValue* value, gpointer v_object);
void value_take_render_texture (GValue* value, gpointer v_object);
gpointer value_get_render_texture (const GValue* value);
GType render_texture_get_type (void) G_GNUC_CONST;
RenderTexture* render3_dobject_get_texture (Render3DObject* self);
guint render_texture_get_handle (RenderTexture* self);
guint open_gl_texture_resource_handle_get_handle (OpenGLTextureResourceHandle* self);
IObject3DResourceHandle* render_target_get_3D_object (RenderTarget* self, guint handle);
guint render3_dobject_get_handle (Render3DObject* self);
guint open_gl_object3_dresource_handle_get_handle (OpenGLObject3DResourceHandle* self);
void render3_dobject_get_rotation (Render3DObject* self, Vec3* result);
void render3_dobject_get_position (Render3DObject* self, Vec3* result);
void render3_dobject_get_scale (Render3DObject* self, Vec3* result);
gint open_gl_object3_dresource_handle_get_triangle_count (OpenGLObject3DResourceHandle* self);
static void open_gl_renderer_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


OpenGLRenderer* open_gl_renderer_construct (GType object_type, SDLWindowTarget* window) {
	OpenGLRenderer * self = NULL;
	SDL_Window* _tmp0_ = NULL;
	OpenGLResourceStore* _tmp1_ = NULL;
	g_return_val_if_fail (window != NULL, NULL);
	self = (OpenGLRenderer*) render_target_construct (object_type, (IWindowTarget*) window);
	_tmp0_ = sdl_window_target_get_sdl_window (window);
	self->priv->sdl_window = _tmp0_;
	_tmp1_ = open_gl_resource_store_new (self);
	_g_object_unref0 (((RenderTarget*) self)->store);
	((RenderTarget*) self)->store = _tmp1_;
	return self;
}


OpenGLRenderer* open_gl_renderer_new (SDLWindowTarget* window) {
	return open_gl_renderer_construct (TYPE_OPEN_GL_RENDERER, window);
}


static gboolean open_gl_renderer_real_init (RenderTarget* base) {
	OpenGLRenderer * self;
	gboolean result = FALSE;
	SDL_GLContext* _tmp0_ = NULL;
	SDL_Surface* _tmp1_ = NULL;
	self = (OpenGLRenderer*) base;
	_tmp0_ = SDL_GL_CreateContext (self->priv->sdl_window);
	self->priv->context = _tmp0_;
	if (self->priv->context == NULL) {
		result = FALSE;
		return result;
	}
	SDL_GL_SetAttribute (SDL_GL_CONTEXT_MAJOR_VERSION, 4);
	SDL_GL_SetAttribute (SDL_GL_CONTEXT_MINOR_VERSION, 0);
	SDL_GL_SetSwapInterval (1);
	glewInit ();
	glEnable (GL_CULL_FACE);
	glEnable (GL_DEPTH_TEST);
	glDepthFunc ((GLenum) GL_LEQUAL);
	glEnable (GL_LINE_SMOOTH);
	glEnable (GL_BLEND);
	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glEnable (GL_FRAMEBUFFER_SRGB);
	glEnable (GL_MULTISAMPLE);
	_tmp1_ = IMG_Load ("textures/Icon.png");
	SDL_SetWindowIcon (self->priv->sdl_window, _tmp1_);
	SDL_SetWindowSize (self->priv->sdl_window, 800, 800);
	open_gl_renderer_init_shader (self);
	result = TRUE;
	return result;
}


static void open_gl_renderer_init_shader (OpenGLRenderer* self) {
	gint _tmp0_;
	gchar** _tmp1_ = NULL;
	gint _tmp2_;
	gchar** _tmp3_ = NULL;
	GLuint _tmp4_;
	GLuint _tmp5_;
	GLint _tmp12_[1] = {0};
	GLint success[1];
	GLuint _tmp17_;
	GLint _tmp18_;
	GLint _tmp19_;
	GLint _tmp20_;
	GLint _tmp21_;
	GLint _tmp22_;
	GLint _tmp23_;
	GLint _tmp24_;
	GLuint len;
	GLenum _tmp25_;
	g_return_if_fail (self != NULL);
	_tmp1_ = file_loader_load ("./3d/vertex_shader.shader", &_tmp0_);
	self->priv->vertex_source = (_vala_array_free (self->priv->vertex_source, self->priv->vertex_source_length1, (GDestroyNotify) g_free), NULL);
	self->priv->vertex_source = _tmp1_;
	self->priv->vertex_source_length1 = _tmp0_;
	self->priv->_vertex_source_size_ = _tmp0_;
	_tmp3_ = file_loader_load ("./3d/fragment_shader.shader", &_tmp2_);
	self->priv->fragment_source = (_vala_array_free (self->priv->fragment_source, self->priv->fragment_source_length1, (GDestroyNotify) g_free), NULL);
	self->priv->fragment_source = _tmp3_;
	self->priv->fragment_source_length1 = _tmp2_;
	self->priv->_fragment_source_size_ = _tmp2_;
	_tmp4_ = glCreateShader (GL_VERTEX_SHADER);
	self->priv->vertex_shader = _tmp4_;
	_tmp5_ = glCreateShader (GL_FRAGMENT_SHADER);
	self->priv->fragment_shader = _tmp5_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gchar* _tmp7_;
				gchar* _tmp8_;
				if (!_tmp6_) {
					i++;
				}
				_tmp6_ = FALSE;
				if (!(i < self->priv->vertex_source_length1)) {
					break;
				}
				_tmp7_ = g_strconcat (self->priv->vertex_source[i], "\n", NULL);
				_tmp8_ = _tmp7_;
				_g_free0 (self->priv->vertex_source[i]);
				self->priv->vertex_source[i] = _tmp8_;
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				gchar* _tmp10_;
				gchar* _tmp11_;
				if (!_tmp9_) {
					i++;
				}
				_tmp9_ = FALSE;
				if (!(i < self->priv->fragment_source_length1)) {
					break;
				}
				_tmp10_ = g_strconcat (self->priv->fragment_source[i], "\n", NULL);
				_tmp11_ = _tmp10_;
				_g_free0 (self->priv->fragment_source[i]);
				self->priv->fragment_source[i] = _tmp11_;
			}
		}
	}
	glShaderSource (self->priv->vertex_shader, (GLsizei) self->priv->vertex_source_length1, self->priv->vertex_source, (GLint*) 0);
	glShaderSource (self->priv->fragment_shader, (GLsizei) self->priv->fragment_source_length1, self->priv->fragment_source, (GLint*) 0);
	glCompileShader (self->priv->vertex_shader);
	_tmp12_[0] = (GLint) (-1);
	memcpy (success, _tmp12_, 1 * sizeof (GLint));
	glGetShaderiv (self->priv->vertex_shader, GL_COMPILE_STATUS, success);
	if (success[0] == GL_FALSE) {
		GLsizei log_size[1] = {0};
		GLchar* _tmp13_ = NULL;
		GLchar* error_log;
		gint error_log_length1;
		gint _error_log_size_;
		g_print ("Vertex shader compilation failure!!!\n");
		glGetShaderiv (self->priv->vertex_shader, GL_INFO_LOG_LENGTH, log_size);
		_tmp13_ = g_new0 (GLchar, log_size[0]);
		error_log = _tmp13_;
		error_log_length1 = log_size[0];
		_error_log_size_ = log_size[0];
		glGetShaderInfoLog (self->priv->vertex_shader, log_size[0], log_size, error_log);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp14_;
				_tmp14_ = TRUE;
				while (TRUE) {
					if (!_tmp14_) {
						i++;
					}
					_tmp14_ = FALSE;
					if (!(i < log_size[0])) {
						break;
					}
					g_print ("%c", (gint) error_log[i]);
				}
			}
		}
		error_log = (g_free (error_log), NULL);
	}
	glCompileShader (self->priv->fragment_shader);
	glGetShaderiv (self->priv->fragment_shader, GL_COMPILE_STATUS, success);
	if (success[0] == GL_FALSE) {
		GLsizei log_size[1] = {0};
		GLchar* _tmp15_ = NULL;
		GLchar* error_log;
		gint error_log_length1;
		gint _error_log_size_;
		g_print ("Fragment shader compilation failure!!!\n");
		glGetShaderiv (self->priv->fragment_shader, GL_INFO_LOG_LENGTH, log_size);
		_tmp15_ = g_new0 (GLchar, log_size[0]);
		error_log = _tmp15_;
		error_log_length1 = log_size[0];
		_error_log_size_ = log_size[0];
		glGetShaderInfoLog (self->priv->fragment_shader, log_size[0], log_size, error_log);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp16_;
				_tmp16_ = TRUE;
				while (TRUE) {
					if (!_tmp16_) {
						i++;
					}
					_tmp16_ = FALSE;
					if (!(i < log_size[0])) {
						break;
					}
					g_print ("%c", (gint) error_log[i]);
				}
			}
		}
		error_log = (g_free (error_log), NULL);
	}
	_tmp17_ = glCreateProgram ();
	self->priv->shader_program = _tmp17_;
	glAttachShader (self->priv->shader_program, self->priv->vertex_shader);
	glAttachShader (self->priv->shader_program, self->priv->fragment_shader);
	glBindFragDataLocation (self->priv->shader_program, (GLuint) 0, "outColor");
	glBindAttribLocation (self->priv->shader_program, self->priv->pos_attrib, "position");
	glBindAttribLocation (self->priv->shader_program, self->priv->tex_attrib, "texcoord");
	glBindAttribLocation (self->priv->shader_program, self->priv->nor_attrib, "normals");
	glLinkProgram (self->priv->shader_program);
	glUseProgram (self->priv->shader_program);
	_tmp18_ = glGetUniformLocation (self->priv->shader_program, "tex");
	self->priv->texture_location = (GLuint) _tmp18_;
	_tmp19_ = glGetUniformLocation (self->priv->shader_program, "rotation_vec");
	self->priv->rotation_attrib = (GLuint) _tmp19_;
	_tmp20_ = glGetUniformLocation (self->priv->shader_program, "position_vec");
	self->priv->position_attrib = (GLuint) _tmp20_;
	_tmp21_ = glGetUniformLocation (self->priv->shader_program, "scale_vec");
	self->priv->scale_attrib = (GLuint) _tmp21_;
	_tmp22_ = glGetUniformLocation (self->priv->shader_program, "camera_rotation");
	self->priv->camera_rotation_attrib = (GLuint) _tmp22_;
	_tmp23_ = glGetUniformLocation (self->priv->shader_program, "camera_position");
	self->priv->camera_position_attrib = (GLuint) _tmp23_;
	_tmp24_ = glGetUniformLocation (self->priv->shader_program, "aspect_ratio");
	self->priv->aspect_ratio_attrib = (GLuint) _tmp24_;
	len = (GLuint) (10 * sizeof (gfloat));
	_tmp25_ = glGetError ();
	if (_tmp25_ != 0) {
		g_print ("GL shader program failure!!!\n");
	}
}


static void open_gl_renderer_real_render (RenderTarget* base, RenderState* state) {
	OpenGLRenderer * self;
	self = (OpenGLRenderer*) base;
	g_return_if_fail (state != NULL);
	open_gl_renderer_render_scene (self, state);
}


static IObject3DResourceHandle* open_gl_renderer_real_do_load_3D_object (RenderTarget* base, Resource3DObject* obj) {
	OpenGLRenderer * self;
	IObject3DResourceHandle* result = NULL;
	GLuint len;
	GLuint triangles[1] = {0};
	ModelPoint* _tmp0_ = NULL;
	gint _tmp1_;
	ModelPoint* _tmp2_ = NULL;
	gint _tmp3_;
	ModelPoint* _tmp4_ = NULL;
	gint _tmp5_;
	OpenGLObject3DResourceHandle* _tmp6_ = NULL;
	self = (OpenGLRenderer*) base;
	g_return_val_if_fail (obj != NULL, NULL);
	len = (GLuint) (10 * sizeof (gfloat));
	glGenBuffers ((GLsizei) 1, triangles);
	glBindBuffer (GL_ARRAY_BUFFER, triangles[0]);
	_tmp0_ = resource3_dobject_get_points (obj, &_tmp1_);
	_tmp2_ = resource3_dobject_get_points (obj, &_tmp3_);
	glBufferData (GL_ARRAY_BUFFER, (GLsizeiptr) (len * _tmp1_), (GLvoid*) _tmp2_, GL_STATIC_DRAW);
	if (FALSE) {
		glEnableVertexAttribArray (self->priv->pos_attrib);
		glVertexAttribPointer (self->priv->pos_attrib, (GLint) 4, GL_FLOAT, GL_FALSE, (GLsizei) len, (GLvoid*) 0);
		glEnableVertexAttribArray (self->priv->tex_attrib);
		glVertexAttribPointer (self->priv->tex_attrib, (GLint) 3, GL_FLOAT, GL_FALSE, (GLsizei) len, (GLvoid*) (4 * sizeof (GLfloat)));
		glEnableVertexAttribArray (self->priv->nor_attrib);
		glVertexAttribPointer (self->priv->nor_attrib, (GLint) 3, GL_FLOAT, GL_FALSE, (GLsizei) len, (GLvoid*) (7 * sizeof (GLfloat)));
	}
	_tmp4_ = resource3_dobject_get_points (obj, &_tmp5_);
	_tmp6_ = open_gl_object3_dresource_handle_new (triangles[0], _tmp5_);
	result = (IObject3DResourceHandle*) _tmp6_;
	return result;
}


static ITextureResourceHandle* open_gl_renderer_real_do_load_texture (RenderTarget* base, ResourceTexture* texture) {
	OpenGLRenderer * self;
	ITextureResourceHandle* result = NULL;
	gint _tmp0_;
	GLint width;
	gint _tmp1_;
	GLint height;
	GLuint tex[1] = {0};
	gfloat _tmp2_[1] = {0};
	gfloat aniso[1];
	gchar* _tmp3_ = NULL;
	OpenGLTextureResourceHandle* _tmp4_ = NULL;
	self = (OpenGLRenderer*) base;
	g_return_val_if_fail (texture != NULL, NULL);
	_tmp0_ = resource_texture_get_width (texture);
	width = (GLint) _tmp0_;
	_tmp1_ = resource_texture_get_height (texture);
	height = (GLint) _tmp1_;
	glGenTextures ((GLsizei) 1, tex);
	_tmp2_[0] = 0.0f;
	memcpy (aniso, _tmp2_, 1 * sizeof (gfloat));
	glActiveTexture (GL_TEXTURE0);
	glBindTexture ((GLenum) GL_TEXTURE_2D, tex[0]);
	glGetFloatv (GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, (GLfloat*) aniso);
	glTexParameterf ((GLenum) GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, (GLfloat) aniso[0]);
	_tmp3_ = resource_texture_get_data (texture);
	glTexImage2D ((GLenum) GL_TEXTURE_2D, (GLint) 0, (GLint) GL_SRGB_ALPHA, (GLsizei) width, (GLsizei) height, (GLint) 0, (GLenum) GL_RGB, (GLenum) GL_UNSIGNED_BYTE, (GLvoid*) _tmp3_);
	glTexParameteri ((GLenum) GL_TEXTURE_2D, (GLenum) GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	_tmp4_ = open_gl_texture_resource_handle_new (tex[0]);
	result = (ITextureResourceHandle*) _tmp4_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void open_gl_renderer_render_scene (OpenGLRenderer* self, RenderState* state) {
	Color _tmp0_ = {0};
	Color _tmp1_ = {0};
	Color _tmp2_ = {0};
	Color _tmp3_ = {0};
	Vec3 _tmp4_ = {0};
	Vec3 _tmp5_ = {0};
	Vec3 _tmp6_ = {0};
	Vec3 _tmp7_ = {0};
	Vec3 _tmp8_ = {0};
	Vec3 _tmp9_ = {0};
	gint _tmp10_;
	gint _tmp11_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (state != NULL);
	open_gl_renderer_setup_projection (self, state, TRUE);
	render_state_get_back_color (state, &_tmp0_);
	render_state_get_back_color (state, &_tmp1_);
	render_state_get_back_color (state, &_tmp2_);
	render_state_get_back_color (state, &_tmp3_);
	glClearColor ((GLfloat) _tmp0_.r, (GLfloat) _tmp1_.g, (GLfloat) _tmp2_.b, (GLfloat) _tmp3_.a);
	glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	render_state_get_camera_position (state, &_tmp4_);
	render_state_get_camera_position (state, &_tmp5_);
	render_state_get_camera_position (state, &_tmp6_);
	glUniform3f ((GLint) self->priv->camera_position_attrib, (GLfloat) _tmp4_.x, (GLfloat) _tmp5_.y, (GLfloat) _tmp6_.z);
	render_state_get_camera_rotation (state, &_tmp7_);
	render_state_get_camera_rotation (state, &_tmp8_);
	render_state_get_camera_rotation (state, &_tmp9_);
	glUniform3f ((GLint) self->priv->camera_rotation_attrib, (GLfloat) _tmp7_.x, (GLfloat) _tmp8_.y, (GLfloat) _tmp9_.z);
	_tmp10_ = render_state_get_screen_width (state);
	_tmp11_ = render_state_get_screen_height (state);
	glUniform1f ((GLint) self->priv->aspect_ratio_attrib, ((GLfloat) _tmp10_) / _tmp11_);
	{
		GeeArrayList* _tmp12_ = NULL;
		GeeArrayList* _tmp13_;
		GeeArrayList* _obj_list;
		gint _tmp14_;
		gint _obj_size;
		gint _obj_index;
		_tmp12_ = render_state_get_objects (state);
		_tmp13_ = _g_object_ref0 (_tmp12_);
		_obj_list = _tmp13_;
		_tmp14_ = gee_collection_get_size ((GeeCollection*) _obj_list);
		_obj_size = _tmp14_;
		_obj_index = -1;
		while (TRUE) {
			gpointer _tmp15_ = NULL;
			Render3DObject* obj;
			_obj_index = _obj_index + 1;
			if (!(_obj_index < _obj_size)) {
				break;
			}
			_tmp15_ = gee_abstract_list_get ((GeeAbstractList*) _obj_list, _obj_index);
			obj = (Render3DObject*) _tmp15_;
			open_gl_renderer_render_3D_object (self, obj);
			_render3_dobject_unref0 (obj);
		}
		_g_object_unref0 (_obj_list);
	}
	iwindow_target_swap (((RenderTarget*) self)->window);
}


static void open_gl_renderer_render_3D_object (OpenGLRenderer* self, Render3DObject* obj) {
	RenderTexture* _tmp0_ = NULL;
	guint _tmp1_;
	ITextureResourceHandle* _tmp2_ = NULL;
	OpenGLTextureResourceHandle* handle;
	guint _tmp3_;
	guint _tmp4_;
	IObject3DResourceHandle* _tmp5_ = NULL;
	OpenGLObject3DResourceHandle* obj_handle;
	guint _tmp6_;
	Vec3 _tmp7_ = {0};
	Vec3 _tmp8_ = {0};
	Vec3 _tmp9_ = {0};
	Vec3 _tmp10_ = {0};
	Vec3 _tmp11_ = {0};
	Vec3 _tmp12_ = {0};
	Vec3 _tmp13_ = {0};
	Vec3 _tmp14_ = {0};
	Vec3 _tmp15_ = {0};
	GLuint len;
	gint _tmp16_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (obj != NULL);
	_tmp0_ = render3_dobject_get_texture (obj);
	_tmp1_ = render_texture_get_handle (_tmp0_);
	_tmp2_ = render_target_get_texture ((RenderTarget*) self, _tmp1_);
	handle = OPEN_GL_TEXTURE_RESOURCE_HANDLE (_tmp2_);
	_tmp3_ = open_gl_texture_resource_handle_get_handle (handle);
	glBindTexture ((GLenum) GL_TEXTURE_2D, (GLuint) _tmp3_);
	_tmp4_ = render3_dobject_get_handle (obj);
	_tmp5_ = render_target_get_3D_object ((RenderTarget*) self, _tmp4_);
	obj_handle = OPEN_GL_OBJECT3_DRESOURCE_HANDLE (_tmp5_);
	_tmp6_ = open_gl_object3_dresource_handle_get_handle (obj_handle);
	glBindBuffer (GL_ARRAY_BUFFER, (GLuint) _tmp6_);
	render3_dobject_get_rotation (obj, &_tmp7_);
	render3_dobject_get_rotation (obj, &_tmp8_);
	render3_dobject_get_rotation (obj, &_tmp9_);
	glUniform3f ((GLint) self->priv->rotation_attrib, (GLfloat) _tmp7_.x, (GLfloat) _tmp8_.y, (GLfloat) _tmp9_.z);
	render3_dobject_get_position (obj, &_tmp10_);
	render3_dobject_get_position (obj, &_tmp11_);
	render3_dobject_get_position (obj, &_tmp12_);
	glUniform3f ((GLint) self->priv->position_attrib, (GLfloat) _tmp10_.x, (GLfloat) _tmp11_.y, (GLfloat) _tmp12_.z);
	render3_dobject_get_scale (obj, &_tmp13_);
	render3_dobject_get_scale (obj, &_tmp14_);
	render3_dobject_get_scale (obj, &_tmp15_);
	glUniform3f ((GLint) self->priv->scale_attrib, (GLfloat) _tmp13_.x, (GLfloat) _tmp14_.y, (GLfloat) _tmp15_.z);
	len = (GLuint) (10 * sizeof (gfloat));
	glEnableVertexAttribArray (self->priv->pos_attrib);
	glVertexAttribPointer (self->priv->pos_attrib, (GLint) 4, GL_FLOAT, GL_FALSE, (GLsizei) len, (GLvoid*) 0);
	glEnableVertexAttribArray (self->priv->tex_attrib);
	glVertexAttribPointer (self->priv->tex_attrib, (GLint) 3, GL_FLOAT, GL_FALSE, (GLsizei) len, (GLvoid*) (4 * sizeof (GLfloat)));
	glEnableVertexAttribArray (self->priv->nor_attrib);
	glVertexAttribPointer (self->priv->nor_attrib, (GLint) 3, GL_FLOAT, GL_FALSE, (GLsizei) len, (GLvoid*) (7 * sizeof (GLfloat)));
	_tmp16_ = open_gl_object3_dresource_handle_get_triangle_count (obj_handle);
	glDrawArrays (GL_TRIANGLES, (GLint) 0, (GLsizei) _tmp16_);
	_g_object_unref0 (obj_handle);
	_g_object_unref0 (handle);
}


static void open_gl_renderer_setup_projection (OpenGLRenderer* self, RenderState* state, gboolean ortho) {
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gint _tmp3_;
	gint _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (state != NULL);
	_tmp1_ = render_state_get_screen_width (state);
	if (self->priv->view_width == _tmp1_) {
		gint _tmp2_;
		_tmp2_ = render_state_get_screen_height (state);
		_tmp0_ = self->priv->view_height == _tmp2_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		return;
	}
	_tmp3_ = render_state_get_screen_width (state);
	self->priv->view_width = _tmp3_;
	_tmp4_ = render_state_get_screen_height (state);
	self->priv->view_height = _tmp4_;
	glViewport ((GLint) 0, (GLint) 0, (GLsizei) self->priv->view_width, (GLsizei) self->priv->view_height);
}


static void open_gl_renderer_class_init (OpenGLRendererClass * klass) {
	open_gl_renderer_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (OpenGLRendererPrivate));
	RENDER_TARGET_CLASS (klass)->init = open_gl_renderer_real_init;
	RENDER_TARGET_CLASS (klass)->render = open_gl_renderer_real_render;
	RENDER_TARGET_CLASS (klass)->do_load_3D_object = open_gl_renderer_real_do_load_3D_object;
	RENDER_TARGET_CLASS (klass)->do_load_texture = open_gl_renderer_real_do_load_texture;
	G_OBJECT_CLASS (klass)->finalize = open_gl_renderer_finalize;
}


static void open_gl_renderer_instance_init (OpenGLRenderer * self) {
	self->priv = OPEN_GL_RENDERER_GET_PRIVATE (self);
	self->priv->pos_attrib = (GLuint) 0;
	self->priv->tex_attrib = (GLuint) 1;
	self->priv->nor_attrib = (GLuint) 2;
	self->priv->texture_location = (GLuint) (-1);
	self->priv->rotation_attrib = (GLuint) (-1);
	self->priv->position_attrib = (GLuint) (-1);
	self->priv->scale_attrib = (GLuint) (-1);
	self->priv->camera_rotation_attrib = (GLuint) (-1);
	self->priv->camera_position_attrib = (GLuint) (-1);
	self->priv->aspect_ratio_attrib = (GLuint) (-1);
	self->priv->view_width = 0;
	self->priv->view_height = 0;
}


static void open_gl_renderer_finalize (GObject* obj) {
	OpenGLRenderer * self;
	self = OPEN_GL_RENDERER (obj);
	self->priv->vertex_source = (_vala_array_free (self->priv->vertex_source, self->priv->vertex_source_length1, (GDestroyNotify) g_free), NULL);
	self->priv->fragment_source = (_vala_array_free (self->priv->fragment_source, self->priv->fragment_source_length1, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (open_gl_renderer_parent_class)->finalize (obj);
}


GType open_gl_renderer_get_type (void) {
	static volatile gsize open_gl_renderer_type_id__volatile = 0;
	if (g_once_init_enter (&open_gl_renderer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (OpenGLRendererClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) open_gl_renderer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OpenGLRenderer), 0, (GInstanceInitFunc) open_gl_renderer_instance_init, NULL };
		GType open_gl_renderer_type_id;
		open_gl_renderer_type_id = g_type_register_static (TYPE_RENDER_TARGET, "OpenGLRenderer", &g_define_type_info, 0);
		g_once_init_leave (&open_gl_renderer_type_id__volatile, open_gl_renderer_type_id);
	}
	return open_gl_renderer_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



