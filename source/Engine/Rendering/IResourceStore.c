/* IResourceStore.c generated by valac 0.12.0, the Vala compiler
 * generated from IResourceStore.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <SOIL/SOIL.h>
#include <float.h>
#include <math.h>
#include <gobject/gvaluecollector.h>


#define TYPE_IRESOURCE_STORE (iresource_store_get_type ())
#define IRESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IRESOURCE_STORE, IResourceStore))
#define IS_IRESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IRESOURCE_STORE))
#define IRESOURCE_STORE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IRESOURCE_STORE, IResourceStoreIface))

typedef struct _IResourceStore IResourceStore;
typedef struct _IResourceStoreIface IResourceStoreIface;

#define TYPE_RENDER3_DOBJECT (render3_dobject_get_type ())
#define RENDER3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER3_DOBJECT, Render3DObject))
#define RENDER3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER3_DOBJECT, Render3DObjectClass))
#define IS_RENDER3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER3_DOBJECT))
#define IS_RENDER3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER3_DOBJECT))
#define RENDER3_DOBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER3_DOBJECT, Render3DObjectClass))

typedef struct _Render3DObject Render3DObject;
typedef struct _Render3DObjectClass Render3DObjectClass;

#define TYPE_RESOURCE_STORE (resource_store_get_type ())
#define RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE_STORE, ResourceStore))
#define RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE_STORE, ResourceStoreClass))
#define IS_RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE_STORE))
#define IS_RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE_STORE))
#define RESOURCE_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE_STORE, ResourceStoreClass))

typedef struct _ResourceStore ResourceStore;
typedef struct _ResourceStoreClass ResourceStoreClass;
typedef struct _ResourceStorePrivate ResourceStorePrivate;

#define TYPE_OPEN_GL_RESOURCE_STORE (open_gl_resource_store_get_type ())
#define OPEN_GL_RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OPEN_GL_RESOURCE_STORE, OpenGLResourceStore))
#define OPEN_GL_RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OPEN_GL_RESOURCE_STORE, OpenGLResourceStoreClass))
#define IS_OPEN_GL_RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OPEN_GL_RESOURCE_STORE))
#define IS_OPEN_GL_RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OPEN_GL_RESOURCE_STORE))
#define OPEN_GL_RESOURCE_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OPEN_GL_RESOURCE_STORE, OpenGLResourceStoreClass))

typedef struct _OpenGLResourceStore OpenGLResourceStore;
typedef struct _OpenGLResourceStoreClass OpenGLResourceStoreClass;
typedef struct _OpenGLResourceStorePrivate OpenGLResourceStorePrivate;

#define TYPE_RENDER_TARGET (render_target_get_type ())
#define RENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER_TARGET, RenderTarget))
#define RENDER_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER_TARGET, RenderTargetClass))
#define IS_RENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER_TARGET))
#define IS_RENDER_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER_TARGET))
#define RENDER_TARGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER_TARGET, RenderTargetClass))

typedef struct _RenderTarget RenderTarget;
typedef struct _RenderTargetClass RenderTargetClass;

#define TYPE_OPEN_GL_RENDERER (open_gl_renderer_get_type ())
#define OPEN_GL_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OPEN_GL_RENDERER, OpenGLRenderer))
#define OPEN_GL_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OPEN_GL_RENDERER, OpenGLRendererClass))
#define IS_OPEN_GL_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OPEN_GL_RENDERER))
#define IS_OPEN_GL_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OPEN_GL_RENDERER))
#define OPEN_GL_RENDERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OPEN_GL_RENDERER, OpenGLRendererClass))

typedef struct _OpenGLRenderer OpenGLRenderer;
typedef struct _OpenGLRendererClass OpenGLRendererClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_RESOURCE_TEXTURE (resource_texture_get_type ())
#define RESOURCE_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE_TEXTURE, ResourceTexture))
#define RESOURCE_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE_TEXTURE, ResourceTextureClass))
#define IS_RESOURCE_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE_TEXTURE))
#define IS_RESOURCE_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE_TEXTURE))
#define RESOURCE_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE_TEXTURE, ResourceTextureClass))

typedef struct _ResourceTexture ResourceTexture;
typedef struct _ResourceTextureClass ResourceTextureClass;

#define TYPE_IRENDER_TARGET (irender_target_get_type ())
#define IRENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IRENDER_TARGET, IRenderTarget))
#define IS_IRENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IRENDER_TARGET))
#define IRENDER_TARGET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IRENDER_TARGET, IRenderTargetIface))

typedef struct _IRenderTarget IRenderTarget;
typedef struct _IRenderTargetIface IRenderTargetIface;

#define TYPE_RENDER_STATE (render_state_get_type ())
#define RENDER_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER_STATE, RenderState))
#define RENDER_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER_STATE, RenderStateClass))
#define IS_RENDER_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER_STATE))
#define IS_RENDER_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER_STATE))
#define RENDER_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER_STATE, RenderStateClass))

typedef struct _RenderState RenderState;
typedef struct _RenderStateClass RenderStateClass;

#define TYPE_RESOURCE3_DOBJECT (resource3_dobject_get_type ())
#define RESOURCE3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE3_DOBJECT, Resource3DObject))
#define RESOURCE3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE3_DOBJECT, Resource3DObjectClass))
#define IS_RESOURCE3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE3_DOBJECT))
#define IS_RESOURCE3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE3_DOBJECT))
#define RESOURCE3_DOBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE3_DOBJECT, Resource3DObjectClass))

typedef struct _Resource3DObject Resource3DObject;
typedef struct _Resource3DObjectClass Resource3DObjectClass;

#define TYPE_MODEL_DATA (model_data_get_type ())
#define MODEL_DATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MODEL_DATA, ModelData))
#define MODEL_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MODEL_DATA, ModelDataClass))
#define IS_MODEL_DATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MODEL_DATA))
#define IS_MODEL_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MODEL_DATA))
#define MODEL_DATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MODEL_DATA, ModelDataClass))

typedef struct _ModelData ModelData;
typedef struct _ModelDataClass ModelDataClass;

#define TYPE_MODEL_POINT (model_point_get_type ())

#define TYPE_MODEL_VERTEX (model_vertex_get_type ())
typedef struct _ModelVertex ModelVertex;

#define TYPE_MODEL_UV (model_uv_get_type ())
typedef struct _ModelUV ModelUV;

#define TYPE_MODEL_NORMAL (model_normal_get_type ())
typedef struct _ModelNormal ModelNormal;
typedef struct _ModelPoint ModelPoint;

#define TYPE_RENDER_TEXTURE (render_texture_get_type ())
#define RENDER_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER_TEXTURE, RenderTexture))
#define RENDER_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER_TEXTURE, RenderTextureClass))
#define IS_RENDER_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER_TEXTURE))
#define IS_RENDER_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER_TEXTURE))
#define RENDER_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER_TEXTURE, RenderTextureClass))

typedef struct _RenderTexture RenderTexture;
typedef struct _RenderTextureClass RenderTextureClass;
#define _render_texture_unref0(var) ((var == NULL) ? NULL : (var = (render_texture_unref (var), NULL)))
#define _resource3_dobject_unref0(var) ((var == NULL) ? NULL : (var = (resource3_dobject_unref (var), NULL)))
#define _model_data_unref0(var) ((var == NULL) ? NULL : (var = (model_data_unref (var), NULL)))
#define _resource_texture_unref0(var) ((var == NULL) ? NULL : (var = (resource_texture_unref (var), NULL)))
#define _render3_dobject_unref0(var) ((var == NULL) ? NULL : (var = (render3_dobject_unref (var), NULL)))
typedef struct _ResourceTexturePrivate ResourceTexturePrivate;
typedef struct _ParamSpecResourceTexture ParamSpecResourceTexture;
typedef struct _Resource3DObjectPrivate Resource3DObjectPrivate;
typedef struct _ParamSpecResource3DObject ParamSpecResource3DObject;
typedef struct _RenderTexturePrivate RenderTexturePrivate;
typedef struct _ParamSpecRenderTexture ParamSpecRenderTexture;
typedef struct _Render3DObjectPrivate Render3DObjectPrivate;

#define TYPE_VEC3 (vec3_get_type ())
typedef struct _Vec3 Vec3;
typedef struct _ParamSpecRender3DObject ParamSpecRender3DObject;

struct _IResourceStoreIface {
	GTypeInterface parent_iface;
	Render3DObject* (*load_3D_object) (IResourceStore* self, const gchar* name);
};

struct _ResourceStore {
	GObject parent_instance;
	ResourceStorePrivate * priv;
};

struct _ResourceStoreClass {
	GObjectClass parent_class;
	Render3DObject* (*load_3D_object) (ResourceStore* self, const gchar* name);
};

struct _OpenGLResourceStore {
	ResourceStore parent_instance;
	OpenGLResourceStorePrivate * priv;
};

struct _OpenGLResourceStoreClass {
	ResourceStoreClass parent_class;
};

struct _OpenGLResourceStorePrivate {
	OpenGLRenderer* renderer;
};

struct _IRenderTargetIface {
	GTypeInterface parent_iface;
	void (*set_state) (IRenderTarget* self, RenderState* state);
	gboolean (*start) (IRenderTarget* self);
	void (*stop) (IRenderTarget* self);
	guint (*load_3D_object) (IRenderTarget* self, Resource3DObject* object);
	guint (*load_texture) (IRenderTarget* self, ResourceTexture* texture);
	IResourceStore* (*get_resource_store) (IRenderTarget* self);
};

struct _ModelVertex {
	gfloat x;
	gfloat y;
	gfloat z;
	gfloat w;
};

struct _ModelUV {
	gfloat u;
	gfloat v;
	gfloat w;
};

struct _ModelNormal {
	gfloat i;
	gfloat j;
	gfloat k;
};

struct _ModelPoint {
	ModelVertex vertex;
	ModelUV uv;
	ModelNormal normal;
};

struct _ResourceTexture {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ResourceTexturePrivate * priv;
};

struct _ResourceTextureClass {
	GTypeClass parent_class;
	void (*finalize) (ResourceTexture *self);
};

struct _ResourceTexturePrivate {
	gchar* _data;
	gint _width;
	gint _height;
};

struct _ParamSpecResourceTexture {
	GParamSpec parent_instance;
};

struct _Resource3DObject {
	GTypeInstance parent_instance;
	volatile int ref_count;
	Resource3DObjectPrivate * priv;
};

struct _Resource3DObjectClass {
	GTypeClass parent_class;
	void (*finalize) (Resource3DObject *self);
};

struct _Resource3DObjectPrivate {
	ModelPoint* _points;
	gint _points_length1;
	gint __points_size_;
};

struct _ParamSpecResource3DObject {
	GParamSpec parent_instance;
};

struct _RenderTexture {
	GTypeInstance parent_instance;
	volatile int ref_count;
	RenderTexturePrivate * priv;
};

struct _RenderTextureClass {
	GTypeClass parent_class;
	void (*finalize) (RenderTexture *self);
};

struct _RenderTexturePrivate {
	guint _handle;
};

struct _ParamSpecRenderTexture {
	GParamSpec parent_instance;
};

struct _Render3DObject {
	GTypeInstance parent_instance;
	volatile int ref_count;
	Render3DObjectPrivate * priv;
};

struct _Render3DObjectClass {
	GTypeClass parent_class;
	void (*finalize) (Render3DObject *self);
};

struct _Vec3 {
	gfloat x;
	gfloat y;
	gfloat z;
};

struct _Render3DObjectPrivate {
	RenderTexture* _texture;
	guint _handle;
	Vec3 _rotation;
	Vec3 _position;
	Vec3 _scale;
};

struct _ParamSpecRender3DObject {
	GParamSpec parent_instance;
};


static gpointer resource_store_parent_class = NULL;
static IResourceStoreIface* resource_store_iresource_store_parent_iface = NULL;
static gpointer open_gl_resource_store_parent_class = NULL;
static gpointer resource_texture_parent_class = NULL;
static gpointer resource3_dobject_parent_class = NULL;
static gpointer render_texture_parent_class = NULL;
static gpointer render3_dobject_parent_class = NULL;

gpointer render3_dobject_ref (gpointer instance);
void render3_dobject_unref (gpointer instance);
GParamSpec* param_spec_render3_dobject (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render3_dobject (GValue* value, gpointer v_object);
void value_take_render3_dobject (GValue* value, gpointer v_object);
gpointer value_get_render3_dobject (const GValue* value);
GType render3_dobject_get_type (void) G_GNUC_CONST;
GType iresource_store_get_type (void) G_GNUC_CONST;
Render3DObject* iresource_store_load_3D_object (IResourceStore* self, const gchar* name);
GType resource_store_get_type (void) G_GNUC_CONST;
enum  {
	RESOURCE_STORE_DUMMY_PROPERTY
};
Render3DObject* resource_store_load_3D_object (ResourceStore* self, const gchar* name);
static Render3DObject* resource_store_real_load_3D_object (ResourceStore* self, const gchar* name);
ResourceStore* resource_store_construct (GType object_type);
GType open_gl_resource_store_get_type (void) G_GNUC_CONST;
GType render_target_get_type (void) G_GNUC_CONST;
GType open_gl_renderer_get_type (void) G_GNUC_CONST;
#define OPEN_GL_RESOURCE_STORE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_OPEN_GL_RESOURCE_STORE, OpenGLResourceStorePrivate))
enum  {
	OPEN_GL_RESOURCE_STORE_DUMMY_PROPERTY
};
OpenGLResourceStore* open_gl_resource_store_new (OpenGLRenderer* renderer);
OpenGLResourceStore* open_gl_resource_store_construct (GType object_type, OpenGLRenderer* renderer);
static Render3DObject* open_gl_resource_store_real_load_3D_object (ResourceStore* base, const gchar* name);
ResourceTexture* resource_texture_new (gchar* data, gint width, gint height);
ResourceTexture* resource_texture_construct (GType object_type, gchar* data, gint width, gint height);
gpointer resource_texture_ref (gpointer instance);
void resource_texture_unref (gpointer instance);
GParamSpec* param_spec_resource_texture (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_resource_texture (GValue* value, gpointer v_object);
void value_take_resource_texture (GValue* value, gpointer v_object);
gpointer value_get_resource_texture (const GValue* value);
GType resource_texture_get_type (void) G_GNUC_CONST;
gpointer render_state_ref (gpointer instance);
void render_state_unref (gpointer instance);
GParamSpec* param_spec_render_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render_state (GValue* value, gpointer v_object);
void value_take_render_state (GValue* value, gpointer v_object);
gpointer value_get_render_state (const GValue* value);
GType render_state_get_type (void) G_GNUC_CONST;
gpointer resource3_dobject_ref (gpointer instance);
void resource3_dobject_unref (gpointer instance);
GParamSpec* param_spec_resource3_dobject (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_resource3_dobject (GValue* value, gpointer v_object);
void value_take_resource3_dobject (GValue* value, gpointer v_object);
gpointer value_get_resource3_dobject (const GValue* value);
GType resource3_dobject_get_type (void) G_GNUC_CONST;
GType irender_target_get_type (void) G_GNUC_CONST;
guint irender_target_load_texture (IRenderTarget* self, ResourceTexture* texture);
gchar** file_loader_load (const gchar* name, int* result_length1);
gpointer model_data_ref (gpointer instance);
void model_data_unref (gpointer instance);
GParamSpec* param_spec_model_data (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_model_data (GValue* value, gpointer v_object);
void value_take_model_data (GValue* value, gpointer v_object);
gpointer value_get_model_data (const GValue* value);
GType model_data_get_type (void) G_GNUC_CONST;
ModelData* obj_parser_parse (gchar** file, int file_length1);
GType model_point_get_type (void) G_GNUC_CONST;
GType model_vertex_get_type (void) G_GNUC_CONST;
ModelVertex* model_vertex_dup (const ModelVertex* self);
void model_vertex_free (ModelVertex* self);
GType model_uv_get_type (void) G_GNUC_CONST;
ModelUV* model_uv_dup (const ModelUV* self);
void model_uv_free (ModelUV* self);
GType model_normal_get_type (void) G_GNUC_CONST;
ModelNormal* model_normal_dup (const ModelNormal* self);
void model_normal_free (ModelNormal* self);
ModelPoint* model_point_dup (const ModelPoint* self);
void model_point_free (ModelPoint* self);
ModelPoint* model_data_create_points (ModelData* self, int* result_length1);
Resource3DObject* resource3_dobject_new (ModelPoint* points, int points_length1);
Resource3DObject* resource3_dobject_construct (GType object_type, ModelPoint* points, int points_length1);
guint irender_target_load_3D_object (IRenderTarget* self, Resource3DObject* object);
RenderTexture* render_texture_new (guint handle);
RenderTexture* render_texture_construct (GType object_type, guint handle);
gpointer render_texture_ref (gpointer instance);
void render_texture_unref (gpointer instance);
GParamSpec* param_spec_render_texture (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render_texture (GValue* value, gpointer v_object);
void value_take_render_texture (GValue* value, gpointer v_object);
gpointer value_get_render_texture (const GValue* value);
GType render_texture_get_type (void) G_GNUC_CONST;
Render3DObject* render3_dobject_new (RenderTexture* texture, guint handle);
Render3DObject* render3_dobject_construct (GType object_type, RenderTexture* texture, guint handle);
static void open_gl_resource_store_finalize (GObject* obj);
#define RESOURCE_TEXTURE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_RESOURCE_TEXTURE, ResourceTexturePrivate))
enum  {
	RESOURCE_TEXTURE_DUMMY_PROPERTY
};
static void resource_texture_set_data (ResourceTexture* self, gchar* value);
static void resource_texture_set_width (ResourceTexture* self, gint value);
static void resource_texture_set_height (ResourceTexture* self, gint value);
gchar* resource_texture_get_data (ResourceTexture* self);
gint resource_texture_get_width (ResourceTexture* self);
gint resource_texture_get_height (ResourceTexture* self);
static void resource_texture_finalize (ResourceTexture* obj);
#define RESOURCE3_DOBJECT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_RESOURCE3_DOBJECT, Resource3DObjectPrivate))
enum  {
	RESOURCE3_DOBJECT_DUMMY_PROPERTY
};
static void resource3_dobject_set_points (Resource3DObject* self, ModelPoint* value, int value_length1);
ModelPoint* resource3_dobject_get_points (Resource3DObject* self, int* result_length1);
static ModelPoint* _vala_array_dup2 (ModelPoint* self, int length);
static void resource3_dobject_finalize (Resource3DObject* obj);
#define RENDER_TEXTURE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_RENDER_TEXTURE, RenderTexturePrivate))
enum  {
	RENDER_TEXTURE_DUMMY_PROPERTY
};
static void render_texture_set_handle (RenderTexture* self, guint value);
guint render_texture_get_handle (RenderTexture* self);
static void render_texture_finalize (RenderTexture* obj);
GType vec3_get_type (void) G_GNUC_CONST;
Vec3* vec3_dup (const Vec3* self);
void vec3_free (Vec3* self);
#define RENDER3_DOBJECT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_RENDER3_DOBJECT, Render3DObjectPrivate))
enum  {
	RENDER3_DOBJECT_DUMMY_PROPERTY
};
static void render3_dobject_set_texture (Render3DObject* self, RenderTexture* value);
static void render3_dobject_set_handle (Render3DObject* self, guint value);
void render3_dobject_set_rotation (Render3DObject* self, Vec3* value);
void render3_dobject_set_position (Render3DObject* self, Vec3* value);
void render3_dobject_set_scale (Render3DObject* self, Vec3* value);
RenderTexture* render3_dobject_get_texture (Render3DObject* self);
guint render3_dobject_get_handle (Render3DObject* self);
void render3_dobject_get_rotation (Render3DObject* self, Vec3* result);
void render3_dobject_get_position (Render3DObject* self, Vec3* result);
void render3_dobject_get_scale (Render3DObject* self, Vec3* result);
static void render3_dobject_finalize (Render3DObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


Render3DObject* iresource_store_load_3D_object (IResourceStore* self, const gchar* name) {
	return IRESOURCE_STORE_GET_INTERFACE (self)->load_3D_object (self, name);
}


static void iresource_store_base_init (IResourceStoreIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType iresource_store_get_type (void) {
	static volatile gsize iresource_store_type_id__volatile = 0;
	if (g_once_init_enter (&iresource_store_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IResourceStoreIface), (GBaseInitFunc) iresource_store_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType iresource_store_type_id;
		iresource_store_type_id = g_type_register_static (G_TYPE_INTERFACE, "IResourceStore", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (iresource_store_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&iresource_store_type_id__volatile, iresource_store_type_id);
	}
	return iresource_store_type_id__volatile;
}


static Render3DObject* resource_store_real_load_3D_object (ResourceStore* self, const gchar* name) {
	g_return_val_if_fail (self != NULL, NULL);
	g_critical ("Type `%s' does not implement abstract method `resource_store_load_3D_object'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


Render3DObject* resource_store_load_3D_object (ResourceStore* self, const gchar* name) {
	return RESOURCE_STORE_GET_CLASS (self)->load_3D_object (self, name);
}


ResourceStore* resource_store_construct (GType object_type) {
	ResourceStore * self = NULL;
	self = (ResourceStore*) g_object_new (object_type, NULL);
	return self;
}


static void resource_store_class_init (ResourceStoreClass * klass) {
	resource_store_parent_class = g_type_class_peek_parent (klass);
	RESOURCE_STORE_CLASS (klass)->load_3D_object = resource_store_real_load_3D_object;
}


static void resource_store_iresource_store_interface_init (IResourceStoreIface * iface) {
	resource_store_iresource_store_parent_iface = g_type_interface_peek_parent (iface);
	iface->load_3D_object = (Render3DObject* (*)(IResourceStore* ,const gchar*)) resource_store_load_3D_object;
}


static void resource_store_instance_init (ResourceStore * self) {
}


GType resource_store_get_type (void) {
	static volatile gsize resource_store_type_id__volatile = 0;
	if (g_once_init_enter (&resource_store_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ResourceStoreClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) resource_store_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ResourceStore), 0, (GInstanceInitFunc) resource_store_instance_init, NULL };
		static const GInterfaceInfo iresource_store_info = { (GInterfaceInitFunc) resource_store_iresource_store_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType resource_store_type_id;
		resource_store_type_id = g_type_register_static (G_TYPE_OBJECT, "ResourceStore", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_type_add_interface_static (resource_store_type_id, TYPE_IRESOURCE_STORE, &iresource_store_info);
		g_once_init_leave (&resource_store_type_id__volatile, resource_store_type_id);
	}
	return resource_store_type_id__volatile;
}


OpenGLResourceStore* open_gl_resource_store_construct (GType object_type, OpenGLRenderer* renderer) {
	OpenGLResourceStore * self = NULL;
	g_return_val_if_fail (renderer != NULL, NULL);
	self = (OpenGLResourceStore*) resource_store_construct (object_type);
	self->priv->renderer = renderer;
	return self;
}


OpenGLResourceStore* open_gl_resource_store_new (OpenGLRenderer* renderer) {
	return open_gl_resource_store_construct (TYPE_OPEN_GL_RESOURCE_STORE, renderer);
}


static Render3DObject* open_gl_resource_store_real_load_3D_object (ResourceStore* base, const gchar* name) {
	OpenGLResourceStore * self;
	Render3DObject* result = NULL;
	gint width = 0;
	gint height = 0;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	guchar* _tmp4_ = NULL;
	guchar* _tmp5_;
	guchar* image;
	ResourceTexture* _tmp6_ = NULL;
	ResourceTexture* texture;
	guint _tmp7_;
	guint texture_handle;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gint _tmp10_;
	gchar** _tmp11_ = NULL;
	gchar** _tmp12_;
	gchar** lines;
	gint lines_length1;
	gint _lines_size_;
	ModelData* _tmp13_ = NULL;
	ModelData* data;
	gint _tmp14_;
	ModelPoint* _tmp15_ = NULL;
	ModelPoint* _tmp16_;
	gint _tmp16__length1;
	Resource3DObject* _tmp17_ = NULL;
	Resource3DObject* _tmp18_;
	Resource3DObject* obj;
	guint _tmp19_;
	guint obj_handle;
	RenderTexture* _tmp20_ = NULL;
	RenderTexture* tex;
	Render3DObject* _tmp21_ = NULL;
	Render3DObject* obj_3d;
	self = (OpenGLResourceStore*) base;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = g_strconcat (name, ".png", NULL);
	_tmp1_ = _tmp0_;
	_tmp4_ = SOIL_load_image (_tmp1_, &_tmp2_, &_tmp3_, NULL, (guint) SOIL_LOAD_RGB);
	width = _tmp2_;
	height = _tmp3_;
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp1_);
	image = _tmp5_;
	_tmp6_ = resource_texture_new ((gchar*) image, width, height);
	texture = _tmp6_;
	_tmp7_ = irender_target_load_texture ((IRenderTarget*) self->priv->renderer, texture);
	texture_handle = _tmp7_;
	_tmp8_ = g_strconcat (name, ".obj", NULL);
	_tmp9_ = _tmp8_;
	_tmp11_ = file_loader_load (_tmp9_, &_tmp10_);
	_tmp12_ = _tmp11_;
	_g_free0 (_tmp9_);
	lines = _tmp12_;
	lines_length1 = _tmp10_;
	_lines_size_ = _tmp10_;
	_tmp13_ = obj_parser_parse (lines, lines_length1);
	data = _tmp13_;
	_tmp15_ = model_data_create_points (data, &_tmp14_);
	_tmp16_ = _tmp15_;
	_tmp16__length1 = _tmp14_;
	_tmp17_ = resource3_dobject_new (_tmp16_, _tmp14_);
	_tmp18_ = _tmp17_;
	_tmp16_ = (g_free (_tmp16_), NULL);
	obj = _tmp18_;
	_tmp19_ = irender_target_load_3D_object ((IRenderTarget*) self->priv->renderer, obj);
	obj_handle = _tmp19_;
	_tmp20_ = render_texture_new (texture_handle);
	tex = _tmp20_;
	_tmp21_ = render3_dobject_new (tex, obj_handle);
	obj_3d = _tmp21_;
	result = obj_3d;
	_render_texture_unref0 (tex);
	_resource3_dobject_unref0 (obj);
	_model_data_unref0 (data);
	lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
	_resource_texture_unref0 (texture);
	return result;
}


static void open_gl_resource_store_class_init (OpenGLResourceStoreClass * klass) {
	open_gl_resource_store_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (OpenGLResourceStorePrivate));
	RESOURCE_STORE_CLASS (klass)->load_3D_object = open_gl_resource_store_real_load_3D_object;
	G_OBJECT_CLASS (klass)->finalize = open_gl_resource_store_finalize;
}


static void open_gl_resource_store_instance_init (OpenGLResourceStore * self) {
	self->priv = OPEN_GL_RESOURCE_STORE_GET_PRIVATE (self);
}


static void open_gl_resource_store_finalize (GObject* obj) {
	OpenGLResourceStore * self;
	self = OPEN_GL_RESOURCE_STORE (obj);
	G_OBJECT_CLASS (open_gl_resource_store_parent_class)->finalize (obj);
}


GType open_gl_resource_store_get_type (void) {
	static volatile gsize open_gl_resource_store_type_id__volatile = 0;
	if (g_once_init_enter (&open_gl_resource_store_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (OpenGLResourceStoreClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) open_gl_resource_store_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OpenGLResourceStore), 0, (GInstanceInitFunc) open_gl_resource_store_instance_init, NULL };
		GType open_gl_resource_store_type_id;
		open_gl_resource_store_type_id = g_type_register_static (TYPE_RESOURCE_STORE, "OpenGLResourceStore", &g_define_type_info, 0);
		g_once_init_leave (&open_gl_resource_store_type_id__volatile, open_gl_resource_store_type_id);
	}
	return open_gl_resource_store_type_id__volatile;
}


ResourceTexture* resource_texture_construct (GType object_type, gchar* data, gint width, gint height) {
	ResourceTexture* self = NULL;
	self = (ResourceTexture*) g_type_create_instance (object_type);
	resource_texture_set_data (self, data);
	resource_texture_set_width (self, width);
	resource_texture_set_height (self, height);
	return self;
}


ResourceTexture* resource_texture_new (gchar* data, gint width, gint height) {
	return resource_texture_construct (TYPE_RESOURCE_TEXTURE, data, width, height);
}


gchar* resource_texture_get_data (ResourceTexture* self) {
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_data;
	return result;
}


static void resource_texture_set_data (ResourceTexture* self, gchar* value) {
	g_return_if_fail (self != NULL);
	self->priv->_data = value;
}


gint resource_texture_get_width (ResourceTexture* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_width;
	return result;
}


static void resource_texture_set_width (ResourceTexture* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_width = value;
}


gint resource_texture_get_height (ResourceTexture* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_height;
	return result;
}


static void resource_texture_set_height (ResourceTexture* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_height = value;
}


static void value_resource_texture_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_resource_texture_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		resource_texture_unref (value->data[0].v_pointer);
	}
}


static void value_resource_texture_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = resource_texture_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_resource_texture_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_resource_texture_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ResourceTexture* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = resource_texture_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_resource_texture_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ResourceTexture** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = resource_texture_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_resource_texture (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecResourceTexture* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_RESOURCE_TEXTURE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_resource_texture (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RESOURCE_TEXTURE), NULL);
	return value->data[0].v_pointer;
}


void value_set_resource_texture (GValue* value, gpointer v_object) {
	ResourceTexture* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RESOURCE_TEXTURE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RESOURCE_TEXTURE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		resource_texture_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		resource_texture_unref (old);
	}
}


void value_take_resource_texture (GValue* value, gpointer v_object) {
	ResourceTexture* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RESOURCE_TEXTURE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RESOURCE_TEXTURE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		resource_texture_unref (old);
	}
}


static void resource_texture_class_init (ResourceTextureClass * klass) {
	resource_texture_parent_class = g_type_class_peek_parent (klass);
	RESOURCE_TEXTURE_CLASS (klass)->finalize = resource_texture_finalize;
	g_type_class_add_private (klass, sizeof (ResourceTexturePrivate));
}


static void resource_texture_instance_init (ResourceTexture * self) {
	self->priv = RESOURCE_TEXTURE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void resource_texture_finalize (ResourceTexture* obj) {
	ResourceTexture * self;
	self = RESOURCE_TEXTURE (obj);
}


GType resource_texture_get_type (void) {
	static volatile gsize resource_texture_type_id__volatile = 0;
	if (g_once_init_enter (&resource_texture_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_resource_texture_init, value_resource_texture_free_value, value_resource_texture_copy_value, value_resource_texture_peek_pointer, "p", value_resource_texture_collect_value, "p", value_resource_texture_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ResourceTextureClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) resource_texture_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ResourceTexture), 0, (GInstanceInitFunc) resource_texture_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType resource_texture_type_id;
		resource_texture_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ResourceTexture", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&resource_texture_type_id__volatile, resource_texture_type_id);
	}
	return resource_texture_type_id__volatile;
}


gpointer resource_texture_ref (gpointer instance) {
	ResourceTexture* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void resource_texture_unref (gpointer instance) {
	ResourceTexture* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		RESOURCE_TEXTURE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


Resource3DObject* resource3_dobject_construct (GType object_type, ModelPoint* points, int points_length1) {
	Resource3DObject* self = NULL;
	ModelPoint* _tmp0_;
	self = (Resource3DObject*) g_type_create_instance (object_type);
	_tmp0_ = points;
	resource3_dobject_set_points (self, _tmp0_, points_length1);
	return self;
}


Resource3DObject* resource3_dobject_new (ModelPoint* points, int points_length1) {
	return resource3_dobject_construct (TYPE_RESOURCE3_DOBJECT, points, points_length1);
}


ModelPoint* resource3_dobject_get_points (Resource3DObject* self, int* result_length1) {
	ModelPoint* result;
	ModelPoint* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_points;
	*result_length1 = self->priv->_points_length1;
	result = _tmp0_;
	return result;
}


static ModelPoint* _vala_array_dup2 (ModelPoint* self, int length) {
	return g_memdup (self, length * sizeof (ModelPoint));
}


static void resource3_dobject_set_points (Resource3DObject* self, ModelPoint* value, int value_length1) {
	ModelPoint* _tmp0_;
	ModelPoint* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (_tmp1_ = value, (_tmp1_ == NULL) ? ((gpointer) _tmp1_) : _vala_array_dup2 (_tmp1_, value_length1));
	self->priv->_points = (g_free (self->priv->_points), NULL);
	self->priv->_points = _tmp0_;
	self->priv->_points_length1 = value_length1;
	self->priv->__points_size_ = value_length1;
}


static void value_resource3_dobject_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_resource3_dobject_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		resource3_dobject_unref (value->data[0].v_pointer);
	}
}


static void value_resource3_dobject_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = resource3_dobject_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_resource3_dobject_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_resource3_dobject_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Resource3DObject* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = resource3_dobject_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_resource3_dobject_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Resource3DObject** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = resource3_dobject_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_resource3_dobject (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecResource3DObject* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_RESOURCE3_DOBJECT), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_resource3_dobject (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RESOURCE3_DOBJECT), NULL);
	return value->data[0].v_pointer;
}


void value_set_resource3_dobject (GValue* value, gpointer v_object) {
	Resource3DObject* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RESOURCE3_DOBJECT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RESOURCE3_DOBJECT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		resource3_dobject_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		resource3_dobject_unref (old);
	}
}


void value_take_resource3_dobject (GValue* value, gpointer v_object) {
	Resource3DObject* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RESOURCE3_DOBJECT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RESOURCE3_DOBJECT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		resource3_dobject_unref (old);
	}
}


static void resource3_dobject_class_init (Resource3DObjectClass * klass) {
	resource3_dobject_parent_class = g_type_class_peek_parent (klass);
	RESOURCE3_DOBJECT_CLASS (klass)->finalize = resource3_dobject_finalize;
	g_type_class_add_private (klass, sizeof (Resource3DObjectPrivate));
}


static void resource3_dobject_instance_init (Resource3DObject * self) {
	self->priv = RESOURCE3_DOBJECT_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void resource3_dobject_finalize (Resource3DObject* obj) {
	Resource3DObject * self;
	self = RESOURCE3_DOBJECT (obj);
	self->priv->_points = (g_free (self->priv->_points), NULL);
}


GType resource3_dobject_get_type (void) {
	static volatile gsize resource3_dobject_type_id__volatile = 0;
	if (g_once_init_enter (&resource3_dobject_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_resource3_dobject_init, value_resource3_dobject_free_value, value_resource3_dobject_copy_value, value_resource3_dobject_peek_pointer, "p", value_resource3_dobject_collect_value, "p", value_resource3_dobject_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (Resource3DObjectClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) resource3_dobject_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Resource3DObject), 0, (GInstanceInitFunc) resource3_dobject_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType resource3_dobject_type_id;
		resource3_dobject_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Resource3DObject", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&resource3_dobject_type_id__volatile, resource3_dobject_type_id);
	}
	return resource3_dobject_type_id__volatile;
}


gpointer resource3_dobject_ref (gpointer instance) {
	Resource3DObject* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void resource3_dobject_unref (gpointer instance) {
	Resource3DObject* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		RESOURCE3_DOBJECT_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


RenderTexture* render_texture_construct (GType object_type, guint handle) {
	RenderTexture* self = NULL;
	self = (RenderTexture*) g_type_create_instance (object_type);
	render_texture_set_handle (self, handle);
	return self;
}


RenderTexture* render_texture_new (guint handle) {
	return render_texture_construct (TYPE_RENDER_TEXTURE, handle);
}


guint render_texture_get_handle (RenderTexture* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_handle;
	return result;
}


static void render_texture_set_handle (RenderTexture* self, guint value) {
	g_return_if_fail (self != NULL);
	self->priv->_handle = value;
}


static void value_render_texture_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_render_texture_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		render_texture_unref (value->data[0].v_pointer);
	}
}


static void value_render_texture_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = render_texture_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_render_texture_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_render_texture_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		RenderTexture* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = render_texture_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_render_texture_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	RenderTexture** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = render_texture_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_render_texture (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecRenderTexture* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_RENDER_TEXTURE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_render_texture (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER_TEXTURE), NULL);
	return value->data[0].v_pointer;
}


void value_set_render_texture (GValue* value, gpointer v_object) {
	RenderTexture* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER_TEXTURE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RENDER_TEXTURE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		render_texture_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		render_texture_unref (old);
	}
}


void value_take_render_texture (GValue* value, gpointer v_object) {
	RenderTexture* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER_TEXTURE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RENDER_TEXTURE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		render_texture_unref (old);
	}
}


static void render_texture_class_init (RenderTextureClass * klass) {
	render_texture_parent_class = g_type_class_peek_parent (klass);
	RENDER_TEXTURE_CLASS (klass)->finalize = render_texture_finalize;
	g_type_class_add_private (klass, sizeof (RenderTexturePrivate));
}


static void render_texture_instance_init (RenderTexture * self) {
	self->priv = RENDER_TEXTURE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void render_texture_finalize (RenderTexture* obj) {
	RenderTexture * self;
	self = RENDER_TEXTURE (obj);
}


GType render_texture_get_type (void) {
	static volatile gsize render_texture_type_id__volatile = 0;
	if (g_once_init_enter (&render_texture_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_render_texture_init, value_render_texture_free_value, value_render_texture_copy_value, value_render_texture_peek_pointer, "p", value_render_texture_collect_value, "p", value_render_texture_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (RenderTextureClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) render_texture_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RenderTexture), 0, (GInstanceInitFunc) render_texture_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType render_texture_type_id;
		render_texture_type_id = g_type_register_fundamental (g_type_fundamental_next (), "RenderTexture", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&render_texture_type_id__volatile, render_texture_type_id);
	}
	return render_texture_type_id__volatile;
}


gpointer render_texture_ref (gpointer instance) {
	RenderTexture* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void render_texture_unref (gpointer instance) {
	RenderTexture* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		RENDER_TEXTURE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


Render3DObject* render3_dobject_construct (GType object_type, RenderTexture* texture, guint handle) {
	Render3DObject* self = NULL;
	Vec3 _tmp0_ = {0};
	Vec3 _tmp1_ = {0};
	Vec3 _tmp2_ = {0};
	Vec3 _tmp3_ = {0};
	self = (Render3DObject*) g_type_create_instance (object_type);
	render3_dobject_set_texture (self, texture);
	render3_dobject_set_handle (self, handle);
	render3_dobject_set_rotation (self, &_tmp0_);
	render3_dobject_set_position (self, &_tmp1_);
	memset (&_tmp2_, 0, sizeof (Vec3));
	_tmp2_.x = (gfloat) 1;
	_tmp2_.y = (gfloat) 1;
	_tmp2_.z = (gfloat) 1;
	_tmp3_ = _tmp2_;
	render3_dobject_set_scale (self, &_tmp3_);
	return self;
}


Render3DObject* render3_dobject_new (RenderTexture* texture, guint handle) {
	return render3_dobject_construct (TYPE_RENDER3_DOBJECT, texture, handle);
}


RenderTexture* render3_dobject_get_texture (Render3DObject* self) {
	RenderTexture* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_texture;
	return result;
}


static gpointer _render_texture_ref0 (gpointer self) {
	return self ? render_texture_ref (self) : NULL;
}


static void render3_dobject_set_texture (Render3DObject* self, RenderTexture* value) {
	RenderTexture* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _render_texture_ref0 (value);
	_render_texture_unref0 (self->priv->_texture);
	self->priv->_texture = _tmp0_;
}


guint render3_dobject_get_handle (Render3DObject* self) {
	guint result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_handle;
	return result;
}


static void render3_dobject_set_handle (Render3DObject* self, guint value) {
	g_return_if_fail (self != NULL);
	self->priv->_handle = value;
}


void render3_dobject_get_rotation (Render3DObject* self, Vec3* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->_rotation;
	return;
}


void render3_dobject_set_rotation (Render3DObject* self, Vec3* value) {
	g_return_if_fail (self != NULL);
	self->priv->_rotation = *value;
}


void render3_dobject_get_position (Render3DObject* self, Vec3* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->_position;
	return;
}


void render3_dobject_set_position (Render3DObject* self, Vec3* value) {
	g_return_if_fail (self != NULL);
	self->priv->_position = *value;
}


void render3_dobject_get_scale (Render3DObject* self, Vec3* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->_scale;
	return;
}


void render3_dobject_set_scale (Render3DObject* self, Vec3* value) {
	g_return_if_fail (self != NULL);
	self->priv->_scale = *value;
}


static void value_render3_dobject_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_render3_dobject_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		render3_dobject_unref (value->data[0].v_pointer);
	}
}


static void value_render3_dobject_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = render3_dobject_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_render3_dobject_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_render3_dobject_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Render3DObject* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = render3_dobject_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_render3_dobject_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Render3DObject** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = render3_dobject_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_render3_dobject (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecRender3DObject* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_RENDER3_DOBJECT), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_render3_dobject (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER3_DOBJECT), NULL);
	return value->data[0].v_pointer;
}


void value_set_render3_dobject (GValue* value, gpointer v_object) {
	Render3DObject* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER3_DOBJECT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RENDER3_DOBJECT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		render3_dobject_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		render3_dobject_unref (old);
	}
}


void value_take_render3_dobject (GValue* value, gpointer v_object) {
	Render3DObject* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_RENDER3_DOBJECT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_RENDER3_DOBJECT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		render3_dobject_unref (old);
	}
}


static void render3_dobject_class_init (Render3DObjectClass * klass) {
	render3_dobject_parent_class = g_type_class_peek_parent (klass);
	RENDER3_DOBJECT_CLASS (klass)->finalize = render3_dobject_finalize;
	g_type_class_add_private (klass, sizeof (Render3DObjectPrivate));
}


static void render3_dobject_instance_init (Render3DObject * self) {
	self->priv = RENDER3_DOBJECT_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void render3_dobject_finalize (Render3DObject* obj) {
	Render3DObject * self;
	self = RENDER3_DOBJECT (obj);
	_render_texture_unref0 (self->priv->_texture);
}


GType render3_dobject_get_type (void) {
	static volatile gsize render3_dobject_type_id__volatile = 0;
	if (g_once_init_enter (&render3_dobject_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_render3_dobject_init, value_render3_dobject_free_value, value_render3_dobject_copy_value, value_render3_dobject_peek_pointer, "p", value_render3_dobject_collect_value, "p", value_render3_dobject_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (Render3DObjectClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) render3_dobject_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Render3DObject), 0, (GInstanceInitFunc) render3_dobject_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType render3_dobject_type_id;
		render3_dobject_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Render3DObject", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&render3_dobject_type_id__volatile, render3_dobject_type_id);
	}
	return render3_dobject_type_id__volatile;
}


gpointer render3_dobject_ref (gpointer instance) {
	Render3DObject* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void render3_dobject_unref (gpointer instance) {
	Render3DObject* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		RENDER3_DOBJECT_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


Vec3* vec3_dup (const Vec3* self) {
	Vec3* dup;
	dup = g_new0 (Vec3, 1);
	memcpy (dup, self, sizeof (Vec3));
	return dup;
}


void vec3_free (Vec3* self) {
	g_free (self);
}


GType vec3_get_type (void) {
	static volatile gsize vec3_type_id__volatile = 0;
	if (g_once_init_enter (&vec3_type_id__volatile)) {
		GType vec3_type_id;
		vec3_type_id = g_boxed_type_register_static ("Vec3", (GBoxedCopyFunc) vec3_dup, (GBoxedFreeFunc) vec3_free);
		g_once_init_leave (&vec3_type_id__volatile, vec3_type_id);
	}
	return vec3_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



