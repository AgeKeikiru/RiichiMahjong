/* IRenderTarget.c generated by valac 0.12.0, the Vala compiler
 * generated from IRenderTarget.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define TYPE_IRENDER_TARGET (irender_target_get_type ())
#define IRENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IRENDER_TARGET, IRenderTarget))
#define IS_IRENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IRENDER_TARGET))
#define IRENDER_TARGET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IRENDER_TARGET, IRenderTargetIface))

typedef struct _IRenderTarget IRenderTarget;
typedef struct _IRenderTargetIface IRenderTargetIface;

#define TYPE_RENDER_STATE (render_state_get_type ())
#define RENDER_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER_STATE, RenderState))
#define RENDER_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER_STATE, RenderStateClass))
#define IS_RENDER_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER_STATE))
#define IS_RENDER_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER_STATE))
#define RENDER_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER_STATE, RenderStateClass))

typedef struct _RenderState RenderState;
typedef struct _RenderStateClass RenderStateClass;

#define TYPE_RESOURCE3_DOBJECT (resource3_dobject_get_type ())
#define RESOURCE3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE3_DOBJECT, Resource3DObject))
#define RESOURCE3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE3_DOBJECT, Resource3DObjectClass))
#define IS_RESOURCE3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE3_DOBJECT))
#define IS_RESOURCE3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE3_DOBJECT))
#define RESOURCE3_DOBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE3_DOBJECT, Resource3DObjectClass))

typedef struct _Resource3DObject Resource3DObject;
typedef struct _Resource3DObjectClass Resource3DObjectClass;

#define TYPE_RESOURCE_TEXTURE (resource_texture_get_type ())
#define RESOURCE_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE_TEXTURE, ResourceTexture))
#define RESOURCE_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE_TEXTURE, ResourceTextureClass))
#define IS_RESOURCE_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE_TEXTURE))
#define IS_RESOURCE_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE_TEXTURE))
#define RESOURCE_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE_TEXTURE, ResourceTextureClass))

typedef struct _ResourceTexture ResourceTexture;
typedef struct _ResourceTextureClass ResourceTextureClass;

#define TYPE_IRESOURCE_STORE (iresource_store_get_type ())
#define IRESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IRESOURCE_STORE, IResourceStore))
#define IS_IRESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IRESOURCE_STORE))
#define IRESOURCE_STORE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IRESOURCE_STORE, IResourceStoreIface))

typedef struct _IResourceStore IResourceStore;
typedef struct _IResourceStoreIface IResourceStoreIface;

#define TYPE_RENDER3_DOBJECT (render3_dobject_get_type ())
#define RENDER3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER3_DOBJECT, Render3DObject))
#define RENDER3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER3_DOBJECT, Render3DObjectClass))
#define IS_RENDER3_DOBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER3_DOBJECT))
#define IS_RENDER3_DOBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER3_DOBJECT))
#define RENDER3_DOBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER3_DOBJECT, Render3DObjectClass))

typedef struct _Render3DObject Render3DObject;
typedef struct _Render3DObjectClass Render3DObjectClass;

#define TYPE_RENDER_TARGET (render_target_get_type ())
#define RENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RENDER_TARGET, RenderTarget))
#define RENDER_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RENDER_TARGET, RenderTargetClass))
#define IS_RENDER_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RENDER_TARGET))
#define IS_RENDER_TARGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RENDER_TARGET))
#define RENDER_TARGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RENDER_TARGET, RenderTargetClass))

typedef struct _RenderTarget RenderTarget;
typedef struct _RenderTargetClass RenderTargetClass;
typedef struct _RenderTargetPrivate RenderTargetPrivate;

#define TYPE_IOBJECT3_DRESOURCE_HANDLE (iobject3_dresource_handle_get_type ())
#define IOBJECT3_DRESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IOBJECT3_DRESOURCE_HANDLE, IObject3DResourceHandle))
#define IS_IOBJECT3_DRESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IOBJECT3_DRESOURCE_HANDLE))
#define IOBJECT3_DRESOURCE_HANDLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IOBJECT3_DRESOURCE_HANDLE, IObject3DResourceHandleIface))

typedef struct _IObject3DResourceHandle IObject3DResourceHandle;
typedef struct _IObject3DResourceHandleIface IObject3DResourceHandleIface;

#define TYPE_ITEXTURE_RESOURCE_HANDLE (itexture_resource_handle_get_type ())
#define ITEXTURE_RESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ITEXTURE_RESOURCE_HANDLE, ITextureResourceHandle))
#define IS_ITEXTURE_RESOURCE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ITEXTURE_RESOURCE_HANDLE))
#define ITEXTURE_RESOURCE_HANDLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_ITEXTURE_RESOURCE_HANDLE, ITextureResourceHandleIface))

typedef struct _ITextureResourceHandle ITextureResourceHandle;
typedef struct _ITextureResourceHandleIface ITextureResourceHandleIface;

#define TYPE_IWINDOW_TARGET (iwindow_target_get_type ())
#define IWINDOW_TARGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IWINDOW_TARGET, IWindowTarget))
#define IS_IWINDOW_TARGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IWINDOW_TARGET))
#define IWINDOW_TARGET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IWINDOW_TARGET, IWindowTargetIface))

typedef struct _IWindowTarget IWindowTarget;
typedef struct _IWindowTargetIface IWindowTargetIface;

#define TYPE_RESOURCE_STORE (resource_store_get_type ())
#define RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESOURCE_STORE, ResourceStore))
#define RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESOURCE_STORE, ResourceStoreClass))
#define IS_RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESOURCE_STORE))
#define IS_RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESOURCE_STORE))
#define RESOURCE_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESOURCE_STORE, ResourceStoreClass))

typedef struct _ResourceStore ResourceStore;
typedef struct _ResourceStoreClass ResourceStoreClass;

#define TYPE_OPEN_GL_RESOURCE_STORE (open_gl_resource_store_get_type ())
#define OPEN_GL_RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OPEN_GL_RESOURCE_STORE, OpenGLResourceStore))
#define OPEN_GL_RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OPEN_GL_RESOURCE_STORE, OpenGLResourceStoreClass))
#define IS_OPEN_GL_RESOURCE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OPEN_GL_RESOURCE_STORE))
#define IS_OPEN_GL_RESOURCE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OPEN_GL_RESOURCE_STORE))
#define OPEN_GL_RESOURCE_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OPEN_GL_RESOURCE_STORE, OpenGLResourceStoreClass))

typedef struct _OpenGLResourceStore OpenGLResourceStore;
typedef struct _OpenGLResourceStoreClass OpenGLResourceStoreClass;
#define _render_state_unref0(var) ((var == NULL) ? NULL : (var = (render_state_unref (var), NULL)))
#define _g_mutex_free0(var) ((var == NULL) ? NULL : (var = (g_mutex_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _resource3_dobject_unref0(var) ((var == NULL) ? NULL : (var = (resource3_dobject_unref (var), NULL)))
#define _resource_texture_unref0(var) ((var == NULL) ? NULL : (var = (resource_texture_unref (var), NULL)))

struct _IResourceStoreIface {
	GTypeInterface parent_iface;
	Render3DObject* (*load_3D_object) (IResourceStore* self, const gchar* name);
};

struct _IRenderTargetIface {
	GTypeInterface parent_iface;
	void (*set_state) (IRenderTarget* self, RenderState* state);
	gboolean (*start) (IRenderTarget* self);
	void (*stop) (IRenderTarget* self);
	guint (*load_3D_object) (IRenderTarget* self, Resource3DObject* object);
	guint (*load_texture) (IRenderTarget* self, ResourceTexture* texture);
	IResourceStore* (*get_resource_store) (IRenderTarget* self);
};

struct _IObject3DResourceHandleIface {
	GTypeInterface parent_iface;
};

struct _ITextureResourceHandleIface {
	GTypeInterface parent_iface;
};

struct _IWindowTargetIface {
	GTypeInterface parent_iface;
	void (*swap) (IWindowTarget* self);
	void (*pump_events) (IWindowTarget* self);
	gboolean (*get_fullscreen) (IWindowTarget* self);
	void (*set_fullscreen) (IWindowTarget* self, gboolean value);
	gint (*get_width) (IWindowTarget* self);
	gint (*get_height) (IWindowTarget* self);
};

struct _RenderTarget {
	GObject parent_instance;
	RenderTargetPrivate * priv;
	IWindowTarget* window;
	OpenGLResourceStore* store;
};

struct _RenderTargetClass {
	GObjectClass parent_class;
	void (*render) (RenderTarget* self, RenderState* state);
	gboolean (*init) (RenderTarget* self);
	IObject3DResourceHandle* (*do_load_3D_object) (RenderTarget* self, Resource3DObject* obj);
	ITextureResourceHandle* (*do_load_texture) (RenderTarget* self, ResourceTexture* texture);
};

struct _RenderTargetPrivate {
	RenderState* current_state;
	RenderState* buffer_state;
	gboolean running;
	GMutex* state_mutex;
	gboolean initialized;
	gboolean init_status;
	GMutex* init_mutex;
	GMutex* resource_mutex;
	guint handle_texture_ID;
	guint handle_3D_object_ID;
	GeeArrayList* to_load_3D_objects;
	GeeArrayList* to_load_textures;
	GeeArrayList* handles_3D_objects;
	GeeArrayList* handles_textures;
};

typedef void (*ThreadingDel0Arg) (void* user_data);

static gpointer render_target_parent_class = NULL;
static IRenderTargetIface* render_target_irender_target_parent_iface = NULL;

gpointer render_state_ref (gpointer instance);
void render_state_unref (gpointer instance);
GParamSpec* param_spec_render_state (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render_state (GValue* value, gpointer v_object);
void value_take_render_state (GValue* value, gpointer v_object);
gpointer value_get_render_state (const GValue* value);
GType render_state_get_type (void) G_GNUC_CONST;
gpointer resource3_dobject_ref (gpointer instance);
void resource3_dobject_unref (gpointer instance);
GParamSpec* param_spec_resource3_dobject (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_resource3_dobject (GValue* value, gpointer v_object);
void value_take_resource3_dobject (GValue* value, gpointer v_object);
gpointer value_get_resource3_dobject (const GValue* value);
GType resource3_dobject_get_type (void) G_GNUC_CONST;
gpointer resource_texture_ref (gpointer instance);
void resource_texture_unref (gpointer instance);
GParamSpec* param_spec_resource_texture (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_resource_texture (GValue* value, gpointer v_object);
void value_take_resource_texture (GValue* value, gpointer v_object);
gpointer value_get_resource_texture (const GValue* value);
GType resource_texture_get_type (void) G_GNUC_CONST;
gpointer render3_dobject_ref (gpointer instance);
void render3_dobject_unref (gpointer instance);
GParamSpec* param_spec_render3_dobject (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_render3_dobject (GValue* value, gpointer v_object);
void value_take_render3_dobject (GValue* value, gpointer v_object);
gpointer value_get_render3_dobject (const GValue* value);
GType render3_dobject_get_type (void) G_GNUC_CONST;
GType iresource_store_get_type (void) G_GNUC_CONST;
GType irender_target_get_type (void) G_GNUC_CONST;
void irender_target_set_state (IRenderTarget* self, RenderState* state);
gboolean irender_target_start (IRenderTarget* self);
void irender_target_stop (IRenderTarget* self);
guint irender_target_load_3D_object (IRenderTarget* self, Resource3DObject* object);
guint irender_target_load_texture (IRenderTarget* self, ResourceTexture* texture);
IResourceStore* irender_target_get_resource_store (IRenderTarget* self);
GType render_target_get_type (void) G_GNUC_CONST;
GType iobject3_dresource_handle_get_type (void) G_GNUC_CONST;
GType itexture_resource_handle_get_type (void) G_GNUC_CONST;
GType iwindow_target_get_type (void) G_GNUC_CONST;
GType resource_store_get_type (void) G_GNUC_CONST;
GType open_gl_resource_store_get_type (void) G_GNUC_CONST;
#define RENDER_TARGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_RENDER_TARGET, RenderTargetPrivate))
enum  {
	RENDER_TARGET_DUMMY_PROPERTY,
	RENDER_TARGET_RESOURCE_STORE
};
RenderTarget* render_target_construct (GType object_type, IWindowTarget* window);
static void render_target_real_set_state (IRenderTarget* base, RenderState* state);
static gboolean render_target_real_start (IRenderTarget* base);
void threading_start0 (ThreadingDel0Arg function, void* function_target);
static void render_target_render_thread (RenderTarget* self);
static void _render_target_render_thread_threading_del0_arg (gpointer self);
void iwindow_target_pump_events (IWindowTarget* self);
static void render_target_real_stop (IRenderTarget* base);
static guint render_target_real_load_3D_object (IRenderTarget* base, Resource3DObject* obj);
static guint render_target_real_load_texture (IRenderTarget* base, ResourceTexture* texture);
IObject3DResourceHandle* render_target_get_3D_object (RenderTarget* self, guint handle);
ITextureResourceHandle* render_target_get_texture (RenderTarget* self, guint handle);
gboolean render_target_init (RenderTarget* self);
static void render_target_load_resources (RenderTarget* self);
void render_target_render (RenderTarget* self, RenderState* state);
IObject3DResourceHandle* render_target_do_load_3D_object (RenderTarget* self, Resource3DObject* obj);
ITextureResourceHandle* render_target_do_load_texture (RenderTarget* self, ResourceTexture* texture);
static void render_target_real_render (RenderTarget* self, RenderState* state);
static gboolean render_target_real_init (RenderTarget* self);
static IObject3DResourceHandle* render_target_real_do_load_3D_object (RenderTarget* self, Resource3DObject* obj);
static ITextureResourceHandle* render_target_real_do_load_texture (RenderTarget* self, ResourceTexture* texture);
static void render_target_finalize (GObject* obj);
static void _vala_render_target_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);


void irender_target_set_state (IRenderTarget* self, RenderState* state) {
	IRENDER_TARGET_GET_INTERFACE (self)->set_state (self, state);
}


gboolean irender_target_start (IRenderTarget* self) {
	return IRENDER_TARGET_GET_INTERFACE (self)->start (self);
}


void irender_target_stop (IRenderTarget* self) {
	IRENDER_TARGET_GET_INTERFACE (self)->stop (self);
}


guint irender_target_load_3D_object (IRenderTarget* self, Resource3DObject* object) {
	return IRENDER_TARGET_GET_INTERFACE (self)->load_3D_object (self, object);
}


guint irender_target_load_texture (IRenderTarget* self, ResourceTexture* texture) {
	return IRENDER_TARGET_GET_INTERFACE (self)->load_texture (self, texture);
}


IResourceStore* irender_target_get_resource_store (IRenderTarget* self) {
	return IRENDER_TARGET_GET_INTERFACE (self)->get_resource_store (self);
}


static void irender_target_base_init (IRenderTargetIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_object_interface_install_property (iface, g_param_spec_object ("resource-store", "resource-store", "resource-store", TYPE_IRESOURCE_STORE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	}
}


GType irender_target_get_type (void) {
	static volatile gsize irender_target_type_id__volatile = 0;
	if (g_once_init_enter (&irender_target_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IRenderTargetIface), (GBaseInitFunc) irender_target_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType irender_target_type_id;
		irender_target_type_id = g_type_register_static (G_TYPE_INTERFACE, "IRenderTarget", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (irender_target_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&irender_target_type_id__volatile, irender_target_type_id);
	}
	return irender_target_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


RenderTarget* render_target_construct (GType object_type, IWindowTarget* window) {
	RenderTarget * self = NULL;
	IWindowTarget* _tmp0_;
	g_return_val_if_fail (window != NULL, NULL);
	self = (RenderTarget*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (window);
	_g_object_unref0 (self->window);
	self->window = _tmp0_;
	return self;
}


static gpointer _render_state_ref0 (gpointer self) {
	return self ? render_state_ref (self) : NULL;
}


static void render_target_real_set_state (IRenderTarget* base, RenderState* state) {
	RenderTarget * self;
	RenderState* _tmp0_;
	self = (RenderTarget*) base;
	g_return_if_fail (state != NULL);
	g_mutex_lock (self->priv->state_mutex);
	_tmp0_ = _render_state_ref0 (state);
	_render_state_unref0 (self->priv->buffer_state);
	self->priv->buffer_state = _tmp0_;
	g_mutex_unlock (self->priv->state_mutex);
}


static void _render_target_render_thread_threading_del0_arg (gpointer self) {
	render_target_render_thread (self);
}


static gboolean render_target_real_start (IRenderTarget* base) {
	RenderTarget * self;
	gboolean result = FALSE;
	self = (RenderTarget*) base;
	threading_start0 (_render_target_render_thread_threading_del0_arg, self);
	while (TRUE) {
		g_mutex_lock (self->priv->init_mutex);
		if (self->priv->initialized) {
			g_mutex_unlock (self->priv->init_mutex);
			break;
		}
		g_mutex_unlock (self->priv->init_mutex);
		iwindow_target_pump_events (self->window);
		g_usleep ((gulong) 10000);
	}
	result = self->priv->init_status;
	return result;
}


static void render_target_real_stop (IRenderTarget* base) {
	RenderTarget * self;
	self = (RenderTarget*) base;
	self->priv->running = FALSE;
}


static guint render_target_real_load_3D_object (IRenderTarget* base, Resource3DObject* obj) {
	RenderTarget * self;
	guint result = 0U;
	guint ret;
	guint _tmp0_;
	self = (RenderTarget*) base;
	g_return_val_if_fail (obj != NULL, 0U);
	ret = (guint) 0;
	g_mutex_lock (self->priv->resource_mutex);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->to_load_3D_objects, obj);
	_tmp0_ = self->priv->handle_3D_object_ID;
	self->priv->handle_3D_object_ID = _tmp0_ + 1;
	ret = _tmp0_;
	g_mutex_unlock (self->priv->resource_mutex);
	result = ret;
	return result;
}


static guint render_target_real_load_texture (IRenderTarget* base, ResourceTexture* texture) {
	RenderTarget * self;
	guint result = 0U;
	guint ret;
	guint _tmp0_;
	self = (RenderTarget*) base;
	g_return_val_if_fail (texture != NULL, 0U);
	ret = (guint) 0;
	g_mutex_lock (self->priv->resource_mutex);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->to_load_textures, texture);
	_tmp0_ = self->priv->handle_texture_ID;
	self->priv->handle_texture_ID = _tmp0_ + 1;
	ret = _tmp0_;
	g_mutex_unlock (self->priv->resource_mutex);
	result = ret;
	return result;
}


IObject3DResourceHandle* render_target_get_3D_object (RenderTarget* self, guint handle) {
	IObject3DResourceHandle* result = NULL;
	IObject3DResourceHandle* _tmp0_ = NULL;
	gint _tmp1_;
	IObject3DResourceHandle* _tmp3_;
	IObject3DResourceHandle* ret;
	g_return_val_if_fail (self != NULL, NULL);
	g_mutex_lock (self->priv->resource_mutex);
	_tmp1_ = gee_collection_get_size ((GeeCollection*) self->priv->handles_3D_objects);
	if (handle > _tmp1_) {
		_g_object_unref0 (_tmp0_);
		_tmp0_ = NULL;
	} else {
		gpointer _tmp2_ = NULL;
		_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->handles_3D_objects, ((gint) handle) - 1);
		_g_object_unref0 (_tmp0_);
		_tmp0_ = (IObject3DResourceHandle*) _tmp2_;
	}
	_tmp3_ = _g_object_ref0 (_tmp0_);
	ret = _tmp3_;
	g_mutex_unlock (self->priv->resource_mutex);
	result = ret;
	_g_object_unref0 (_tmp0_);
	return result;
}


ITextureResourceHandle* render_target_get_texture (RenderTarget* self, guint handle) {
	ITextureResourceHandle* result = NULL;
	ITextureResourceHandle* _tmp0_ = NULL;
	gint _tmp1_;
	ITextureResourceHandle* _tmp3_;
	ITextureResourceHandle* ret;
	g_return_val_if_fail (self != NULL, NULL);
	g_mutex_lock (self->priv->resource_mutex);
	_tmp1_ = gee_collection_get_size ((GeeCollection*) self->priv->handles_textures);
	if (handle > _tmp1_) {
		_g_object_unref0 (_tmp0_);
		_tmp0_ = NULL;
	} else {
		gpointer _tmp2_ = NULL;
		_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->handles_textures, ((gint) handle) - 1);
		_g_object_unref0 (_tmp0_);
		_tmp0_ = (ITextureResourceHandle*) _tmp2_;
	}
	_tmp3_ = _g_object_ref0 (_tmp0_);
	ret = _tmp3_;
	g_mutex_unlock (self->priv->resource_mutex);
	result = ret;
	_g_object_unref0 (_tmp0_);
	return result;
}


static void render_target_render_thread (RenderTarget* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = render_target_init (self);
	self->priv->init_status = _tmp0_;
	g_mutex_lock (self->priv->init_mutex);
	self->priv->initialized = TRUE;
	g_mutex_unlock (self->priv->init_mutex);
	if (!self->priv->init_status) {
		return;
	}
	self->priv->running = TRUE;
	while (TRUE) {
		RenderState* _tmp1_;
		if (!self->priv->running) {
			break;
		}
		g_mutex_lock (self->priv->state_mutex);
		_tmp1_ = _render_state_ref0 (self->priv->buffer_state);
		_render_state_unref0 (self->priv->current_state);
		self->priv->current_state = _tmp1_;
		g_mutex_unlock (self->priv->state_mutex);
		render_target_load_resources (self);
		if (self->priv->current_state == NULL) {
			g_usleep ((gulong) 1000);
			continue;
		}
		render_target_render (self, self->priv->current_state);
		g_usleep ((gulong) 5000);
	}
}


static void render_target_load_resources (RenderTarget* self) {
	g_return_if_fail (self != NULL);
	g_mutex_lock (self->priv->resource_mutex);
	while (TRUE) {
		gint _tmp0_;
		gpointer _tmp1_ = NULL;
		Resource3DObject* obj;
		IObject3DResourceHandle* _tmp2_ = NULL;
		IObject3DResourceHandle* _tmp3_;
		_tmp0_ = gee_collection_get_size ((GeeCollection*) self->priv->to_load_3D_objects);
		if (!(_tmp0_ != 0)) {
			break;
		}
		_tmp1_ = gee_abstract_list_remove_at ((GeeAbstractList*) self->priv->to_load_3D_objects, 0);
		obj = (Resource3DObject*) _tmp1_;
		g_mutex_unlock (self->priv->resource_mutex);
		_tmp2_ = render_target_do_load_3D_object (self, obj);
		_tmp3_ = _tmp2_;
		gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->handles_3D_objects, _tmp3_);
		_g_object_unref0 (_tmp3_);
		g_mutex_lock (self->priv->resource_mutex);
		_resource3_dobject_unref0 (obj);
	}
	while (TRUE) {
		gint _tmp4_;
		gpointer _tmp5_ = NULL;
		ResourceTexture* texture;
		ITextureResourceHandle* _tmp6_ = NULL;
		ITextureResourceHandle* _tmp7_;
		_tmp4_ = gee_collection_get_size ((GeeCollection*) self->priv->to_load_textures);
		if (!(_tmp4_ != 0)) {
			break;
		}
		_tmp5_ = gee_abstract_list_remove_at ((GeeAbstractList*) self->priv->to_load_textures, 0);
		texture = (ResourceTexture*) _tmp5_;
		g_mutex_unlock (self->priv->resource_mutex);
		_tmp6_ = render_target_do_load_texture (self, texture);
		_tmp7_ = _tmp6_;
		gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->handles_textures, _tmp7_);
		_g_object_unref0 (_tmp7_);
		g_mutex_lock (self->priv->resource_mutex);
		_resource_texture_unref0 (texture);
	}
	g_mutex_unlock (self->priv->resource_mutex);
}


static void render_target_real_render (RenderTarget* self, RenderState* state) {
	g_return_if_fail (self != NULL);
	g_critical ("Type `%s' does not implement abstract method `render_target_render'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void render_target_render (RenderTarget* self, RenderState* state) {
	RENDER_TARGET_GET_CLASS (self)->render (self, state);
}


static gboolean render_target_real_init (RenderTarget* self) {
	g_return_val_if_fail (self != NULL, FALSE);
	g_critical ("Type `%s' does not implement abstract method `render_target_init'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return FALSE;
}


gboolean render_target_init (RenderTarget* self) {
	return RENDER_TARGET_GET_CLASS (self)->init (self);
}


static IObject3DResourceHandle* render_target_real_do_load_3D_object (RenderTarget* self, Resource3DObject* obj) {
	g_return_val_if_fail (self != NULL, NULL);
	g_critical ("Type `%s' does not implement abstract method `render_target_do_load_3D_object'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


IObject3DResourceHandle* render_target_do_load_3D_object (RenderTarget* self, Resource3DObject* obj) {
	return RENDER_TARGET_GET_CLASS (self)->do_load_3D_object (self, obj);
}


static ITextureResourceHandle* render_target_real_do_load_texture (RenderTarget* self, ResourceTexture* texture) {
	g_return_val_if_fail (self != NULL, NULL);
	g_critical ("Type `%s' does not implement abstract method `render_target_do_load_texture'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


ITextureResourceHandle* render_target_do_load_texture (RenderTarget* self, ResourceTexture* texture) {
	return RENDER_TARGET_GET_CLASS (self)->do_load_texture (self, texture);
}


static IResourceStore* render_target_real_get_resource_store (IRenderTarget* base) {
	IResourceStore* result;
	RenderTarget* self;
	self = (RenderTarget*) base;
	result = (IResourceStore*) self->store;
	return result;
}


static void render_target_class_init (RenderTargetClass * klass) {
	render_target_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RenderTargetPrivate));
	RENDER_TARGET_CLASS (klass)->render = render_target_real_render;
	RENDER_TARGET_CLASS (klass)->init = render_target_real_init;
	RENDER_TARGET_CLASS (klass)->do_load_3D_object = render_target_real_do_load_3D_object;
	RENDER_TARGET_CLASS (klass)->do_load_texture = render_target_real_do_load_texture;
	G_OBJECT_CLASS (klass)->get_property = _vala_render_target_get_property;
	G_OBJECT_CLASS (klass)->finalize = render_target_finalize;
	g_object_class_override_property (G_OBJECT_CLASS (klass), RENDER_TARGET_RESOURCE_STORE, "resource-store");
}


static void render_target_irender_target_interface_init (IRenderTargetIface * iface) {
	render_target_irender_target_parent_iface = g_type_interface_peek_parent (iface);
	iface->set_state = (void (*)(IRenderTarget* ,RenderState*)) render_target_real_set_state;
	iface->start = (gboolean (*)(IRenderTarget*)) render_target_real_start;
	iface->stop = (void (*)(IRenderTarget*)) render_target_real_stop;
	iface->load_3D_object = (guint (*)(IRenderTarget* ,Resource3DObject*)) render_target_real_load_3D_object;
	iface->load_texture = (guint (*)(IRenderTarget* ,ResourceTexture*)) render_target_real_load_texture;
	iface->get_resource_store = render_target_real_get_resource_store;
}


static void render_target_instance_init (RenderTarget * self) {
	GMutex* _tmp0_ = NULL;
	GMutex* _tmp1_ = NULL;
	GMutex* _tmp2_ = NULL;
	GeeArrayList* _tmp3_ = NULL;
	GeeArrayList* _tmp4_ = NULL;
	GeeArrayList* _tmp5_ = NULL;
	GeeArrayList* _tmp6_ = NULL;
	self->priv = RENDER_TARGET_GET_PRIVATE (self);
	self->priv->current_state = NULL;
	self->priv->buffer_state = NULL;
	self->priv->running = FALSE;
	_tmp0_ = g_mutex_new ();
	self->priv->state_mutex = _tmp0_;
	self->priv->initialized = FALSE;
	_tmp1_ = g_mutex_new ();
	self->priv->init_mutex = _tmp1_;
	_tmp2_ = g_mutex_new ();
	self->priv->resource_mutex = _tmp2_;
	self->priv->handle_texture_ID = (guint) 1;
	self->priv->handle_3D_object_ID = (guint) 1;
	_tmp3_ = gee_array_list_new (TYPE_RESOURCE3_DOBJECT, (GBoxedCopyFunc) resource3_dobject_ref, resource3_dobject_unref, NULL);
	self->priv->to_load_3D_objects = _tmp3_;
	_tmp4_ = gee_array_list_new (TYPE_RESOURCE_TEXTURE, (GBoxedCopyFunc) resource_texture_ref, resource_texture_unref, NULL);
	self->priv->to_load_textures = _tmp4_;
	_tmp5_ = gee_array_list_new (TYPE_IOBJECT3_DRESOURCE_HANDLE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->handles_3D_objects = _tmp5_;
	_tmp6_ = gee_array_list_new (TYPE_ITEXTURE_RESOURCE_HANDLE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	self->priv->handles_textures = _tmp6_;
}


static void render_target_finalize (GObject* obj) {
	RenderTarget * self;
	self = RENDER_TARGET (obj);
	_render_state_unref0 (self->priv->current_state);
	_render_state_unref0 (self->priv->buffer_state);
	_g_mutex_free0 (self->priv->state_mutex);
	_g_mutex_free0 (self->priv->init_mutex);
	_g_mutex_free0 (self->priv->resource_mutex);
	_g_object_unref0 (self->priv->to_load_3D_objects);
	_g_object_unref0 (self->priv->to_load_textures);
	_g_object_unref0 (self->priv->handles_3D_objects);
	_g_object_unref0 (self->priv->handles_textures);
	_g_object_unref0 (self->window);
	_g_object_unref0 (self->store);
	G_OBJECT_CLASS (render_target_parent_class)->finalize (obj);
}


GType render_target_get_type (void) {
	static volatile gsize render_target_type_id__volatile = 0;
	if (g_once_init_enter (&render_target_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RenderTargetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) render_target_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RenderTarget), 0, (GInstanceInitFunc) render_target_instance_init, NULL };
		static const GInterfaceInfo irender_target_info = { (GInterfaceInitFunc) render_target_irender_target_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType render_target_type_id;
		render_target_type_id = g_type_register_static (G_TYPE_OBJECT, "RenderTarget", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_type_add_interface_static (render_target_type_id, TYPE_IRENDER_TARGET, &irender_target_info);
		g_once_init_leave (&render_target_type_id__volatile, render_target_type_id);
	}
	return render_target_type_id__volatile;
}


static void _vala_render_target_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	RenderTarget * self;
	self = RENDER_TARGET (object);
	switch (property_id) {
		case RENDER_TARGET_RESOURCE_STORE:
		g_value_set_object (value, irender_target_get_resource_store ((IRenderTarget*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



